[{"name":"do_login_command","owner":2,"perms":173,"preposition":-1,"code":["\"...This code should only be run as a server task...\";","if (callers())","return E_PERM;","endif","if (typeof(h = $network:incoming_connection(player)) == OBJ)","\"connected to an object\";","return h;","elseif (h)","return 0;","endif","host = $string_utils:connection_hostname(connection_name(player));","if ($login:redlisted(host))","boot_player(player);","server_log(tostr(\"REDLISTED: \", player, \" from \", host));","return 0;","endif","if (!$login:maybe_limit_commands())","args = $login:parse_command(@args);","return $login:(args[1])(@listdelete(args, 1));","endif"]},{"name":"server_started","owner":2,"perms":173,"preposition":-1,"code":["if (!callers())","$last_restart_time = time();","$network:server_started();","$login:server_started();","endif"]},{"name":"core_objects","owner":2,"perms":173,"preposition":-1,"code":["saved = {#0};","for p in (properties(#0))","v = #0.(p);","if ((typeof(v) == OBJ) && valid(v))","saved = setadd(saved, v);","endif","endfor","for o in (saved)","p = parent(o);","while (valid(p))","saved = setadd(saved, p);","p = parent(p);","endwhile","endfor","return $list_utils:sort(saved);"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","pass();","if (\"server_started\" in verbs(this))","code = {\"if (!callers())\", \"$last_restart_time = time(); $network:server_started(); $login:server_started(); endif\"};","set_verb_code(this, \"server_started\", code);","endif","if (\"uptime_since\" in verbs(this))","delete_verb(this, \"uptime_since\");","endif","if (\"do_command\" in verbs(this))","delete_verb(this, \"do_command\");","endif","`delete_verb(this, \"checkpoint_finished\") ! E_VERBNF';","$core_history = {{$network.MOO_name, server_version(), time()}, @$core_history};","$shutdown_message = \"\";","$shutdown_time = 0;","$dump_interval = 3600;","$gripe_recipients = {player};","$class_registry = {{\"generics\", \"Generic objects intended for use as the parents of new objects\", {$room, $exit, $thing, $note, $letter, $container, $root_class, $player, $prog, $wiz, $generic_editor, $mail_recipient, $mail_agent}}, {\"utilities\", \"Objects holding useful general-purpose verbs\", children($generic_utils)}};","`set_verb_code(this, \"user_connected\", verb_code(this, \"user_connected(core)\")) ! ANY';","`delete_verb(this, \"user_connected(core)\") ! ANY';","`set_verb_code(this, \"user_reconnected\", verb_code(this, \"user_reconnected(core)\")) ! ANY';","`delete_verb(this, \"user_reconnected(core)\") ! ANY';","for v in ({\"do_login_command\", \"server_started\"})","c = {};","for i in (verb_code(this, v))","c = {@c, strsub(i, \"$local.login\", \"$login\")};","endfor","set_verb_code(#0, v, c);","endfor","endif"]},{"name":"user_created user_connected","owner":2,"perms":173,"preposition":-1,"code":["\"Copied from The System Object (#0):user_connected by Slartibartfast (#4242) Sun May 21 18:14:16 1995 PDT\";","if (callers())","return;","endif","user = args[1];","set_task_perms(user);","try","user.location:confunc(user);","user:confunc();","except id (ANY)","user:tell(\"Confunc failed: \", id[2], \".\");","for tb in (id[4])","user:tell(\"... called from \", tb[4], \":\", tb[2], (tb[4] != tb[1]) ? tostr(\" (this == \", tb[1], \")\") | \"\", \", line \", tb[6]);","endfor","user:tell(\"(End of traceback)\");","endtry"]},{"name":"user_disconnected user_client_disconnected","owner":2,"perms":173,"preposition":-1,"code":["if (callers())","return;","endif","if (args[1] < #0)","\"not logged in user.  probably should do something clever here involving Carrot's no-spam hack.  --yduJ\";","return;","endif","user = args[1];","user.last_disconnect_time = time();","set_task_perms(user);","where = user.location;","`user:disfunc() ! ANY => 0';","if (user.location != where)","`where.location:disfunc(user) ! ANY => 0';","endif","`user.location:disfunc(user) ! ANY => 0';"]},{"name":"bf_chparent chparent","owner":2,"perms":173,"preposition":-1,"code":["\"chparent(object, new-parent) -- see help on the builtin.\";","who = caller_perms();","{what, papa} = args;","if (typeof(what) != OBJ)","retval = E_TYPE;","elseif (!valid(what))","retval = E_INVARG;","elseif (typeof(papa) != OBJ)","retval = E_TYPE;","elseif ((!valid(papa)) && (papa != #-1))","retval = E_INVIND;","elseif (!$perm_utils:controls(who, what))","retval = E_PERM;","elseif ((is_player(what) && (!$object_utils:isa(papa, $player_class))) && (!who.wizard))","retval = E_PERM;","elseif ((is_player(what) && (!$object_utils:isa(what, $player_class))) && (!who.wizard))","retval = E_PERM;","elseif ((children(what) && $object_utils:isa(what, $player_class)) && (!$object_utils:isa(papa, $player_class)))","retval = E_PERM;","elseif ((!valid(papa)) || ($perm_utils:controls(who, papa) || papa.f))","retval = `chparent(@args) ! ANY';","else","retval = E_PERM;","endif","return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;"]},{"name":"bf_add_verb add_verb","owner":2,"perms":173,"preposition":-1,"code":["\"add_verb() -- see help on the builtin for more information. This verb is called by the server when $server_options.protect_add_verb exists and is true and caller_perms() are not wizardly.\";","who = caller_perms();","{what, info, verbargs} = args;","if (typeof(what) != OBJ)","retval = E_TYPE;","elseif (!valid(what))","retval = E_INVARG;","elseif ((!$perm_utils:controls(who, what)) && (!what.w))","\"caller_perms() is not allowed to hack on the object in question\";","retval = E_PERM;","elseif (!$perm_utils:controls(who, info[1]))","\"caller_perms() is not permitted to add a verb with the specified owner.\";","retval = E_PERM;","elseif (index(info[2], \"w\") && (!$server_options.permit_writable_verbs))","retval = E_INVARG;","elseif (!$quota_utils:verb_addition_permitted(who))","retval = E_QUOTA;","elseif (((what.owner != who) && (!who.wizard)) && (!$quota_utils:verb_addition_permitted(what.owner)))","retval = E_QUOTA;","elseif (!who.programmer)","retval = E_PERM;","else","\"we now know that the caller's perms control the object or the object is writable, and we know that the caller's perms control the prospective verb owner (by more traditional means)\";","retval = `add_verb(@args) ! ANY';","endif","return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;"]},{"name":"bf_add_property add_property","owner":2,"perms":173,"preposition":-1,"code":["\"add_property() -- see help on the builtin for more information. This verb is called by the server when $server_options.protect_add_property exists and is true and caller_perms() are not wizardly.\";","who = caller_perms();","{what, propname, value, info} = args;","if (typeof(what) != OBJ)","retval = E_TYPE;","elseif (!valid(what))","retval = E_INVARG;","elseif ((!$perm_utils:controls(who, what)) && (!what.w))","retval = E_PERM;","elseif (!$perm_utils:controls(who, info[1]))","retval = E_PERM;","elseif (!$quota_utils:property_addition_permitted(who))","retval = E_QUOTA;","elseif (((what.owner != who) && (!who.wizard)) && (!$quota_utils:property_addition_permitted(what.owner)))","retval = E_QUOTA;","\"elseif (!who.programmer)\";","\"  return E_PERM;     I wanted to do this, but $builder:@newmessage relies upon nonprogs being able to call add_property.  --Nosredna\";","elseif ((propname in {\"object_size\", \"size_quota\", \"queued_task_limit\"}) && (!who.wizard))","retval = E_PERM;","else","\"we now know that the caller's perms control the object (or the object is writable), and that the caller's perms are permitted to control the new property's owner.\";","retval = `add_property(@args) ! ANY';","endif","return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;"]},{"name":"bf_recycle recycle","owner":2,"perms":173,"preposition":-1,"code":["\"recycle(object) -- see help on the builtin. This verb is called by the server when $server_options.protect_recycle exists and is true and caller_perms() are not wizardly.\";","if (!valid(what = args[1]))","retval = E_INVARG;","elseif (!$perm_utils:controls(who = caller_perms(), what))","retval = E_PERM;","elseif ((p = is_player(what)) && (!who.wizard))","for p in ($wiz_utils:connected_wizards_unadvertised())","p:tell($string_utils:pronoun_sub(\"%N (%#) is currently trying to recycle %t (%[#t])\", who, what));","endfor","retval = E_PERM;","else","if (p)","$wiz_utils:unset_player(what);","endif","retval = `recycle(what) ! ANY';","if (typeof(retval) != ERR)","$recycler:kill_all_tasks(what);","endif","endif","return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;"]},{"name":"user_reconnected","owner":2,"perms":173,"preposition":-1,"code":["if (callers())","return;","endif","if ($object_utils:isa(user = args[1], $guest))","\"from $guest:boot\";","oldloc = user.location;","move(user, $nothing);","\"..force enterfunc to be called so that the newbie gets a room description.\";","move(user, user.home);","user:do_reset();","if ($object_utils:isa(oldloc, $room))","oldloc:announce(\"In the distance you hear someone's alarm clock going off.\");","if (oldloc != user.location)","oldloc:announce(user.name, \" wavers and vanishes into insubstantial mist.\");","else","oldloc:announce(user.name, \" undergoes a wrenching personality shift.\");","endif","endif","set_task_perms(user);","`user:confunc() ! ANY';","endif"]},{"name":"bf_set_verb_info set_verb_info","owner":2,"perms":173,"preposition":-1,"code":["\"set_verb_info() -- see help on the builtin for more information. This verb is called by the server when $server_options.protect_set_verb_info exists and is true and caller_perms() are not wizardly.\";","{o, v, i} = args;","if (typeof(vi = `verb_info(o, v) ! ANY') == ERR)","\"probably verb doesn't exist\";","retval = vi;","elseif (!$perm_utils:controls(cp = caller_perms(), vi[1]))","\"perms don't control the current verb owner\";","retval = E_PERM;","elseif ((typeof(i) != LIST) || (typeof(no = i[1]) != OBJ))","\"info is malformed\";","retval = E_TYPE;","elseif ((!valid(no)) || (!is_player(no)))","\"invalid new verb owner\";","retval = E_INVARG;","elseif (!$perm_utils:controls(cp, no))","\"perms don't control prospective verb owner\";","retval = E_PERM;","elseif (index(i[2], \"w\") && (!`$server_options.permit_writable_verbs ! E_PROPNF, E_INVIND => 1'))","retval = E_INVARG;","else","retval = `set_verb_info(o, v, i) ! ANY';","endif","return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;"]},{"name":"bf_match match","owner":2,"perms":173,"preposition":-1,"code":["m = `match(@args) ! ANY';","return ((typeof(m) == ERR) && $code_utils:dflag_on()) ? raise(m) | m;","if ((length(args[1]) > 256) && index(args[2], \"*\"))","return E_INVARG;","else","return match(@args);","endif"]},{"name":"bf_rmatch rmatch","owner":2,"perms":173,"preposition":-1,"code":["r = `rmatch(@args) ! ANY';","return ((typeof(r) == ERR) && $code_utils:dflag_on()) ? raise(r) | r;","if ((length(args[1]) > 256) && index(args[2], \"*\"))","return E_INVARG;","else","return rmatch(@args);","endif"]},{"name":"do_out_of_band_command doobc","owner":2,"perms":173,"preposition":-1,"code":["\"do_out_of_band_command -- a cheap and very dirty do_out_of_band verb.  Forwards to verb on player with same name if it exists, otherwise forwards to $login.  May only be called by the server in response to an out of band command, otherwise E_PERM is returned.\";","if (((caller == #-1) && (caller_perms() == #-1)) && (callers() == {}))","if (valid(player) && is_player(player))","set_task_perms(player);","player:do_out_of_band_command(@args);","else","$login:do_out_of_band_command(@args);","endif","else","return E_PERM;","endif"]},{"name":"handle_uncaught_error","owner":2,"perms":173,"preposition":-1,"code":["if (!callers())","{code, msg, value, stack, traceback} = args;","if (!$object_utils:connected(player))","\"Mail the player the traceback if e isn't connected.\";","$mail_agent:send_message(#0, player, {\"traceback\", $gripe_recipients}, traceback);","endif","\"now let the player do something with it if e wants...\";","return `player:(verb)(@args) ! ANY';","endif"]},{"name":"bf_force_input","owner":2,"perms":173,"preposition":-1,"code":["\"Copied from Jay (#3920):bf_force_input Mon Jun 16 20:55:27 1997 PDT\";","\"force_input(conn, line [, at-front])\";","\"see help on the builtin for more information. This verb is called by the server when $server_options.protect_force_input exists and is true and caller_perms() are not wizardly.\";","{conn, line, ?at_front = 0} = args;","if (caller_perms() != conn)","retval = E_PERM;","elseif (conn in $login.newted)","retval = E_PERM;","else","retval = `force_input(@args) ! ANY';","this.force_input_count = this.force_input_count + 1;","endif","return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;"]},{"name":"moveto","owner":2,"perms":173,"preposition":-1,"code":["\"Let's keep bozos from partying.  --Nosredna the partypooper\";","return pass(#-1);"]},{"name":"bf_set_property_info set_property_info","owner":2,"perms":173,"preposition":-1,"code":["who = caller_perms();","retval = 0;","try","{what, propname, info} = args;","except (E_ARGS)","retval = E_ARGS;","endtry","try","{owner, perms, ?newname = 0} = info;","except (E_ARGS)","retval = E_ARGS;","except (E_TYPE)","retval = E_TYPE;","endtry","if (retval != 0)","elseif ((newname in {\"object_size\", \"size_quota\", \"queued_task_limit\"}) && (!who.wizard))","retval = E_PERM;","else","set_task_perms(who);","retval = `set_property_info(@args) ! ANY';","endif","return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;"]},{"name":"initialize","owner":2,"perms":173,"preposition":-1,"code":["if (typeof(this.owner.owned_objects) == LIST)","this.owner.owned_objects = setadd(this.owner.owned_objects, this);","endif","if ((caller == this) || $perm_utils:controls(caller_perms(), this))","if (is_clear_property(this, \"object_size\"))","\"If this isn't clear, then we're being hacked.\";","this.object_size = {0, 0};","endif","this.key = 0;","else","return E_PERM;","endif"]},{"name":"recycle","owner":2,"perms":173,"preposition":-1,"code":["if ((caller == this) || $perm_utils:controls(caller_perms(), this))","try","if ((typeof(this.owner.owned_objects) == LIST) && (!is_clear_property(this.owner, \"owned_objects\")))","this.owner.owned_objects = setremove(this.owner.owned_objects, this);","$recycler.lost_souls = setadd($recycler.lost_souls, this);","endif","except (ANY)","\"Oy, doesn't have a .owned_objects??, or maybe .owner is $nothing\";","\"Should probably do something...like send mail somewhere.\";","endtry","else","return E_PERM;","endif"]},{"name":"set_name","owner":2,"perms":173,"preposition":-1,"code":["\"set_name(newname) attempts to change this.name to newname\";","\"  => E_PERM   if you don't own this or aren't its parent, or are a player trying to do an end-run around $player_db...\";","if ((!caller_perms().wizard) && (is_player(this) || ((caller_perms() != this.owner) && (this != caller))))","return E_PERM;","else","return (typeof(e = `this.name = args[1] ! ANY') != ERR) || e;","endif"]},{"name":"title","owner":2,"perms":173,"preposition":-1,"code":["return this.name;"]},{"name":"titlec","owner":2,"perms":173,"preposition":-1,"code":["return `this.namec ! E_PROPNF => $string_utils:capitalize(this:title())';"]},{"name":"set_aliases","owner":2,"perms":173,"preposition":-1,"code":["\"set_aliases(alias_list) attempts to change this.aliases to alias_list\";","\"  => E_PERM   if you don't own this or aren't its parent\";","\"  => E_TYPE   if alias_list is not a list\";","\"  => E_INVARG if any element of alias_list is not a string\";","\"  => 1        if aliases are set exactly as expected (default)\";","\"  => 0        if aliases were set differently than expected\";","\"              (children with custom :set_aliases should be aware of this)\";","if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))","return E_PERM;","elseif (typeof(aliases = args[1]) != LIST)","return E_TYPE;","else","for s in (aliases)","if (typeof(s) != STR)","return E_INVARG;","endif","endfor","this.aliases = aliases;","return 1;","endif"]},{"name":"match","owner":2,"perms":173,"preposition":-1,"code":["c = this:contents();","return $string_utils:match(args[1], c, \"name\", c, \"aliases\");"]},{"name":"match_object","owner":2,"perms":173,"preposition":-1,"code":["\":match_object(string [,who])\";","args[2..1] = {this};","return $string_utils:match_object(@args);"]},{"name":"set_description","owner":2,"perms":173,"preposition":-1,"code":["\"set_description(newdesc) attempts to change this.description to newdesc\";","\"  => E_PERM   if you don't own this or aren't its parent\";","if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))","return E_PERM;","elseif (typeof(desc = args[1]) in {LIST, STR})","this.description = desc;","return 1;","else","return E_TYPE;","endif"]},{"name":"description","owner":2,"perms":173,"preposition":-1,"code":["return this.description;"]},{"name":"look_self","owner":2,"perms":173,"preposition":-1,"code":["desc = this:description();","if (desc)","player:tell_lines(desc);","else","player:tell(\"You see nothing special.\");","endif"]},{"name":"notify","owner":2,"perms":173,"preposition":-1,"code":["if (is_player(this))","notify(this, args[1]);","endif"]},{"name":"tell","owner":2,"perms":173,"preposition":-1,"code":["this:notify(tostr(@args));"]},{"name":"tell_lines","owner":2,"perms":173,"preposition":-1,"code":["lines = args[1];","if (typeof(lines) == LIST)","for line in (lines)","this:tell(line);","endfor","else","this:tell(lines);","endif"]},{"name":"accept","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","return this:acceptable(@args);"]},{"name":"moveto","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(this.owner);","return `move(this, args[1]) ! ANY';"]},{"name":"eject eject_nice eject_basic","owner":2,"perms":173,"preposition":-1,"code":["\"eject(victim) --- usable by the owner of this to remove victim from this.contents.  victim goes to its home if different from here, or $nothing or $player_start according as victim is a player.\";","\"eject_basic(victim) --- victim goes to $nothing or $player_start according as victim is a player; victim:moveto is not called.\";","what = args[1];","nice = verb != \"eject_basic\";","perms = caller_perms();","if ((!perms.wizard) && (perms != this.owner))","raise(E_PERM);","elseif ((!(what in this.contents)) || what.wizard)","return 0;","endif","if ((((nice && $object_utils:has_property(what, \"home\")) && (typeof(where = what.home) == OBJ)) && (where != this)) && (is_player(what) ? `where:accept_for_abode(what) ! ANY' | `where:acceptable(what) ! ANY'))","else","where = is_player(what) ? $player_start | $nothing;","endif","fork (0)","if (what.location == this)","\"It didn't move when we asked it to, or :moveto is broken. Force it.\";","move(what, where);","endif","endfork","return nice ? `what:moveto(where) ! ANY' | `move(what, where) ! ANY';"]},{"name":"is_unlocked_for","owner":2,"perms":173,"preposition":-1,"code":["return (this.key == 0) || $lock_utils:eval_key(this.key, args[1]);"]},{"name":"huh","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms((caller_perms() != #-1) ? caller_perms() | player);","$command_utils:do_huh(verb, args);"]},{"name":"set_message","owner":2,"perms":173,"preposition":-1,"code":["\":set_message(msg_name,new_value)\";","\"Does the actual dirty work of @<msg_name> object is <new_value>\";","\"changing the raw value of the message msg_name to be new_value.\";","\"Both msg_name and new_value should be strings, though their interpretation is up to the object itself.\";","\" => error value (use E_PROPNF if msg_name isn't recognized)\";","\" => string error message if something else goes wrong.\";","\" => 1 (true non-string) if the message is successfully set\";","\" => 0 (false non-error) if the message is successfully `cleared'\";","if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))","return E_PERM;","else","return `this.(args[1] + \"_msg\") = args[2] ! ANY' && 1;","endif"]},{"name":"do_examine","owner":2,"perms":173,"preposition":-1,"code":["\"do_examine(examiner)\";","\"the guts of examine\";","\"call a series of verbs and report their return values to the player\";","who = args[1];","\"if (caller == this || caller == who)\";","if (caller == who)","\"set_task_perms();\";","who:notify_lines(this:examine_names(who) || {});","\"this:examine_names(who);\";","who:notify_lines(this:examine_owner(who) || {});","\"this:examine_owner(who);\";","who:notify_lines(this:examine_desc(who) || {});","\"this:examine_desc(who);\";","who:notify_lines(this:examine_key(who) || {});","\"this:examine_key(who);\";","who:notify_lines(this:examine_contents(who) || {});","who:notify_lines(this:examine_verbs(who) || {});","else","return E_PERM;","endif"]},{"name":"examine_key","owner":2,"perms":173,"preposition":-1,"code":["\"examine_key(examiner)\";","\"return a list of strings to be told to the player, indicating what the key on this type of object means, and what this object's key is set to.\";","\"the default will only tell the key to a wizard or this object's owner.\";","who = args[1];","if (((caller == this) && $perm_utils:controls(who, this)) && (this.key != 0))","return {tostr(\"Key:  \", $lock_utils:unparse_key(this.key))};","endif"]},{"name":"examine_names","owner":2,"perms":173,"preposition":-1,"code":["\"examine_names(examiner)\";","\"Return a list of strings to be told to the player, indicating the name and aliases (and, by default, the object number) of this.\";","return {tostr(this.name, \" (aka \", $string_utils:english_list({tostr(this), @this.aliases}), \")\")};"]},{"name":"examine_desc","owner":2,"perms":173,"preposition":-1,"code":["\"examine_desc(who) - return the description, probably\";","\"who is the player examining\";","\"this should probably go away\";","desc = this:description();","if (desc)","if (typeof(desc) != LIST)","desc = {desc};","endif","return desc;","else","return {\"(No description set.)\"};","endif"]},{"name":"examine_contents","owner":2,"perms":173,"preposition":-1,"code":["\"examine_contents(examiner)\";","\"by default, calls :tell_contents.\";","\"Should probably go away.\";","who = args[1];","if (caller == this)","try","this:tell_contents(this.contents, this.ctype);","except (ANY)","\"Just ignore it. We shouldn't care about the contents unless the object wants to tell us about them via :tell_contents ($container, $room)\";","endtry","endif"]},{"name":"examine_verbs","owner":2,"perms":173,"preposition":-1,"code":["\"Return a list of strings to be told to the player.  Standard format says \\\"Obvious verbs:\\\" followed by a series of lines explaining syntax for each usable verb.\";","if (caller != this)","return E_PERM;","endif","who = args[1];","name = dobjstr;","vrbs = {};","commands_ok = `this:examine_commands_ok(who) ! ANY => 0';","dull_classes = {$root_class, $room, $player, $prog, $builder};","what = this;","hidden_verbs = this:hidden_verbs(who);","while (what != $nothing)","$command_utils:suspend_if_needed(0);","if (!(what in dull_classes))","for i in [1..length(verbs(what))]","$command_utils:suspend_if_needed(0);","info = verb_info(what, i);","syntax = verb_args(what, i);","if (this:examine_verb_ok(what, i, info, syntax, commands_ok, hidden_verbs))","{dobj, prep, iobj} = syntax;","if (syntax == {\"any\", \"any\", \"any\"})","prep = \"none\";","endif","if (prep != \"none\")","for x in ($string_utils:explode(prep, \"/\"))","if (length(x) <= length(prep))","prep = x;","endif","endfor","endif","\"This is the correct way to handle verbs ending in *\";","vname = info[3];","while (j = index(vname, \"* \"))","vname = tostr(vname[1..j - 1], \"<anything>\", vname[j + 1..$]);","endwhile","if (vname[$] == \"*\")","vname = vname[1..$ - 1] + \"<anything>\";","endif","vname = strsub(vname, \" \", \"/\");","rest = \"\";","if (prep != \"none\")","rest = \" \" + ((prep == \"any\") ? \"<anything>\" | prep);","if (iobj != \"none\")","rest = tostr(rest, \" \", (iobj == \"this\") ? name | \"<anything>\");","endif","endif","if (dobj != \"none\")","rest = tostr(\" \", (dobj == \"this\") ? name | \"<anything>\", rest);","endif","vrbs = setadd(vrbs, (\"  \" + vname) + rest);","endif","endfor","endif","what = parent(what);","endwhile","if ($code_utils:verb_or_property(this, \"help_msg\"))","vrbs = {@vrbs, tostr(\"  help \", dobjstr)};","endif","return vrbs && {\"Obvious verbs:\", @vrbs};"]},{"name":"get_message","owner":2,"perms":173,"preposition":-1,"code":["\":get_message(msg_name)\";","\"Use this to obtain a given user-customizable message's raw value, i.e., the value prior to any pronoun-substitution or incorporation of any variant elements --- the value one needs to supply to :set_message().\";","\"=> error (use E_PROPNF if msg_name isn't recognized)\";","\"=> string or list-of-strings raw value\";","\"=> {2, @(list of {msg_name_n,rawvalue_n} pairs to give to :set_message)}\";","\"=> {1, other kind of raw value}\";","\"=> {E_NONE, error message} \";","if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))","return E_PERM;","elseif (((t = typeof(msg = `this.(args[1] + \"_msg\") ! ANY')) in {ERR, STR}) || (((t == LIST) && msg) && (typeof(msg[1]) == STR)))","return msg;","else","return {1, msg};","endif"]},{"name":"room_announce*_all_but","owner":2,"perms":173,"preposition":-1,"code":["try","this.location:(verb)(@args);","except (ANY)","endtry"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","vnum = 1;","while (vnum <= length(verbs(this)))","$command_utils:suspend_if_needed(0);","info = verb_info(this, vnum)[3];","if (index(info, \"(old)\"))","delete_verb(this, vnum);","else","vnum = vnum + 1;","endif","endwhile","if (this == $root_class)","set_verb_code(this, \"initialize\", verb_code(this, \"initialize(core)\"));","delete_verb(this, \"initialize(core)\");","endif","endif"]},{"name":"contents","owner":36,"perms":173,"preposition":-1,"code":["\"Returns a list of the objects that are apparently inside this one.  Don't confuse this with .contents, which is a property kept consistent with .location by the server.  This verb should be used in `VR' situations, for instance when looking in a room, and does not necessarily have anything to do with the value of .contents (although the default implementation does).  `Non-VR' commands (like @contents) should look directly at .contents.\";","return this.contents;"]},{"name":"examine_verb_ok","owner":2,"perms":173,"preposition":-1,"code":["\"examine_verb_ok(loc, index, info, syntax, commands_ok, hidden_verbs)\";","\"loc is the object that defines the verb; index is which verb on the object; info is verb_info; syntax is verb_args; commands_ok is determined by this:commands_ok, probably, but passed in so we don't have to calculate it for each verb.\";","\"hidden_verbs is passed in for the same reasons.  It should be a list, each of whose entries is either a string with the full verb name to be hidden (e.g., \\\"d*rop th*row\\\") or a list of the form {verb location, full verb name, args}.\";","if ((caller == this) || $perm_utils:controls(caller_perms(), this))","{loc, index, info, syntax, commands_ok, hidden_verbs} = args;","vname = info[3];","return (((((syntax[2..3] != {\"none\", \"this\"}) && (!index(vname, \"(\"))) && (commands_ok || (\"this\" in syntax))) && `verb_code(loc, index) ! ANY') && (!(vname in hidden_verbs))) && (!({loc, vname, syntax} in hidden_verbs));","else","return E_PERM;","endif"]},{"name":"is_listening","owner":2,"perms":173,"preposition":-1,"code":["\"return 1 if the object can hear a :tell, or cares. Useful for active objects that want to stop when nothing is listening.\";","return 0;"]},{"name":"hidden_verbs","owner":2,"perms":173,"preposition":-1,"code":["\"hidden_verbs(who)\";","\"returns a list of verbs on this that should be hidden from examine\";","\"the player who's examining is passed in, so objects can hide verbs from specific players\";","\"verbs are returned as {location, full_verb_name, args} or just full_verb_name.  full_verb name is what shows up in verb_info(object, verb)[2], for example \\\"d*op th*row\\\".\";","if ((caller == this) || $perm_utils:controls(caller_perms(), this))","hidden = {};","what = this;","while (what != $nothing)","for i in [1..length(verbs(what))]","info = verb_info(what, i);","if (!index(info[2], \"r\"))","hidden = setadd(hidden, {what, info[3], verb_args(what, i)});","endif","endfor","what = parent(what);","endwhile","return hidden;","else","return E_PERM;","endif"]},{"name":"examine_owner","owner":2,"perms":173,"preposition":-1,"code":["\"examine_owner(examiner)\";","\"Return a list of strings to be told to the player, indicating who owns this.\";","return {tostr(\"Owned by \", this.owner.name, \".\")};"]},{"name":"announce*_all_but","owner":2,"perms":173,"preposition":-1,"code":["return;"]},{"name":"tell_lines_suspended","owner":2,"perms":173,"preposition":-1,"code":["lines = args[1];","if (typeof(lines) == LIST)","for line in (lines)","this:tell(line);","$command_utils:suspend_if_needed(0);","endfor","else","this:tell(lines);","endif"]},{"name":"acceptable","owner":2,"perms":173,"preposition":-1,"code":["return 0;","\"intended as a 'quiet' way to determine if :accept will succeed. Currently, some objects have a noisy :accept verb since it is the only thing that a builtin move() call is guaranteed to call.\";","\"if you want to tell, before trying, whether :accept will fail, use :acceptable instead. Normally, they'll do the same thing.\";"]},{"name":"confunc","owner":2,"perms":173,"preposition":-1,"code":["if ((((cp = caller_perms()) == player) || $perm_utils:controls(cp, player)) || (caller == this))","\"Need the first check because guests don't control themselves\";","this:look_self(player.brief);","this:announce($string_utils:pronoun_sub(\"%N %<has> connected.\", player));","endif"]},{"name":"disfunc","owner":2,"perms":173,"preposition":-1,"code":["if ((((cp = caller_perms()) == player) || $perm_utils:controls(cp, player)) || (caller == this))","this:announce($string_utils:pronoun_sub(\"%N %<has> disconnected.\", player));","\"need the first check since guests don't control themselves\";","if (!$object_utils:isa(player, $guest))","\"guest disfuncs are handled by $guest:disfunc. Don't add them here\";","$housekeeper:move_players_home(player);","endif","endif"]},{"name":"say","owner":2,"perms":85,"preposition":-2,"code":["try","player:tell(\"You say, \\\"\", argstr, \"\\\"\");","this:announce(player.name, \" \", $gender_utils:get_conj(\"says\", player), \", \\\"\", argstr, \"\\\"\");","except (ANY)","\"Don't really need to do anything but ignore the idiot who has a bad :tell\";","endtry"]},{"name":"emote","owner":2,"perms":93,"preposition":-2,"code":["if ((argstr != \"\") && (argstr[1] == \":\"))","this:announce_all(player.name, argstr[2..length(argstr)]);","else","this:announce_all(player.name, \" \", argstr);","endif"]},{"name":"announce","owner":2,"perms":173,"preposition":-1,"code":["for dude in (setremove(this:contents(), player))","try","dude:tell(@args);","except (ANY)","\"Just skip the dude with the bad :tell\";","continue dude;","endtry","endfor"]},{"name":"match_exit","owner":2,"perms":173,"preposition":-1,"code":["what = args[1];","if (what)","yes = $failed_match;","for e in (this.exits)","if (valid(e) && (what in {e.name, @e.aliases}))","if (yes == $failed_match)","yes = e;","elseif (yes != e)","return $ambiguous_match;","endif","endif","endfor","return yes;","else","return $nothing;","endif"]},{"name":"add_exit","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","return `this.exits = setadd(this.exits, args[1]) ! E_PERM' != E_PERM;"]},{"name":"tell_contents","owner":2,"perms":173,"preposition":-1,"code":["{contents, ctype} = args;","if ((!this.dark) && (contents != {}))","if (ctype == 0)","player:tell(\"Contents:\");","for thing in (contents)","player:tell(\"  \", thing:title());","endfor","elseif (ctype == 1)","for thing in (contents)","if (is_player(thing))","player:tell($string_utils:pronoun_sub(tostr(\"%N \", $gender_utils:get_conj(\"is\", thing), \" here.\"), thing));","else","player:tell(\"You see \", thing:title(), \" here.\");","endif","endfor","elseif (ctype == 2)","player:tell(\"You see \", $string_utils:title_list(contents), \" here.\");","elseif (ctype == 3)","players = things = {};","for x in (contents)","if (is_player(x))","players = {@players, x};","else","things = {@things, x};","endif","endfor","if (things)","player:tell(\"You see \", $string_utils:title_list(things), \" here.\");","endif","if (players)","player:tell($string_utils:title_listc(players), (length(players) == 1) ? \" \" + $gender_utils:get_conj(\"is\", players[1]) | \" are\", \" here.\");","endif","endif","endif"]},{"name":"@exits","owner":2,"perms":13,"preposition":-1,"code":["if (!$perm_utils:controls(valid(caller_perms()) ? caller_perms() | player, this))","player:tell(\"Sorry, only the owner of a room may list its exits.\");","elseif (this.exits == {})","player:tell(\"This room has no conventional exits.\");","else","try","for exit in (this.exits)","try","player:tell(exit.name, \" (\", exit, \") leads to \", valid(exit.dest) ? exit.dest.name | \"???\", \" (\", exit.dest, \") via {\", $string_utils:from_list(exit.aliases, \", \"), \"}.\");","except (ANY)","player:tell(\"Bad exit or missing .dest property:  \", $string_utils:nn(exit));","continue exit;","endtry","endfor","except (E_TYPE)","player:tell(\"Bad .exits property. This should be a list of exit objects. Please fix this.\");","endtry","endif"]},{"name":"look_self","owner":2,"perms":173,"preposition":-1,"code":["{?brief = 0} = args;","player:tell(this:title());","if (!brief)","pass();","endif","this:tell_contents(setremove(this:contents(), player), this.ctype);"]},{"name":"acceptable","owner":2,"perms":173,"preposition":-1,"code":["what = args[1];","return this:is_unlocked_for(what) && (((this:free_entry(@args) || ((what == this.blessed_object) && (task_id() == this.blessed_task))) || (what.owner == this.owner)) || ((typeof(this.residents) == LIST) && ((what in this.residents) || (what.owner in this.residents))));"]},{"name":"add_entrance","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","return `this.entrances = setadd(this.entrances, args[1]) ! E_PERM' != E_PERM;"]},{"name":"bless_for_entry","owner":2,"perms":173,"preposition":-1,"code":["if (caller in {@this.entrances, this})","this.blessed_object = args[1];","this.blessed_task = task_id();","endif"]},{"name":"@entrances","owner":2,"perms":9,"preposition":-1,"code":["if (!$perm_utils:controls(valid(caller_perms()) ? caller_perms() | player, this))","player:tell(\"Sorry, only the owner of a room may list its entrances.\");","elseif (this.entrances == {})","player:tell(\"This room has no conventional entrances.\");","else","try","for exit in (this.entrances)","try","player:tell(exit.name, \" (\", exit, \") comes from \", valid(exit.source) ? exit.source.name | \"???\", \" (\", exit.source, \") via {\", $string_utils:from_list(exit.aliases, \", \"), \"}.\");","except (ANY)","player:tell(\"Bad entrance object or missing .source property: \", $string_utils:nn(exit));","continue exit;","endtry","endfor","except (E_TYPE)","player:tell(\"Bad .entrances property. This should be a list of exit objects. Please fix this.\");","endtry","endif"]},{"name":"go","owner":2,"perms":93,"preposition":-2,"code":["if ((!args) || (!(dir = args[1])))","player:tell(\"You need to specify a direction.\");","return E_INVARG;","elseif (valid(exit = player.location:match_exit(dir)))","exit:invoke();","if (length(args) > 1)","old_room = player.location;","\"Now give objects in the room we just entered a chance to act.\";","suspend(0);","if (player.location == old_room)","\"player didn't move or get moved while we were suspended\";","player.location:go(@listdelete(args, 1));","endif","endif","elseif (exit == $failed_match)","player:tell(\"You can't go that way (\", dir, \").\");","else","player:tell(\"I don't know which direction `\", dir, \"' you mean.\");","endif"]},{"name":"l*ook","owner":2,"perms":93,"preposition":-2,"code":["if ((dobjstr == \"\") && (!prepstr))","this:look_self();","elseif ((prepstr != \"in\") && (prepstr != \"on\"))","if ((!dobjstr) && (prepstr == \"at\"))","dobjstr = iobjstr;","iobjstr = \"\";","else","dobjstr = dobjstr + (prepstr && ((dobjstr && \" \") + prepstr));","dobjstr = dobjstr + (iobjstr && ((dobjstr && \" \") + iobjstr));","endif","dobj = this:match_object(dobjstr);","if (!$command_utils:object_match_failed(dobj, dobjstr))","dobj:look_self();","endif","elseif (!iobjstr)","player:tell(verb, \" \", prepstr, \" what?\");","else","iobj = this:match_object(iobjstr);","if (!$command_utils:object_match_failed(iobj, iobjstr))","if (dobjstr == \"\")","iobj:look_self();","elseif ((thing = iobj:match(dobjstr)) == $failed_match)","player:tell(\"I don't see any \\\"\", dobjstr, \"\\\" \", prepstr, \" \", iobj.name, \".\");","elseif (thing == $ambiguous_match)","player:tell(\"There are several things \", prepstr, \" \", iobj.name, \" one might call \\\"\", dobjstr, \"\\\".\");","else","thing:look_self();","endif","endif","endif"]},{"name":"announce_all","owner":2,"perms":173,"preposition":-1,"code":["for dude in (this:contents())","try","dude:tell(@args);","except (ANY)","\"Just ignore the dude with the stupid :tell\";","continue dude;","endtry","endfor"]},{"name":"announce_all_but","owner":2,"perms":173,"preposition":-1,"code":["\":announce_all_but(LIST objects to ignore, text)\";","{ignore, @text} = args;","contents = this:contents();","for l in (ignore)","contents = setremove(contents, l);","endfor","for listener in (contents)","try","listener:tell(@text);","except (ANY)","\"Ignure listener with bad :tell\";","continue listener;","endtry","endfor"]},{"name":"enterfunc","owner":2,"perms":173,"preposition":-1,"code":["object = args[1];","if (is_player(object) && (object.location == this))","player = object;","this:look_self(player.brief);","endif","if (object == this.blessed_object)","this.blessed_object = #-1;","endif"]},{"name":"exitfunc","owner":2,"perms":173,"preposition":-1,"code":["return;"]},{"name":"remove_exit","owner":2,"perms":173,"preposition":-1,"code":["exit = args[1];","if (caller != exit)","set_task_perms(caller_perms());","endif","return `this.exits = setremove(this.exits, exit) ! E_PERM' != E_PERM;"]},{"name":"remove_entrance","owner":2,"perms":173,"preposition":-1,"code":["exit = args[1];","if (caller != exit)","set_task_perms(caller_perms());","endif","return `this.entrances = setremove(this.entrances, exit) ! E_PERM' != E_PERM;"]},{"name":"@add-exit","owner":2,"perms":25,"preposition":-1,"code":["set_task_perms(player);","if (!dobjstr)","player:tell(\"Usage:  @add-exit <exit-number>\");","return;","endif","exit = this:match_object(dobjstr);","if ($command_utils:object_match_failed(exit, dobjstr))","return;","endif","if (!($exit in $object_utils:ancestors(exit)))","player:tell(\"That doesn't look like an exit object to me...\");","return;","endif","try","dest = exit.dest;","except (E_PERM)","player:tell(\"You can't read the exit's destination to check that it's consistent!\");","return;","endtry","try","source = exit.source;","except (E_PERM)","player:tell(\"You can't read that exit's source to check that it's consistent!\");","return;","endtry","if (source != this)","player:tell(\"That exit wasn't made to be attached here; it was made as an exit from \", source.name, \" (\", source, \").\");","return;","elseif (((typeof(dest) != OBJ) || (!valid(dest))) || (!($room in $object_utils:ancestors(dest))))","player:tell(\"That exit doesn't lead to a room!\");","return;","endif","if (!this:add_exit(exit))","player:tell(\"Sorry, but you must not have permission to add exits to this room.\");","else","player:tell(\"You have added \", exit, \" as an exit that goes to \", exit.dest.name, \" (\", exit.dest, \") via \", $string_utils:english_list(setadd(exit.aliases, exit.name)), \".\");","endif"]},{"name":"@add-entrance","owner":2,"perms":25,"preposition":-1,"code":["set_task_perms(player);","if (!dobjstr)","player:tell(\"Usage:  @add-entrance <exit-number>\");","return;","endif","exit = this:match_object(dobjstr);","if ($command_utils:object_match_failed(exit, dobjstr))","return;","endif","if (!($exit in $object_utils:ancestors(exit)))","player:tell(\"That doesn't look like an exit object to me...\");","return;","endif","try","dest = exit.dest;","except (E_PERM)","player:tell(\"You can't read the exit's destination to check that it's consistent!\");","return;","endtry","if (dest != this)","player:tell(\"That exit doesn't lead here!\");","return;","endif","if (!this:add_entrance(exit))","player:tell(\"Sorry, but you must not have permission to add entrances to this room.\");","else","player:tell(\"You have added \", exit, \" as an entrance that gets here via \", $string_utils:english_list(setadd(exit.aliases, exit.name)), \".\");","endif"]},{"name":"recycle","owner":2,"perms":173,"preposition":-1,"code":["\"Make a mild attempt to keep people and objects from ending up in #-1 when people recycle a room\";","if ((caller == this) || $perm_utils:controls(caller_perms(), this))","\"... first try spilling them out onto the floor of enclosing room if any\";","if (valid(this.location))","for x in (this.contents)","try","x:moveto(this.location);","except (ANY)","continue x;","endtry","endfor","endif","\"... try sending them home...\";","for x in (this.contents)","if (is_player(x))","if ((typeof(x.home) == OBJ) && valid(x.home))","try","x:moveto(x.home);","except (ANY)","continue x;","endtry","endif","if (x.location == this)","move(x, $player_start);","endif","elseif (valid(x.owner))","try","x:moveto(x.owner);","except (ANY)","continue x;","endtry","endif","endfor","pass(@args);","else","return E_PERM;","endif"]},{"name":"e east w west s south n north ne northeast nw northwest se southeast sw southwest u up d down","owner":2,"perms":13,"preposition":-1,"code":["set_task_perms((caller_perms() == #-1) ? player | caller_perms());","exit = this:match_exit(verb);","if (valid(exit))","exit:invoke();","elseif (exit == $failed_match)","player:tell(\"You can't go that way.\");","else","player:tell(\"I don't know which direction `\", verb, \"' you mean.\");","endif"]},{"name":"@eject @eject! @eject!!","owner":2,"perms":25,"preposition":-1,"code":["set_task_perms(player);","if ($command_utils:object_match_failed(dobj, dobjstr))","return;","elseif (dobj.location != this)","is = $gender_utils:get_conj(\"is\", dobj);","player:tell(dobj.name, \"(\", dobj, \") \", is, \" not here.\");","return;","elseif (!$perm_utils:controls(player, this))","player:tell(\"You are not the owner of this room.\");","return;","elseif (dobj.wizard)","player:tell(\"Sorry, you can't \", verb, \" a wizard.\");","dobj:tell(player.name, \" tried to \", verb, \" you.\");","return;","endif","iobj = this;","player:tell(this:ejection_msg());","this:((verb == \"@eject\") ? \"eject\" | \"eject_basic\")(dobj);","if (verb != \"@eject!!\")","dobj:tell(this:victim_ejection_msg());","endif","this:announce_all_but({player, dobj}, this:oejection_msg());"]},{"name":"ejection_msg oejection_msg victim_ejection_msg","owner":36,"perms":173,"preposition":-1,"code":["return $gender_utils:pronoun_sub(this.(verb));"]},{"name":"accept_for_abode","owner":2,"perms":173,"preposition":-1,"code":["who = args[1];","return this:basic_accept_for_abode(who) && this:acceptable(who);"]},{"name":"@resident*s","owner":2,"perms":25,"preposition":-1,"code":["if (!$perm_utils:controls(player, this))","player:tell(\"You must own this room to manipulate the legal residents list.  Try contacting \", this.owner.name, \".\");","else","if (typeof(this.residents) != LIST)","this.residents = {this.residents};","endif","if (!dobjstr)","\"First, remove !valid objects from this room...\";","for x in (this.residents)","if ((typeof(x) != OBJ) || (!valid(x)))","player:tell(\"Warning: removing \", x, \", an invalid object, from the residents list.\");","this.residents = setremove(this.residents, x);","endif","endfor","player:tell(\"Allowable residents in this room:  \", $string_utils:english_list($list_utils:map_prop(this.residents, \"name\"), \"no one\"), \".\");","return;","elseif (dobjstr[1] == \"!\")","notflag = 1;","dobjstr = dobjstr[2..$];","else","notflag = 0;","endif","result = $string_utils:match_player_or_object(dobjstr);","if (!result)","return;","else","\"a one element list was returned to us if it won.\";","result = result[1];","if (notflag)","if (!(result in this.residents))","player:tell(result.name, \" doesn't appear to be in the residents list of \", this.name, \".\");","else","this.residents = setremove(this.residents, result);","player:tell(result.name, \" removed from the residents list of \", this.name, \".\");","endif","else","if (result in this.residents)","is = $gender_utils:get_conj(\"is\", result);","player:tell(result.name, \" \", is, \" already an allowed resident of \", this.name, \".\");","else","this.residents = {@this.residents, result};","player:tell(result.name, \" added to the residents list of \", this.name, \".\");","endif","endif","endif","endif"]},{"name":"match","owner":2,"perms":173,"preposition":-1,"code":["target = {@this:contents(), @this:exits()};","return $string_utils:match(args[1], target, \"name\", target, \"aliases\");"]},{"name":"@remove-exit","owner":2,"perms":25,"preposition":-1,"code":["set_task_perms(player);","if (!dobjstr)","player:tell(\"Usage:  @remove-exit <exit>\");","return;","endif","exit = this:match_object(dobjstr);","if (!(exit in this.exits))","if ($command_utils:object_match_failed(exit, dobjstr))","return;","endif","player:tell(\"Couldn't find \\\"\", dobjstr, \"\\\" in the exits list of \", this.name, \".\");","return;","elseif (!this:remove_exit(exit))","player:tell(\"Sorry, but you do not have permission to remove exits from this room.\");","else","name = valid(exit) ? exit.name | \"<recycled>\";","player:tell(\"Exit \", exit, \" (\", name, \") removed from exit list of \", this.name, \" (\", this, \").\");","endif"]},{"name":"@remove-entrance","owner":2,"perms":25,"preposition":-1,"code":["set_task_perms(player);","if (!dobjstr)","player:tell(\"Usage:  @remove-entrance <entrance>\");","return;","endif","entrance = $string_utils:match(dobjstr, this.entrances, \"name\", this.entrances, \"aliases\");","if (!valid(entrance))","\"Try again to parse it.  Maybe they gave object number.  Don't complain if it's invalid though; maybe it's been recycled in some nefarious way.\";","entrance = this:match_object(dobjstr);","endif","if (!(entrance in this.entrances))","player:tell(\"Couldn't find \\\"\", dobjstr, \"\\\" in the entrances list of \", this.name, \".\");","return;","elseif (!this:remove_entrance(entrance))","player:tell(\"Sorry, but you do not have permission to remove entrances from this room.\");","else","name = valid(entrance) ? entrance.name | \"<recycled>\";","player:tell(\"Entrance \", entrance, \" (\", name, \") removed from entrance list of \", this.name, \" (\", this, \").\");","endif"]},{"name":"moveto","owner":2,"perms":173,"preposition":-1,"code":["if ((caller in {this, this.owner}) || $perm_utils:controls(caller_perms(), this))","return pass(@args);","else","return E_PERM;","endif"]},{"name":"who_location_msg","owner":2,"perms":173,"preposition":-1,"code":["return (msg = `this.(verb) ! ANY') ? $string_utils:pronoun_sub(msg, args[1]) | \"\";"]},{"name":"exits entrances","owner":2,"perms":173,"preposition":-1,"code":["if ((caller == this) || $perm_utils:controls(caller_perms(), this))","return this.(verb);","else","return E_PERM;","endif"]},{"name":"obvious_exits obvious_entrances","owner":2,"perms":173,"preposition":-1,"code":["exits = {};","for exit in (`(verb == \"obvious_exits\") ? this.exits | this.entrances ! ANY => {}')","if (`exit.obvious ! ANY')","exits = setadd(exits, exit);","endif","endfor","return exits;"]},{"name":"here_huh","owner":2,"perms":173,"preposition":-1,"code":["\":here_huh(verb,args)  -- room-specific :huh processing.  This should return 1 if it finds something interesting to do and 0 otherwise; see $command_utils:do_huh.\";","\"For the generic room, we check for the case of the caller specifying an exit for which a corresponding verb was never defined.\";","set_task_perms(caller_perms());","if (args[2] || ($failed_match == (exit = this:match_exit(verb = args[1]))))","\"... okay, it's not an exit.  we give up...\";","return 0;","elseif (valid(exit))","exit:invoke();","else","\"... ambiguous exit ...\";","player:tell(\"I don't know which direction `\", verb, \"' you mean.\");","endif","return 1;"]},{"name":"room_announce*_all_but","owner":2,"perms":173,"preposition":-1,"code":["this:(verb[6..$])(@args);"]},{"name":"examine_commands_ok","owner":2,"perms":173,"preposition":-1,"code":["return this == args[1].location;"]},{"name":"examine_key","owner":2,"perms":173,"preposition":-1,"code":["\"examine_key(examiner)\";","\"return a list of strings to be told to the player, indicating what the key on this type of object means, and what this object's key is set to.\";","\"the default will only tell the key to a wizard or this object's owner.\";","who = args[1];","if (((caller == this) && $perm_utils:controls(who, this)) && (this.key != 0))","return {tostr(this:title(), \" will accept only objects matching the following key:\"), tostr(\"  \", $lock_utils:unparse_key(this.key))};","endif"]},{"name":"examine_contents","owner":2,"perms":173,"preposition":-1,"code":["\"examine_contents(who)\";","if (caller == this)","this:tell_contents(this.contents, this.ctype);","endif"]},{"name":"free_entry","owner":36,"perms":173,"preposition":-1,"code":["return this.free_entry;"]},{"name":"dark","owner":2,"perms":173,"preposition":-1,"code":["return this.(verb);"]},{"name":"announce_lines_x","owner":2,"perms":173,"preposition":-1,"code":["\"Copied from generic room (#3):announce by Haakon (#2) Thu Oct 24 16:15:01 1996 PDT\";","for dude in (setremove(this:contents(), player))","try","dude:tell_lines(@args);","except id (ANY)","endtry","endfor"]},{"name":"basic_accept_for_abode","owner":2,"perms":173,"preposition":-1,"code":["who = args[1];","return valid(who) && ((this.free_home || $perm_utils:controls(who, this)) || ((typeof(residents = this.residents) == LIST) ? who in this.residents | (who == this.residents)));"]},{"name":"@quota","owner":2,"perms":25,"preposition":-1,"code":["set_task_perms(player);","if (dobjstr == \"\")","dobj = player;","else","dobj = $string_utils:match_player(dobjstr);","endif","if (!valid(dobj))","player:notify(\"Show whose quota?\");","return;","endif","$quota_utils:display_quota(dobj);"]},{"name":"@create","owner":2,"perms":89,"preposition":-2,"code":["set_task_perms(player);","nargs = length(args);","pos = \"named\" in args;","if ((pos <= 1) || (pos == nargs))","pos = \"called\" in args;","endif","if ((pos <= 1) || (pos == nargs))","player:notify(\"Usage:  @create <parent-class> named [name:]alias,...,alias\");","player:notify(\"   or:  @create <parent-class> named name-and-alias,alias,...,alias\");","player:notify(\"\");","player:notify(\"where <parent-class> is one of the standard classes ($note, $letter, $thing, or $container) or an object number (e.g., #999), or the name of some object in the current room.\");","player:notify(\"You can use \\\"called\\\" instead of \\\"named\\\", if you wish.\");","return;","endif","parentstr = $string_utils:from_list(args[1..pos - 1], \" \");","namestr = $string_utils:from_list(args[pos + 1..$], \" \");","if (!namestr)","player:notify(\"You must provide a name.\");","return;","endif","if (parentstr[1] == \"$\")","parent = #0.(parentstr[2..$]);","if (typeof(parent) != OBJ)","player:notify(tostr(\"\\\"\", parentstr, \"\\\" does not name an object.\"));","return;","endif","else","parent = player:my_match_object(parentstr);","if ($command_utils:object_match_failed(parent, parentstr))","return;","endif","endif","object = player:_create(parent);","if (typeof(object) == ERR)","player:notify(tostr(object));","return;","endif","for f in ($string_utils:char_list(player:build_option(\"create_flags\") || \"\"))","object.(f) = 1;","endfor","\"move() shouldn't, but could bomb. Say if player has a stupid :accept\";","`move(object, player) ! ANY';","$building_utils:set_names(object, namestr);","if ((other_names = setremove(object.aliases, object.name)) != {})","aka = (\" (aka \" + $string_utils:english_list(other_names)) + \")\";","else","aka = \"\";","endif","player:notify(tostr(\"You now have \", object.name, aka, \" with object number \", object, \" and parent \", parent.name, \" (\", parent, \").\"));"]},{"name":"@recycle","owner":2,"perms":25,"preposition":-1,"code":["set_task_perms(player);","dobj = player:my_match_object(dobjstr);","if (dobj == $nothing)","player:notify(tostr(\"Usage:  \", verb, \" <object>\"));","elseif ($command_utils:object_match_failed(dobj, dobjstr))","\"...bogus object...\";","elseif (player == dobj)","player:notify($wiz_utils.suicide_string);","else","name = dobj.name;","result = player:_recycle(dobj);","if (typeof(result) == ERR)","player:notify(tostr(result));","else","player:notify(tostr(name, \" (\", dobj, \") recycled.\"));","endif","endif"]},{"name":"@recreate","owner":2,"perms":89,"preposition":13,"code":["\"@recreate <object> as <parent-class> named [name:]alias,alias,...\";","\"  effectively recycles and creates <object> all over again.\";","set_task_perms(player);","as = prepstr in args;","named = \"named\" in args;","if ((named <= (as + 1)) || (named == length(args)))","named = \"called\" in args;","endif","if ((named <= (as + 1)) || (named == length(args)))","player:notify_lines({tostr(\"Usage:  \", verb, \" <object> as <parent-class> named [name:]alias,...,alias\"), \"\", \"where <parent-class> is one of the standard classes ($note, $letter, $thing, or $container) or an object number (e.g., #999), or the name of some object in the current room.  The [name:]alias... specification is as in @create.\", \"\", \"You can use \\\"called\\\" instead of \\\"named\\\", if you wish.\"});","return;","elseif ($command_utils:object_match_failed(dobj = player:my_match_object(dobjstr), dobjstr))","return;","elseif (is_player(dobj))","player:notify(\"You really *don't* want to do that!\");","return;","endif","parentstr = $string_utils:from_list(args[as + 1..named - 1], \" \");","namestr = $string_utils:from_list(args[named + 1..$], \" \");","if (parentstr[1] == \"$\")","parent = #0.(parentstr[2..$]);","if (typeof(parent) != OBJ)","player:notify(tostr(\"\\\"\", parentstr, \"\\\" does not name an object.\"));","return;","endif","else","parent = player:my_match_object(parentstr);","if ($command_utils:object_match_failed(parent, parentstr))","return;","endif","endif","if (!(e = $building_utils:recreate(dobj, parent)))","player:notify(tostr(e));","return;","endif","for f in ($string_utils:char_list(player:build_option(\"create_flags\") || \"\"))","dobj.(f) = 1;","endfor","\"move() shouldn't, but could, bomb. Say if player has a stupid :accept\";","`move(dobj, player) ! ANY';","$building_utils:set_names(dobj, namestr);","if ((other_names = setremove(dobj.aliases, dobj.name)) != {})","aka = (\" (aka \" + $string_utils:english_list(other_names)) + \")\";","else","aka = \"\";","endif","player:notify(tostr(\"Object number \", dobj, \" is now \", dobj.name, aka, \" with parent \", parent.name, \" (\", parent, \").\"));"]},{"name":"@dig","owner":2,"perms":89,"preposition":-2,"code":["set_task_perms(player);","nargs = length(args);","if (nargs == 1)","room = args[1];","exit_spec = \"\";","elseif ((nargs >= 3) && (args[2] == \"to\"))","exit_spec = args[1];","room = $string_utils:from_list(args[3..$], \" \");","elseif (argstr && (!prepstr))","room = argstr;","exit_spec = \"\";","else","player:notify(tostr(\"Usage:  \", verb, \" <new-room-name>\"));","player:notify(tostr(\"    or  \", verb, \" <exit-description> to <new-room-name-or-old-room-object-number>\"));","return;","endif","if (room != tostr(other_room = toobj(room)))","room_kind = player:build_option(\"dig_room\");","if (room_kind == 0)","room_kind = $room;","endif","other_room = player:_create(room_kind);","if (typeof(other_room) == ERR)","player:notify(tostr(\"Cannot create new room as a child of \", $string_utils:nn(room_kind), \": \", other_room, \".  See `help @build-options' for information on how to specify the kind of room this command tries to create.\"));","return;","endif","for f in ($string_utils:char_list(player:build_option(\"create_flags\") || \"\"))","other_room.(f) = 1;","endfor","other_room.name = room;","other_room.aliases = {room};","move(other_room, $nothing);","player:notify(tostr(other_room.name, \" (\", other_room, \") created.\"));","elseif (nargs == 1)","player:notify(\"You can't dig a room that already exists!\");","return;","elseif ((!valid(player.location)) || (!($room in $object_utils:ancestors(player.location))))","player:notify(tostr(\"You may only use the \", verb, \" command from inside a room.\"));","return;","elseif ((!valid(other_room)) || (!($room in $object_utils:ancestors(other_room))))","player:notify(tostr(other_room, \" doesn't look like a room to me...\"));","return;","endif","if (exit_spec)","exit_kind = player:build_option(\"dig_exit\");","if (exit_kind == 0)","exit_kind = $exit;","endif","exits = $string_utils:explode(exit_spec, \"|\");","if ((length(exits) < 1) || (length(exits) > 2))","player:notify(\"The exit-description must have the form\");","player:notify(\"     [name:]alias,...,alias\");","player:notify(\"or   [name:]alias,...,alias|[name:]alias,...,alias\");","return;","endif","do_recreate = !player:build_option(\"bi_create\");","to_ok = $building_utils:make_exit(exits[1], player.location, other_room, do_recreate, exit_kind);","if (to_ok && (length(exits) == 2))","$building_utils:make_exit(exits[2], other_room, player.location, do_recreate, exit_kind);","endif","endif"]},{"name":"@audit","owner":2,"perms":89,"preposition":-2,"code":["\"Usage:  @audit [player] [from <start>] [to <end>] [for <matching string>]\";","set_task_perms(player);","dobj = $string_utils:match_player(dobjstr);","if (!dobjstr)","dobj = player;","elseif ($command_utils:player_match_result(dobj, dobjstr)[1])","return;","endif","dobjwords = $string_utils:words(dobjstr);","if (args[1..length(dobjwords)] == dobjwords)","args = args[length(dobjwords) + 1..$];","endif","if (!(parse_result = $code_utils:_parse_audit_args(@args)))","player:notify(tostr(\"Usage:  \", verb, \" [player] [from <start>] [to <end>] [for <match>]\"));","return;","endif","return $building_utils:do_audit(dobj, @parse_result);"]},{"name":"@count","owner":2,"perms":25,"preposition":-1,"code":["if (!dobjstr)","dobj = player;","elseif ($command_utils:player_match_result(dobj = $string_utils:match_player(dobjstr), dobjstr)[1])","return;","endif","set_task_perms(player);","if (typeof(dobj.owned_objects) == LIST)","count = length(dobj.owned_objects);","player:notify(tostr(dobj.name, \" currently owns \", count, \" object\", (count == 1) ? \".\" | \"s.\"));","if ($quota_utils.byte_based)","player:notify(tostr(\"Total bytes consumed:  \", $string_utils:group_number($quota_utils:get_size_quota(dobj)[2]), \".\"));","endif","else","player:notify(tostr(dobj.name, \" is not enrolled in the object ownership system.  Use @countDB instead.\"));","endif"]},{"name":"@countDB","owner":2,"perms":25,"preposition":-1,"code":["if (!dobjstr)","dobj = player;","elseif ($command_utils:player_match_result(dobj = $string_utils:match_player(dobjstr), dobjstr)[1])","return;","endif","set_task_perms(player);","count = 0;","for o in [#1..max_object()]","if ($command_utils:running_out_of_time())","player:notify(\"Counting...\");","suspend(5);","endif","if (valid(o) && (o.owner == dobj))","count = count + 1;","endif","endfor","player:notify(tostr(dobj.name, \" currently owns \", count, \" object\", (count == 1) ? \".\" | \"s.\"));"]},{"name":"@sort-owned*-objects","owner":2,"perms":25,"preposition":-1,"code":["\"$player:owned_objects -- sorts a players .owned_objects property in ascending\";","\"order so it looks nice on @audit.\";","if (player != this)","return E_PERM;","endif","if (typeof(player.owned_objects) == LIST)","if ((!dobjstr) || (index(\"object\", dobjstr) == 1))","ret = $list_utils:sort_suspended(0, player.owned_objects);","elseif (index(\"size\", dobjstr) == 1)","ret = $list_utils:reverse_suspended($list_utils:sort_suspended(0, player.owned_objects, $list_utils:slice($list_utils:map_prop(player.owned_objects, \"object_size\"))));","endif","if (typeof(ret) == LIST)","player.owned_objects = ret;","player:tell(\"Your .owned_objects list has been sorted.\");","return 1;","else","player:tell(\"Something went wrong. .owned_objects not sorted.\");","return 0;","endif","else","player:tell(\"You are not enrolled in .owned_objects scheme, sorry.\");","endif"]},{"name":"@add-owned","owner":2,"perms":25,"preposition":-1,"code":["if (player != this)","player:tell(\"Permission Denied\");","return E_PERM;","endif","if (!valid(dobj))","player:tell(\"Don't understand `\", dobjstr, \"' as an object to add.\");","elseif (dobj.owner != player)","player:tell(\"You don't own \", dobj.name, \".\");","elseif (dobj in player.owned_objects)","player:tell(dobj.name, \" is already recorded in your .owned_objects.\");","else","player.owned_objects = setadd(player.owned_objects, dobj);","player:tell(\"Added \", dobj, \" to your .owned_objects.\");","endif"]},{"name":"@verify-owned","owner":2,"perms":9,"preposition":-1,"code":["for x in (player.owned_objects)","if ((!valid(x)) || (x.owner != player))","player.owned_objects = setremove(player.owned_objects, x);","if (valid(x))","player:tell(\"Removing \", x.name, \"(\", x, \"), owned by \", valid(x.owner) ? x.owner.name | \"<recycled player>\", \" from your .owned_objects property.\");","else","player:tell(\"Removing invalid object \", x, \" from your .owned_objects property.\");","endif","endif","$command_utils:suspend_if_needed(2, tostr(\"Suspending @verify-owned ... \", x));","endfor","player:tell(\".owned_objects property verified.\");"]},{"name":"@unlock","owner":2,"perms":25,"preposition":-1,"code":["set_task_perms(player);","dobj = player:my_match_object(dobjstr);","if ($command_utils:object_match_failed(dobj, dobjstr))","return;","endif","try","dobj.key = 0;","player:notify(tostr(\"Unlocked \", dobj.name, \".\"));","except error (ANY)","player:notify(error[2]);","endtry"]},{"name":"@lock","owner":2,"perms":89,"preposition":0,"code":["set_task_perms(player);","dobj = player:my_match_object(dobjstr);","if ($command_utils:object_match_failed(dobj, dobjstr))","return;","endif","key = $lock_utils:parse_keyexp(iobjstr, player);","if (typeof(key) == STR)","player:notify(\"That key expression is malformed:\");","player:notify(tostr(\"  \", key));","else","try","dobj.key = key;","player:notify(tostr(\"Locked \", dobj.name, \" to this key:\"));","player:notify(tostr(\"  \", $lock_utils:unparse_key(key)));","except error (ANY)","player:notify(error[2]);","endtry","endif"]},{"name":"@newmess*age","owner":2,"perms":89,"preposition":-2,"code":["\"Usage:  @message <message-name> [<message>] [on <object>]\";","\"Add a message property to an object (default is player), and optionally\";","\"set its value.  For use by non-programmers, who aren't allowed to add\";","\"properties generally.\";","\"To undo the effects of this, use @unmessage.\";","set_task_perms(player);","dobjwords = $string_utils:words(dobjstr);","if (!dobjwords)","player:notify(tostr(\"Usage:  \", verb, \" <message-name> [<message>] [on <object>]\"));","return;","endif","object = valid(iobj) ? iobj | player;","name = this:_messagify(dobjwords[1]);","value = dobjstr[length(dobjwords[1]) + 2..$];","nickname = \"@\" + name[1..$ - 4];","e = `add_property(object, name, value, {player, \"rc\"}) ! ANY';","if (typeof(e) != ERR)","player:notify(tostr(nickname, \" on \", object.name, \" is now \\\"\", object.(name), \"\\\".\"));","elseif (e != E_INVARG)","player:notify(tostr(e));","elseif ($object_utils:has_property(object, name))","\"object already has property\";","player:notify(tostr(object.name, \" already has a \", nickname, \" message.\"));","else","player:notify(tostr(\"Unable to add \", nickname, \" message to \", object.name, \": \", e));","endif"]},{"name":"@unmess*age","owner":2,"perms":89,"preposition":-2,"code":["\"Usage:  @unmessage <message-name> [from <object>]\";","\"Remove a message property from an object (default is player).\";","set_task_perms(player);","if ((!dobjstr) || (length($string_utils:words(dobjstr)) > 1))","player:notify(tostr(\"Usage:  \", verb, \" <message-name> [from <object>]\"));","return;","endif","object = valid(iobj) ? iobj | player;","name = this:_messagify(dobjstr);","nickname = \"@\" + name[1..$ - 4];","try","delete_property(object, name);","player:notify(tostr(nickname, \" message removed from \", object.name, \".\"));","except (E_PROPNF)","player:notify(tostr(\"No \", nickname, \" message found on \", object.name, \".\"));","except error (ANY)","player:notify(error[2]);","endtry"]},{"name":"_messagify","owner":2,"perms":173,"preposition":-1,"code":["\"Given any of several formats people are likely to use for a @message\";","\"property, return the canonical form (\\\"foobar_msg\\\").\";","name = args[1];","if (name[1] == \"@\")","name = name[2..$];","endif","if ((length(name) < 4) || (name[$ - 3..$] != \"_msg\"))","name = name + \"_msg\";","endif","return name;"]},{"name":"@kids","owner":2,"perms":29,"preposition":-1,"code":["\"'@kids <obj>' - List the children of an object. This is handy for seeing whether anybody's actually using your carefully-wrought public objects.\";","thing = player:my_match_object(dobjstr);","if (!$command_utils:object_match_failed(thing, dobjstr))","kids = children(thing);","if (kids)","player:notify(tostr(thing:title(), \"(\", thing, \") has \", length(kids), \" kid\", (length(kids) == 1) ? \"\" | \"s\", \".\"));","player:notify(tostr($string_utils:names_of(kids)));","else","player:notify(tostr(thing:title(), \"(\", thing, \") has no kids.\"));","endif","endif"]},{"name":"@contents","owner":2,"perms":25,"preposition":-1,"code":["\"'@contents <obj> - list the contents of an object, with object numbers.\";","set_task_perms(player);","if (!dobjstr)","dobj = player.location;","else","dobj = player:my_match_object(dobjstr);","endif","if ($command_utils:object_match_failed(dobj, dobjstr))","else","contents = dobj.contents;","if (contents)","player:notify(tostr(dobj:title(), \"(\", dobj, \") contains:\"));","player:notify(tostr($string_utils:names_of(contents)));","else","player:notify(tostr(dobj:title(), \"(\", dobj, \") contains nothing.\"));","endif","endif"]},{"name":"@par*ents","owner":2,"perms":25,"preposition":-1,"code":["\"'@parents <thing>' - List <thing> and its ancestors, all the way back to the Root Class (#1).\";","if (player != this)","return player:notify(\"Permission denied: not a builder.\");","elseif (!dobjstr)","player:notify(tostr(\"Usage:  \", verb, \" <object>\"));","return;","endif","set_task_perms(player);","o = player:my_match_object(dobjstr);","if (!$command_utils:object_match_failed(o, dobjstr))","player:notify($string_utils:names_of({o, @$object_utils:ancestors(o)}));","endif"]},{"name":"@location*s","owner":2,"perms":25,"preposition":-1,"code":["\"@locations <thing> - List <thing> and its containers, all the way back to the outermost one.\";","set_task_perms(player);","if (!dobjstr)","what = player;","elseif ((!valid(what = player:my_match_object(dobjstr))) && (!valid(what = $string_utils:match_player(dobjstr))))","$command_utils:object_match_failed(dobj, dobjstr);","return;","endif","player:notify($string_utils:names_of({what, @$object_utils:locations(what)}));"]},{"name":"@cl*asses","owner":2,"perms":89,"preposition":-2,"code":["\"$class_registry is in the following format:\";","\"        { {name, description, members}, ... }\";","\"where `name' is the name of a particular class of objects, `description' is a one-sentence description of the membership of the class, and `members' is a list of object numbers, the members of the class.\";","\"\";","if (!$command_utils:yes_or_no(\"This command can be very spammy.  Are you certain you need this information?\"))","return player:tell(\"OK, aborting.  The lag thanks you.\");","endif","if (args)","members = {};","for name in (args)","class = $list_utils:assoc_prefix(name, $class_registry);","if (class)","for o in (class[3])","members = setadd(members, o);","endfor","else","player:tell(\"There is no defined class of objects named `\", name, \"'; type `@classes' to see a complete list of defined classes.\");","return;","endif","endfor","printed = {};","for o in (members)","what = o;","while (valid(what))","printed = setadd(printed, what);","what = parent(what);","endwhile","endfor","player:tell(\"Members of the class\", (length(args) > 1) ? \"es\" | \"\", \" named \", $string_utils:english_list(args), \":\");","player:tell();","set_task_perms(player);","this:classes_2($root_class, \"\", members, printed);","player:tell();","else","\"List all class names and descriptions\";","player:tell(\"The following classes of objects have been defined:\");","for class in ($class_registry)","name = class[1];","description = class[2];","player:tell();","player:tell(\"-- \", name, \": \", description);","endfor","player:tell();","player:tell(\"Type `@classes <name>' to see the members of the class with the given <name>.\");","endif"]},{"name":"classes_2","owner":2,"perms":173,"preposition":-1,"code":["{root, indent, members, printed} = args;","if (root in members)","player:tell(indent, root.name, \" (\", root, \")\");","else","player:tell(indent, \"<\", root.name, \" (\", root, \")>\");","endif","printed = setremove(printed, root);","indent = indent + \"  \";","set_task_perms(caller_perms());","for c in ($list_utils:sort_suspended(2, $set_utils:intersection(children(root), printed)))","$command_utils:suspend_if_needed(10);","this:classes_2(c, indent, members, printed);","endfor"]},{"name":"_create","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","if (this:build_option(\"bi_create\"))","return $quota_utils:bi_create(@args);","else","return $recycler:(verb)(@args);","endif"]},{"name":"_recycle","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","if (this:build_option(\"bi_create\"))","return recycle(@args);","else","return $recycler:(verb)(@args);","endif"]},{"name":"@chparent","owner":2,"perms":89,"preposition":1,"code":["set_task_perms(player);","if ($command_utils:object_match_failed(object = player:my_match_object(dobjstr), dobjstr))","\"...bogus object...\";","elseif ($command_utils:object_match_failed(parent = player:my_match_object(iobjstr), iobjstr))","\"...bogus new parent...\";","elseif ((this != player) && (!$object_utils:isa(player, $player)))","\"...They chparented to #1 and want to chparent back to $prog.  Probably for some nefarious purpose...\";","player:notify(\"You don't seem to already be a valid player class.  Perhaps chparenting away from the $player hierarchy was not such a good idea.  Permission denied.\");","elseif (is_player(object) && (!$object_utils:isa(parent, $player)))","player:notify(tostr(object, \" is a player and \", parent, \" is not a player class.\"));","player:notify(\"You really *don't* want to do this.  Trust me.\");","else","if ($object_utils:isa(object, $mail_recipient))","if (!$command_utils:yes_or_no(\"Chparenting a mailing list is usually a really bad idea.  Do you really want to do it?  (If you don't know why we're asking this question, please say 'no'.)\"))","return player:tell(\"Aborted.\");","endif","endif","try","result = player:_chparent(object, parent);","player:notify(\"Parent changed.\");","except (E_INVARG)","if (valid(object) && valid(parent))","player:notify(tostr(\"Some property existing on \", parent, \" is defined on \", object, \" or one of its descendants.\"));","player:notify(tostr(\"Try @check-chparent \", dobjstr, \" to \", iobjstr));","else","player:notify(\"Either that is not a valid object or not a valid parent\");","endif","except (E_PERM)","player:notify(\"Either you don't own the object, don't own the parent, or the parent is not fertile.\");","except (E_RECMOVE)","player:notify(\"That parent object is a descendant of the object!\");","endtry","endif"]},{"name":"@check-chp*arent","owner":2,"perms":89,"preposition":1,"code":["\"Copied from generic programmer (#217):@check-chparent by ur-Rog (#6349) Sun Nov  8 22:13:53 1992 PST\";","\"@check-chparent object to newparent\";","\"checks for property name conflicts that would make @chparent bomb.\";","set_task_perms(player);","if (!(dobjstr && iobjstr))","player:notify(tostr(\"Usage:  \", verb, \" <object> to <newparent>\"));","elseif ($command_utils:object_match_failed(object = player:my_match_object(dobjstr), dobjstr))","\"...bogus object...\";","elseif ($command_utils:object_match_failed(parent = player:my_match_object(iobjstr), iobjstr))","\"...bogus new parent...\";","elseif (player != this)","player:notify(tostr(E_PERM));","elseif (typeof(result = $object_utils:property_conflicts(object, parent)) == ERR)","player:notify(tostr(result));","elseif (result)","su = $string_utils;","player:notify(\"\");","player:notify(su:left(\"Property\", 30) + \"Also Defined on\");","player:notify(su:left(\"--------\", 30) + \"---------------\");","for r in (result)","player:notify(su:left(tostr(parent, \".\", r[1]), 30) + su:from_list(listdelete(r, 1), \" \"));","$command_utils:suspend_if_needed(0);","endfor","else","player:notify(\"No property conflicts found.\");","endif"]},{"name":"@set*prop","owner":2,"perms":89,"preposition":1,"code":["\"Syntax:  @set <object>.<prop-name> to <value>\";","\"\";","\"Changes the value of the specified object's property to the given value.\";","\"You must have permission to modify the property, either because you own the property or if it is writable.\";","set_task_perms(player);","if (this != player)","return player:tell(E_PERM);","endif","l = $code_utils:parse_propref(dobjstr);","if (l)","dobj = player:my_match_object(l[1], player.location);","if ($command_utils:object_match_failed(dobj, l[1]))","return;","endif","prop = l[2];","to_i = \"to\" in args;","at_i = \"at\" in args;","i = (to_i && at_i) ? min(to_i, at_i) | (to_i || at_i);","iobjstr = argstr[$string_utils:word_start(argstr)[i][2] + 1..$];","iobjstr = $string_utils:trim(iobjstr);","if (!iobjstr)","try","val = dobj.(prop) = \"\";","except e (ANY)","player:tell(\"Unable to set \", dobj, \".\", prop, \": \", e[2]);","return;","endtry","iobjstr = \"\\\"\\\"\";","\"elseif (iobjstr[1] == \\\"\\\\\\\"\\\")\";","\"val = dobj.(prop) = iobjstr;\";","\"iobjstr = \\\"\\\\\\\"\\\" + iobjstr + \\\"\\\\\\\"\\\";\";","else","val = $string_utils:to_value(iobjstr);","if (!val[1])","player:tell(\"Could not parse: \", iobjstr);","return;","elseif (!$object_utils:has_property(dobj, prop))","player:tell(\"That object does not define that property.\");","return;","endif","try","val = dobj.(prop) = val[2];","except e (ANY)","player:tell(\"Unable to set \", dobj, \".\", prop, \": \", e[2]);","return;","endtry","endif","player:tell(\"Property \", dobj, \".\", prop, \" set to \", $string_utils:print(val), \".\");","else","player:tell(\"Property \", dobjstr, \" not found.\");","endif"]},{"name":"build_option","owner":2,"perms":173,"preposition":-1,"code":["\":build_option(name)\";","\"Returns the value of the specified builder option\";","if ((caller == this) || $perm_utils:controls(caller_perms(), this))","return $build_options:get(this.build_options, args[1]);","else","return E_PERM;","endif"]},{"name":"set_build_option","owner":2,"perms":173,"preposition":-1,"code":["\":set_build_option(oname,value)\";","\"Changes the value of the named option.\";","\"Returns a string error if something goes wrong.\";","if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))","return tostr(E_PERM);","endif","\"...this is kludgy, but it saves me from writing the same verb n times.\";","\"...there's got to be a better way to do this...\";","verb[1..4] = \"\";","foo_options = verb + \"s\";","\"...\";","if (typeof(s = #0.(foo_options):set(this.(foo_options), @args)) == STR)","return s;","elseif (s == this.(foo_options))","return 0;","else","this.(foo_options) = s;","return 1;","endif"]},{"name":"@build-o*ptions @buildo*ptions @builder-o*ptions @buildero*ptions","owner":2,"perms":89,"preposition":-2,"code":["\"@<what>-option <option> [is] <value>   sets <option> to <value>\";","\"@<what>-option <option>=<value>        sets <option> to <value>\";","\"@<what>-option +<option>     sets <option>   (usually equiv. to <option>=1\";","\"@<what>-option -<option>     resets <option> (equiv. to <option>=0)\";","\"@<what>-option !<option>     resets <option> (equiv. to <option>=0)\";","\"@<what>-option <option>      displays value of <option>\";","set_task_perms(player);","what = \"build\";","options = what + \"_options\";","option_pkg = #0.(options);","set_option = (\"set_\" + what) + \"_option\";","if (!args)","player:notify_lines({(\"Current \" + what) + \" options:\", \"\", @option_pkg:show(this.(options), option_pkg.names)});","return;","elseif (typeof(presult = option_pkg:parse(args)) == STR)","player:notify(presult);","return;","else","if (length(presult) > 1)","if (typeof(sresult = this:(set_option)(@presult)) == STR)","player:notify(sresult);","return;","elseif (!sresult)","player:notify(\"No change.\");","return;","endif","endif","player:notify_lines(option_pkg:show(this.(options), presult[1]));","endif"]},{"name":"@measure","owner":36,"perms":89,"preposition":-2,"code":["\"Syntax:\";","\"  @measure object <object name>\";","\"  @measure summary [player]\";","\"  @measure new [player]\";","\"  @measure breakdown <object name>\";","\"  @measure recent [number of days] [player]\";","if (length(args) < 1)","player:tell_lines($code_utils:verb_documentation());","return;","endif","if (index(\"object\", args[1]) == 1)","\"Object.\";","what = player.location:match_object(name = $string_utils:from_list(args[2..$], \" \"));","if (!valid(what))","player:tell(\"Sorry, I didn't understand `\", name, \"'\");","elseif ((((($object_utils:has_property(what, \"object_size\") && (what.object_size[1] > $byte_quota_utils.too_large)) && (!player.wizard)) && (player != $byte_quota_utils.owner)) && (player != $hacker)) && (player != what.owner))","player:tell($string_utils:nn(what), \" when last measured was \", $string_utils:group_number(what.object_size[1]), \" bytes.  To reduce lag induced by multiple players re-measuring large objects multiple times, you may not measure that object.\");","elseif ((`what.object_size[2] ! ANY => 0' > (time() - 86400)) && (!$command_utils:yes_or_no(tostr(\"That object was measured only \", $string_utils:from_seconds(time() - what.object_size[2]), \" ago.  Please don't lag the MOO by remeasuring things frequently.  Are you sure you want to remeasure it?\"))))","return player:tell(\"Not measuring.  It was \", $string_utils:group_number(what.object_size[1]), \" bytes when last measured.\");","else","player:tell(\"Checking size of \", what.name, \" (\", what, \")...\");","player:tell(\"Size of \", what.name, \" (\", what, \") is \", $byte_quota_utils:object_bytes(what), \" bytes.\");","endif","elseif (index(\"summary\", args[1]) == 1)","\"Summarize player.\";","if (length(args) == 1)","what = player;","else","what = $string_utils:match_player(name = $string_utils:from_list(args[2..$], \" \"));","endif","if (!valid(what))","player:tell(\"Sorry, I don't know who you mean by `\", name, \"'\");","else","$byte_quota_utils:do_summary(what);","endif","elseif (index(\"new\", args[1]) == 1)","if (length(args) == 1)","what = player;","elseif (!valid(what = $string_utils:match_player(name = $string_utils:from_list(args[2..$], \" \"))))","return $command_utils:player_match_failed(what, name);","endif","player:tell(\"Measuring the sizes of \", what.name, \"'s recently created objects...\");","total = 0;","unmeasured_index = 4;","unmeasured_multiplier = 100;","nunmeasured = 0;","if (typeof(what.owned_objects) == LIST)","for x in (what.owned_objects)","if (!$object_utils:has_property(x, \"object_size\"))","nunmeasured = nunmeasured + 1;","elseif (!x.object_size[1])","player:tell(\"Measured \", $string_utils:nn(x), \":  \", size = $byte_quota_utils:object_bytes(x), \" bytes.\");","total = total + size;","endif","$command_utils:suspend_if_needed(5);","endfor","if (nunmeasured && (what.size_quota[unmeasured_index] < (unmeasured_multiplier * nunmeasured)))","what.size_quota[unmeasured_index] = (what.size_quota[unmeasured_index] % unmeasured_multiplier) + (nunmeasured * unmeasured_multiplier);","endif","player:tell(\"Total bytes used in new creations: \", total, \".\", nunmeasured ? tostr(\"There were a total of \", nunmeasured, \" object(s) found with no .object_size property.  This will prevent additional building.\") | \"\");","else","player:tell(\"Sorry, \", what.name, \" is not enrolled in the object measurement scheme.\");","endif","elseif (index(\"recent\", args[1]) == 1)","\"@measure recent days player\";","if (length(args) > 1)","days = $code_utils:toint(args[2]);","else","days = $byte_quota_utils.cycle_days;","endif","if (!days)","return player:tell(\"Couldn't understand `\", args[2], \"' as a positive integer.\");","endif","if (length(args) > 2)","if (!valid(who = $string_utils:match_player(name = $string_utils:from_list(args[3..$], \" \"))))","return $command_utils:player_match_failed(who, name);","endif","else","who = player;","endif","if (typeof(who.owned_objects) == LIST)","player:tell(\"Re-measuring objects of \", $string_utils:nn(who), \" which have not been measured in the past \", days, \" days.\");","when = time() - (days * 86400);","which = {};","for x in (who.owned_objects)","if (x.object_size[2] < when)","$byte_quota_utils:object_size(x);","which = setadd(which, x);","$command_utils:suspend_if_needed(3, \"...measuring\");","endif","endfor","player:tell(\"Done, re-measured \", length(which), \" objects.\", (length(which) > 0) ? \"  Recommend you use @measure summary to update the display of @quota.\" | \"\");","else","player:tell(\"Sorry, \", who.name, \" is not enrolled in the object measurement scheme.\");","endif","elseif (index(\"breakdown\", args[1]) == 1)","what = player.location:match_object(name = $string_utils:from_list(args[2..$], \" \"));","if (!valid(what))","player:tell(\"Sorry, I didn't understand `\", name, \"'\");","elseif (!$byte_quota_utils:can_peek(player, what.owner))","return player:tell(\"Sorry, you don't control \", what.name, \" (\", what, \")\");","else","if (mail = $command_utils:yes_or_no(\"This might be kinda long.  Want me to mail you the result?\"))","player:tell(\"Result will be mailed.\");","endif","info = $byte_quota_utils:do_breakdown(what);","if (typeof(info) == ERR)","player:tell(info);","endif","if (mail)","$mail_agent:send_message($byte_quota_utils.owner, {player}, tostr(\"Object breakdown of \", what.name, \" (\", what, \")\"), info);","else","player:tell_lines_suspended(info);","endif","endif","else","player:tell(\"Not a sub-command of @measure: \", args[1]);","player:tell_lines($code_utils:verb_documentation());","endif"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","if (this == $builder)","this.build_options = {};","else","clear_property(this, \"build_options\");","endif","return pass(@args);","endif"]},{"name":"g*et t*ake","owner":2,"perms":45,"preposition":-1,"code":["set_task_perms(callers() ? caller_perms() | player);","if (this.location == player)","player:tell(\"You already have that!\");","elseif (this.location != player.location)","player:tell(\"I don't see that here.\");","else","this:moveto(player);","if (this.location == player)","player:tell(this:take_succeeded_msg() || \"Taken.\");","if (msg = this:otake_succeeded_msg())","player.location:announce(player.name, \" \", msg);","endif","else","player:tell(this:take_failed_msg() || \"You can't pick that up.\");","if (msg = this:otake_failed_msg())","player.location:announce(player.name, \" \", msg);","endif","endif","endif"]},{"name":"d*rop th*row","owner":2,"perms":45,"preposition":-1,"code":["set_task_perms(callers() ? caller_perms() | player);","if (this.location != player)","player:tell(\"You don't have that.\");","elseif (!player.location:acceptable(this))","player:tell(\"You can't drop that here.\");","else","this:moveto(player.location);","if (this.location == player.location)","player:tell_lines(this:drop_succeeded_msg() || \"Dropped.\");","if (msg = this:odrop_succeeded_msg())","player.location:announce(player.name, \" \", msg);","endif","else","player:tell_lines(this:drop_failed_msg() || \"You can't seem to drop that here.\");","if (msg = this:odrop_failed_msg())","player.location:announce(player.name, \" \", msg);","endif","endif","endif"]},{"name":"moveto","owner":2,"perms":173,"preposition":-1,"code":["where = args[1];","\"if (!valid(where) || this:is_unlocked_for(where))\";","if (this:is_unlocked_for(where))","pass(where);","endif"]},{"name":"take_failed_msg take_succeeded_msg otake_failed_msg otake_succeeded_msg drop_failed_msg drop_succeeded_msg odrop_failed_msg odrop_succeeded_msg","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","return $string_utils:pronoun_sub(this.(verb));"]},{"name":"gi*ve ha*nd","owner":2,"perms":109,"preposition":1,"code":["set_task_perms(callers() ? caller_perms() | player);","if (this.location != player)","player:tell(\"You don't have that!\");","elseif (!valid(player.location))","player:tell(\"I see no \\\"\", iobjstr, \"\\\" here.\");","elseif ($command_utils:object_match_failed(who = player.location:match_object(iobjstr), iobjstr))","elseif (who.location != player.location)","player:tell(\"I see no \\\"\", iobjstr, \"\\\" here.\");","elseif (who == player)","player:tell(\"Give it to yourself?\");","else","this:moveto(who);","if (this.location == who)","player:tell(\"You hand \", this:title(), \" to \", who:title(), \".\");","who:tell(player:titlec(), \" \", $gender_utils:get_conj(\"hands/hand\", player), \" you \", this:title(), \".\");","else","player:tell(who:titlec(), \" \", $gender_utils:get_conj(\"does/do\", who), \" not want that item.\");","endif","endif"]},{"name":"examine_key","owner":2,"perms":173,"preposition":-1,"code":["\"examine_key(examiner)\";","\"return a list of strings to be told to the player, indicating what the key on this type of object means, and what this object's key is set to.\";","\"the default will only tell the key to a wizard or this object's owner.\";","who = args[1];","if (((caller == this) && $perm_utils:controls(who, this)) && (this.key != 0))","return {tostr(this:title(), \" can only be moved to locations matching this key:\"), tostr(\"  \", $lock_utils:unparse_key(this.key))};","endif"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","pass();","this.home = (this in {$no_one, $hacker}) ? $nothing | $player_start;","if (a = $list_utils:assoc(this, {{$prog, {$prog_help, $builtin_function_help, $verb_help, $core_help}}, {$wiz, $wiz_help}, {$builder, $builder_help}, {$mail_recipient_class, $mail_help}, {$frand_class, $frand_help}}))","this.help = a[2];","else","this.help = 0;","endif","if (this != $player)","for p in ({\"last_connect_place\", \"all_connect_places\", \"features\", \"previous_connection\", \"last_connect_time\"})","clear_property(this, p);","endfor","if (is_player(this))","this.first_connect_time = $maxint;","this.last_disconnect_time = $maxint;","endif","endif","endif"]},{"name":"confunc","owner":2,"perms":173,"preposition":-1,"code":["if (((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (caller != #0))","return E_PERM;","endif","this:(\"@last-connection\")();","$news:check();"]},{"name":"disfunc","owner":2,"perms":173,"preposition":-1,"code":["if (((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (caller != #0))","return E_PERM;","endif","this:expunge_rmm();","this:erase_paranoid_data();","this:gc_gaglist();","return;"]},{"name":"initialize","owner":2,"perms":173,"preposition":-1,"code":["if ((caller == this) || $perm_utils:controls(caller_perms(), this))","this.help = 0;","return pass(@args);","else","return E_PERM;","endif"]},{"name":"acceptable","owner":2,"perms":173,"preposition":-1,"code":["return !is_player(args[1]);"]},{"name":"my_huh","owner":2,"perms":173,"preposition":-1,"code":["\"Extra parsing of player commands.  Called by $command_utils:do_huh.\";","\"This version of my_huh just handles features.\";","permissions = (((caller == this) || $perm_utils:controls(caller_perms(), this)) && $command_utils:validate_feature(@args)) ? this | $no_one;","\"verb - obvious                 pass - would be args\";","\"plist - list of prepspecs that this command matches\";","\"dlist and ilist - likewise for dobjspecs, iobjspecs\";","verb = args[1];","if ($code_utils:toint(verb))","return;","endif","pass = args[2];","plist = {\"any\", prepstr ? $code_utils:full_prep(prepstr) | \"none\"};","dlist = dobjstr ? {\"any\"} | {\"none\", \"any\"};","ilist = iobjstr ? {\"any\"} | {\"none\", \"any\"};","for fobj in (this.features)","if (!$recycler:valid(fobj))","this:remove_feature(fobj);","elseif (`valid(loc = $object_utils:has_callable_verb(fobj, verb)[1]) ! ANY => 0')","vargs = verb_args(loc, verb);","if ((vargs[2] in plist) && ((vargs[1] in dlist) && (vargs[3] in ilist)))","\"(got rid of notify_huh - should write a @which command)\";","\"if (this.notify_huh)\";","\"player:notify(tostr(\\\"Using \\\", what.name, \\\" (\\\", what, \\\")\\\"));\";","\"endif\";","set_task_perms(permissions);","fobj:(verb)(@pass);","\"Problem with verbs of the same name. If we use which=vrb in the loop instead, we have a problem with verbs that use the variable verb.\";","return 1;","endif","endif","if ($command_utils:running_out_of_time())","player:tell(\"You have too many features.  Parsing your command runs out of ticks while checking \", fobj.name, \" (\", fobj, \").\");","return 1;","endif","endfor"]},{"name":"last_huh","owner":2,"perms":173,"preposition":-1,"code":["\":last_huh(verb,args)  final attempt to parse a command...\";","set_task_perms(caller_perms());","{verb, args} = args;","if ((verb[1] == \"@\") && (prepstr == \"is\"))","\"... set or show _msg property ...\";","set_task_perms(player);","$last_huh:(verb)(@args);","return 1;","elseif (verb in {\"give\", \"hand\", \"get\", \"take\", \"drop\", \"throw\"})","$last_huh:(verb)(@args);","return 1;","else","return 0;","endif"]},{"name":"my_match_object","owner":2,"perms":173,"preposition":-1,"code":["\":my_match_object(string [,location])\";","return $string_utils:match_object(@{@args, this.location}[1..2], this);"]},{"name":"tell_contents","owner":2,"perms":173,"preposition":-1,"code":["c = args[1];","if (c)","longear = {};","gear = {};","width = player:linelen();","half = width / 2;","player:tell(\"Carrying:\");","for thing in (c)","cx = tostr(\" \", thing:title());","if (length(cx) > half)","longear = {@longear, cx};","else","gear = {@gear, cx};","endif","endfor","player:tell_lines($string_utils:columnize(gear, 2, width));","player:tell_lines(longear);","endif"]},{"name":"titlec","owner":2,"perms":173,"preposition":-1,"code":["return `this.namec ! E_PROPNF => this:title()';"]},{"name":"notify","owner":2,"perms":173,"preposition":-1,"code":["line = args[1];","if (this.pagelen)","if (!(this in connected_players()))","\"...drop it on the floor...\";","return 0;","elseif ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))","return E_PERM;","endif","\"...need wizard perms if this and this.owner are different, since...\";","\"...only this can notify() and only this.owner can read .linebuffer...\";","if ((player == this) && (this.linetask[2] != task_id()))","\"...player has started a new task...\";","\"....linetask[2] is the taskid of the most recent player task...\";","if (this.linetask[2] != this.linetask[1])","this.linesleft = this.pagelen - 2;","endif","this.linetask[2] = task_id();","endif","\"... digest the current line...\";","if (this.linelen > 0)","lbuf = {@this.linebuffer, @this:linesplit(line, this.linelen)};","else","lbuf = {@this.linebuffer, line};","endif","\"... print out what we can...\";","if (this.linesleft)","howmany = min(this.linesleft, length(lbuf));","for l in (lbuf[1..howmany])","pass(l);","endfor","this.linesleft = this.linesleft - howmany;","lbuf[1..howmany] = {};","endif","if (lbuf)","\"...see if we need to say ***More***\";","if (this.linetask[1] != this.linetask[2])","\"....linetask[1] is the taskid of the most recent player task\";","\"...   for which ***More*** was printed...\";","this.linetask[1] = this.linetask[2];","fork (0)","if (lb = this.linebuffer)","pass(strsub(this.more_msg, \"%n\", tostr(length(lb))));","endif","endfork","endif","llen = length(lbuf);","if (llen > 500)","\"...way too much saved text, flush some of it...\";","lbuf[1..llen - 100] = {\"*** buffer overflow, lines flushed ***\"};","endif","endif","this.linebuffer = lbuf;","else","if (caller != this)","set_task_perms(caller_perms());","endif","if (this.linelen > 0)","for l in (this:linesplit(line, this.linelen))","pass(l);","endfor","else","pass(line);","endif","endif"]},{"name":"notify_lines","owner":2,"perms":173,"preposition":-1,"code":["if (($perm_utils:controls(caller_perms(), this) || (caller == this)) || (caller_perms() == this))","set_task_perms(caller_perms());","for line in ((typeof(lines = args[1]) != LIST) ? {lines} | lines)","this:notify(tostr(line));","endfor","else","return E_PERM;","endif"]},{"name":"linesplit","owner":2,"perms":173,"preposition":-1,"code":["\":linesplit(line,len) => list of substrings of line\";","\"used by :notify to split up long lines if .linelen>0\";","{line, len} = args;","cline = {};","while (length(line) > len)","cutoff = rindex(line[1..len], \" \");","if (nospace = cutoff < ((4 * len) / 5))","cutoff = len + 1;","nospace = line[cutoff] != \" \";","endif","cline = {@cline, line[1..cutoff - 1]};","line = (nospace ? \" \" | \"\") + line[cutoff..$];","endwhile","return {@cline, line};"]},{"name":"linelen","owner":36,"perms":173,"preposition":-1,"code":["return abs(this.linelen);"]},{"name":"@more","owner":2,"perms":25,"preposition":-1,"code":["if (player != this)","\"... somebody's being sneaky...\";","\"... Can't do set_task_perms(player) since we need to be `this'...\";","\"... to notify and `this.owner' to change +c properties...\";","return;","elseif (!(lbuf = this.linebuffer))","this.linesleft = this.pagelen - 2;","notify(this, \"*** No more ***\");","elseif (index(\"flush\", dobjstr || \"x\") == 1)","this.linesleft = this.pagelen - 2;","notify(this, tostr(\"*** Flushed ***  \", length(lbuf), \" lines\"));","this.linebuffer = {};","elseif ((index(\"rest\", dobjstr || \"x\") == 1) || (!this.pagelen))","this.linesleft = this.pagelen - 2;","for l in (lbuf)","notify(this, l);","endfor","this.linebuffer = {};","else","howmany = min(this.pagelen - 2, llen = length(lbuf = this.linebuffer));","for l in (lbuf[1..howmany])","notify(this, l);","endfor","this.linesleft = (this.pagelen - 2) - howmany;","this.linebuffer = lbuf[howmany + 1..llen];","if (howmany < llen)","notify(this, strsub(this.more_msg, \"%n\", tostr(llen - howmany)));","this.linetask[1] = task_id();","endif","endif","this.linetask[2] = task_id();"]},{"name":"@wrap","owner":36,"perms":9,"preposition":-2,"code":["if (player != this)","\"... someone is being sneaky...\";","\"... Can't do set_task_perms(player) since we need to be `this'...\";","\"... to notify and `this.owner' to change +c properties...\";","return;","endif","linelen = player.linelen;","if (!(prepstr in {\"on\", \"off\"}))","player:notify(\"Usage:  @wrap on|off\");","player:notify(tostr(\"Word wrap is currently \", (linelen > 0) ? \"on\" | \"off\", \".\"));","return;","endif","player.linelen = abs(linelen) * ((prepstr == \"on\") ? 1 | -1);","player:notify(tostr(\"Word wrap is now \", prepstr, \".\"));"]},{"name":"@linelen*gth","owner":36,"perms":25,"preposition":-1,"code":["if (callers() ? (caller != this) && (!$perm_utils:controls(caller_perms(), this)) | (player != this))","\"... somebody is being sneaky ...\";","return;","endif","curlen = player.linelen;","wrap = curlen > 0;","wrapstr = wrap ? \"on\" | \"off\";","if (!dobjstr)","player:notify(tostr(\"Usage:  \", verb, \" <number>\"));","player:notify(tostr(\"Current line length is \", abs(curlen), \".  Word wrapping is \", wrapstr, \".\"));","return;","endif","newlen = toint(dobjstr);","if (newlen < 0)","player:notify(\"Line length can't be a negative number.\");","return;","elseif (newlen < 10)","player:notify(\"You don't want your linelength that small.  Setting it to 10.\");","newlen = 10;","endif","this:set_linelength(newlen);","player:notify(tostr(\"Line length is now \", abs(player.linelen), \".  Word wrapping is \", wrapstr, \".\"));","if (!wrap)","player:notify(\"To enable word wrapping, type `@wrap on'.\");","endif"]},{"name":"@pagelen*gth","owner":2,"perms":25,"preposition":-1,"code":["\"@pagelength number  -- sets page buffering to that many lines (or 0 to turn off page buffering)\";","if (player != this)","\"... somebody is being sneaky ...\";","\"... Can't do set_task_perms(player) since we need to be `this'...\";","\"... to notify and `this.owner' to change +c properties...\";","return;","elseif (!dobjstr)","notify(player, tostr(\"Usage:  \", verb, \" <number>\"));","notify(player, tostr(\"Current page length is \", player.pagelen, \".\"));","return;","elseif (0 > (newlen = toint(dobjstr)))","notify(player, \"Page length can't be a negative number.\");","return;","elseif (newlen == 0)","player.pagelen = 0;","notify(player, \"Page buffering off.\");","if (lb = this.linebuffer)","\"queued text remains\";","this:notify_lines(lb);","clear_property(this, \"linebuffer\");","endif","elseif (newlen < 5)","player.pagelen = 5;","notify(player, \"Too small.  Setting it to 5.\");","else","notify(player, tostr(\"Page length is now \", player.pagelen = newlen, \".\"));","endif","if (this.linebuffer)","notify(this, strsub(this.more_msg, \"%n\", tostr(length(this.linebuffer))));","player.linetask = {task_id(), task_id()};","player.linesleft = 0;","else","player.linetask = {0, task_id()};","player.linesleft = player.pagelen - 2;","endif"]},{"name":"tell","owner":2,"perms":173,"preposition":-1,"code":["if (this.gaglist || this.paranoid)","\"Check the above first, default case, to save ticks.  Paranoid gaggers are cost an extra three or so ticks by this, probably a net savings.\";","if (this:gag_p())","return;","endif","if (this.paranoid == 1)","$paranoid_db:add_data(this, {{@callers(1), {player, \"<cmd-line>\", player}}, args});","elseif (this.paranoid == 2)","z = this:whodunnit({@callers(), {player, \"\", player}}, {this, $no_one}, {})[3];","args = {\"(\", z.name, \" \", z, \") \", @args};","endif","endif","pass(@args);"]},{"name":"gag_p","owner":2,"perms":173,"preposition":-1,"code":["if (player in this.gaglist)","return 1;","elseif (gag = this.gaglist)","for x in (callers())","if (((x[1] == #-1) && (x[3] == #-1)) && (x[2] != \"\"))","elseif ((x[1] in gag) || (x[4] in gag))","return 1;","endif","endfor","endif","return 0;","\"--- old definition --\";","if (player in this.gaglist)","return 1;","elseif (this.gaglist)","for x in (callers())","if (valid(x[1]))","if (x[1] in this.gaglist)","return 1;","endif","endif","endfor","endif","return 0;"]},{"name":"set_gaglist","owner":2,"perms":173,"preposition":-1,"code":["\":set_gaglist(@newlist) => this.gaglist = newlist\";","if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))","return E_PERM;","else","return this.gaglist = args;","endif"]},{"name":"@gag*!","owner":2,"perms":89,"preposition":-2,"code":["set_task_perms(player);","if (player != this)","player:notify(\"Permission denied.\");","return;","endif","if (!args)","player:notify(tostr(\"Usage:  \", verb, \" <player or object> [<player or object>...]\"));","return;","endif","victims = $string_utils:match_player_or_object(@args);","changed = 0;","for p in (victims)","if (p in player.gaglist)","player:notify(tostr(\"You are already gagging \", p.name, \".\"));","elseif (p == player)","player:notify(\"Gagging yourself is a bad idea.\");","elseif (children(p) && (verb != \"@gag!\"))","player:tell(\"If you really want to gag all descendents of \", $string_utils:nn(p), \", use `@gag! \", p, \"' instead.\");","else","changed = 1;","player:set_gaglist(@setadd(this.gaglist, p));","endif","endfor","if (changed)","this:(\"@listgag\")();","endif"]},{"name":"@listgag @gaglist @gagged","owner":2,"perms":29,"preposition":-1,"code":["set_task_perms(valid(caller_perms()) ? caller_perms() | player);","if (!this.gaglist)","player:notify(tostr(\"You are \", callers() ? \"no longer gagging anything.\" | \"not gagging anything right now.\"));","else","player:notify(tostr(\"You are \", callers() ? \"now\" | \"currently\", \" gagging \", $string_utils:english_list($list_utils:map_arg(2, $string_utils, \"pronoun_sub\", \"%n (%#)\", this.gaglist)), \".\"));","endif","gl = {};","if (args)","player:notify(\"Searching for players who may be gagging you...\");","for p in (players())","if ((typeof(`p.gaglist ! E_PERM') == LIST) && (this in p.gaglist))","gl = {@gl, p};","endif","$command_utils:suspend_if_needed(10, \"...searching gaglist...\");","endfor","if (gl || (!callers()))","player:notify(tostr($string_utils:english_list($list_utils:map_arg(2, $string_utils, \"pronoun_sub\", \"%n (%#)\", gl), \"No one\"), \" appear\", (length(gl) <= 1) ? \"s\" | \"\", \" to be gagging you.\"));","endif","endif"]},{"name":"@ungag","owner":2,"perms":29,"preposition":-1,"code":["if ((player != this) || ((caller != this) && (!$perm_utils:controls(caller_perms(), this))))","player:notify(\"Permission denied.\");","elseif (dobjstr == \"\")","player:notify(tostr(\"Usage:  \", verb, \" <player>  or  \", verb, \" everyone\"));","elseif (dobjstr == \"everyone\")","this.gaglist = {};","player:notify(\"You are no longer gagging anyone or anything.\");","else","if (valid(dobj))","match = dobj;","elseif ((match = toobj(dobjstr)) > #0)","else","match = $string_utils:match(dobjstr, this.gaglist, \"name\", this.gaglist, \"aliases\");","endif","if (match == $failed_match)","player:notify(tostr(\"You don't seem to be gagging anything named \", dobjstr, \".\"));","elseif (match == $ambiguous_match)","player:notify(tostr(\"I don't know which \\\"\", dobjstr, \"\\\" you mean.\"));","else","this.gaglist = setremove(this.gaglist, match);","player:notify(tostr(valid(match) ? match.name | match, \" removed from gag list.\"));","endif","this:(\"@listgag\")();","endif"]},{"name":"whodunnit","owner":2,"perms":173,"preposition":-1,"code":["{record, trust, mistrust} = args;","s = {this, \"???\", this};","for w in (record)","if (((((!valid(s[3])) || s[3].wizard) || (s[3] in trust)) && (!(s[3] in mistrust))) || (s[1] == this))","s = w;","else","return s;","endif","endfor","return s;"]},{"name":"@ch*eck-full","owner":2,"perms":89,"preposition":-2,"code":["responsible = $paranoid_db:get_data(this);","if (length(verb) <= 6)","\"@check, not @check-full\";","n = 5;","trust = {this, $no_one};","\"... trust no one, my friend.... no one....  --Herod\";","mistrust = {};","for k in (args)","if (z = $code_utils:toint(k))","n = z;","elseif (k[1] == \"!\")","mistrust = listappend(mistrust, $string_utils:match_player(k[2..$]));","else","trust = listappend(trust, $string_utils:match_player(k));","endif","endfor","msg_width = player:linelen() - 60;","for q in ((n > (y = length(responsible))) ? responsible | responsible[(y - n) + 1..y])","msg = tostr(@q[2]);","if (length(msg) > msg_width)","msg = msg[1..msg_width];","endif","s = this:whodunnit(q[1], trust, mistrust);","text = valid(s[1]) ? s[1].name | \"** NONE **\";","this:notify(tostr($string_utils:left(tostr((length(text) > 13) ? text[1..13] | text, \" (\", s[1], \")\"), 20), $string_utils:left(s[2], 15), $string_utils:left(tostr((length(s[3].name) > 13) ? s[3].name[1..13] | s[3].name, \" (\", s[3], \")\"), 20), msg));","endfor","this:notify(\"*** finished ***\");","else","\"@check-full, from @traceback by APHiD\";","\"s_i_n's by Ho_Yan 10/18/94\";","matches = {};","if (length(match = argstr) == 0)","player:notify(tostr(\"Usage: \", verb, \" <string> --or-- \", verb, \" <number>\"));","return;","endif","if (!responsible)","player:notify(\"No text has been saved by the monitor.  (See `help @paranoid').\");","else","if (typeof(x = $code_utils:toint(argstr)) == ERR)","for line in (responsible)","if (index(tostr(@line[$]), argstr))","matches = {@matches, line};","endif","endfor","else","matches = responsible[($ - x) + 1..$];","endif","if (matches)","for match in (matches)","$command_utils:suspend_if_needed(3);","text = tostr(@match[$]);","player:notify(\"Traceback for:\");","player:notify(text);","\"Moved cool display code to $code_utils, 3/29/95, Ho_Yan\";","$code_utils:display_callers(listdelete(mm = match[1], length(mm)));","endfor","player:notify(\"**** finished ****\");","else","player:notify(tostr(\"No matches for \\\"\", argstr, \"\\\" found.\"));","endif","endif","endif"]},{"name":"@paranoid","owner":2,"perms":89,"preposition":-2,"code":["if ((args == {}) || ((typ = args[1]) == \"\"))","$paranoid_db:set_kept_lines(this, 10);","this.paranoid = 1;","this:notify(\"Anti-spoofer on and keeping 10 lines.\");","elseif (index(\"immediate\", typ))","$paranoid_db:set_kept_lines(this, 0);","this.paranoid = 2;","this:notify(\"Anti-spoofer now in immediate mode.\");","elseif (index(\"off\", typ) || (typ == \"0\"))","this.paranoid = 0;","$paranoid_db:set_kept_lines(this, 0);","this:notify(\"Anti-spoofer off.\");","elseif ((tostr(y = toint(typ)) != typ) || (y < 0))","this:notify(tostr(\"Usage: \", verb, \" <lines to be kept>     to turn on your anti-spoofer.\"));","this:notify(tostr(\"       \", verb, \" off                    to turn it off.\"));","this:notify(tostr(\"       \", verb, \" immediate              to use immediate mode.\"));","else","this.paranoid = 1;","$paranoid_db:set_kept_lines(this, y = min(y, 30));","this:notify(tostr(\"Anti-spoofer on and keeping \", y, \" lines.\"));","endif"]},{"name":"@sw*eep","owner":2,"perms":9,"preposition":-1,"code":["buggers = 1;","found_listener = 0;","here = this.location;","for thing in (setremove(here.contents, this))","tellwhere = $object_utils:has_verb(thing, \"tell\");","notifywhere = $object_utils:has_verb(thing, \"notify\");","if (thing in connected_players())","this:notify(tostr(thing.name, \" (\", thing, \") is listening.\"));","found_listener = 1;","elseif ($object_utils:has_callable_verb(thing, \"sweep_msg\") && (typeof(msg = thing:sweep_msg()) == STR))","this:notify(tostr(thing.name, \" (\", thing, \") \", msg, \".\"));","found_listener = 1;","elseif (tellwhere && (((owner = verb_info(tellwhere[1], \"tell\")[1]) != this) && (!owner.wizard)))","this:notify(tostr(thing.name, \" (\", thing, \") has been taught to listen by \", owner.name, \" (\", owner, \")\"));","found_listener = 1;","elseif (notifywhere && (((owner = verb_info(notifywhere[1], \"notify\")[1]) != this) && (!owner.wizard)))","this:notify(tostr(thing.name, \" (\", thing, \") has been taught to listen by \", owner.name, \" (\", owner, \")\"));","found_listener = 1;","endif","endfor","buggers = {};","for v in ({\"announce\", \"announce_all\", \"announce_all_but\", \"say\", \"emote\", \"huh\", \"here_huh\", \"huh2\", \"whisper\", \"here_explain_syntax\"})","vwhere = $object_utils:has_verb(here, v);","if (vwhere && (((owner = verb_info(vwhere[1], v)[1]) != this) && (!owner.wizard)))","buggers = setadd(buggers, owner);","endif","endfor","if (buggers != {})","if ($object_utils:has_verb(here, \"sweep_msg\") && (typeof(msg = here:sweep_msg()) == STR))","this:notify(tostr(here.name, \" (\", here, \") \", msg, \".\"));","else","this:notify(tostr(here.name, \" (\", here, \") may have been bugged by \", $string_utils:english_list($list_utils:map_prop(buggers, \"name\")), \".\"));","endif","elseif (!found_listener)","this:notify(\"Communications look secure.\");","endif"]},{"name":"wh*isper","owner":2,"perms":157,"preposition":1,"code":["this:tell(player.name, \" whispers, \\\"\", dobjstr, \"\\\"\");","player:tell(\"You whisper, \\\"\", dobjstr, \"\\\" to \", this.name, \".\");"]},{"name":"page","owner":2,"perms":93,"preposition":-2,"code":["nargs = length(args);","if (nargs < 1)","player:notify(tostr(\"Usage: \", verb, \" <player> [with <message>]\"));","return;","endif","who = $string_utils:match_player(args[1]);","if ($command_utils:player_match_result(who, args[1])[1])","return;","elseif (who in this.gaglist)","player:tell(\"You have \", who:title(), \" @gagged.  If you paged \", $gender_utils:get_pronoun(\"o\", who), \", \", $gender_utils:get_pronoun(\"s\", who), \" wouldn't be able to answer you.\");","return;","endif","\"for pronoun_sub's benefit...\";","dobj = who;","iobj = player;","header = player:page_origin_msg();","text = \"\";","if (nargs > 1)","if ((args[2] == \"with\") && (nargs > 2))","msg_start = 3;","else","msg_start = 2;","endif","msg = $string_utils:from_list(args[msg_start..nargs], \" \");","text = tostr($string_utils:pronoun_sub(($string_utils:index_delimited(header, player.name) ? \"%S\" | \"%N\") + \" %<pages>, \\\"\"), msg, \"\\\"\");","endif","result = text ? who:receive_page(header, text) | who:receive_page(header);","if (result == 2)","\"not connected\";","player:tell((typeof(msg = who:page_absent_msg()) == STR) ? msg | $string_utils:pronoun_sub(\"%n is not currently logged in.\", who));","else","player:tell(who:page_echo_msg());","endif"]},{"name":"receive_page","owner":2,"perms":173,"preposition":-1,"code":["\"called by $player:page.  Two args, the page header and the text, all pre-processed by the page command.  Could be extended to provide haven abilities, multiline pages, etc.  Indeed, at the moment it just does :tell_lines, so we already do have multiline pages, if someone wants to take advantage of it.\";","\"Return codes:\";","\"  1:  page was received\";","\"  2:  player is not connected\";","\"  0:  page refused\";","\"If a specialization wants to refuse a page, it should return 0 to say it was refused.  If it uses pass(@args) it should propagate back up the return value.  It is possible that this code should interact with gagging and return 0 if the page was gagged.\";","if (this:is_listening())","this:tell_lines_suspended(args);","return 1;","else","return 2;","endif"]},{"name":"page_origin_msg page_echo_msg page_absent_msg","owner":36,"perms":173,"preposition":-1,"code":["\"set_task_perms(this.owner)\";","return (msg = `this.(verb) ! ANY') ? $string_utils:pronoun_sub(this.(verb), this) | \"\";"]},{"name":"i inv*entory","owner":2,"perms":9,"preposition":-1,"code":["if (c = player:contents())","this:tell_contents(c);","else","player:tell(\"You are empty-handed.\");","endif"]},{"name":"look_self","owner":2,"perms":173,"preposition":-1,"code":["player:tell(this:titlec());","pass();","if (!(this in connected_players()))","player:tell($gender_utils:pronoun_sub(\"%{:He} %{!is} sleeping.\", this));","elseif ((idle = idle_seconds(this)) < 60)","player:tell($gender_utils:pronoun_sub(\"%{:He} %{!is} awake and %{!looks} alert.\", this));","else","time = $string_utils:from_seconds(idle);","player:tell($gender_utils:pronoun_sub(\"%{:He} %{!is} awake, but %{!has} been staring off into space for \", this), time, \".\");","endif","if (c = this:contents())","this:tell_contents(c);","endif"]},{"name":"home","owner":2,"perms":9,"preposition":-1,"code":["start = this.location;","if (start == this.home)","player:tell(\"You're already home!\");","return;","elseif (typeof(this.home) != OBJ)","player:tell(\"You've got a weird home, pal.  I've reset it to the default one.\");","this.home = $player_start;","elseif (!valid(this.home))","player:tell(\"Oh no!  Your home's been recycled.  Time to look around for a new one.\");","this.home = $player_start;","else","player:tell(\"You click your heels three times.\");","endif","this:moveto(this.home);","if (!valid(start))","elseif (start == this.location)","start:announce(player.name, \" \", $gender_utils:get_conj(\"learns\", player), \" that you can never go home...\");","else","try","start:announce(player.name, \" \", $gender_utils:get_conj(\"goes\", player), \" home.\");","except e (E_VERBNF)","\"start did not support announce\";","endtry","endif","if (this.location == this.home)","this.location:announce(player.name, \" \", $gender_utils:get_conj(\"comes\", player), \" home.\");","elseif (this.location == start)","player:tell(\"Either home doesn't want you, or you don't really want to go.\");","else","player:tell(\"Wait a minute!  This isn't your home...\");","if (valid(this.location))","this.location:announce(player.name, \" \", $gender_utils:get_conj(\"arrives\", player), \", looking quite bewildered.\");","endif","endif"]},{"name":"@sethome","owner":2,"perms":9,"preposition":-1,"code":["set_task_perms(this);","here = this.location;","if (!$object_utils:has_callable_verb(here, \"accept_for_abode\"))","player:notify(\"This is a pretty odd place.  You should make your home in an actual room.\");","elseif (here:accept_for_abode(this))","this.home = here;","player:notify(tostr(here.name, \" is your new home.\"));","else","player:notify(tostr(\"This place doesn't want to be your home.  Contact \", here.owner.name, \" to be added to the residents list of this place, or choose another place as your home.\"));","endif"]},{"name":"g*et take","owner":2,"perms":45,"preposition":-1,"code":["player:tell(\"This is not a pick-up joint!\");","this:tell(player.name, \" tried to pick you up.\");"]},{"name":"@move @teleport","owner":2,"perms":93,"preposition":1,"code":["\"'@move <object> to <place>' - Teleport an object. Example: '@move trash to #11' to move trash to the closet.\";","set_task_perms((caller == this) ? this | $no_one);","dobj = this:my_match_object(dobjstr);","iobj = this:my_match_object(iobjstr);","if ($command_utils:object_match_failed(dobj, dobjstr) || ((iobj != $nothing) && $command_utils:object_match_failed(iobj, iobjstr)))","return;","endif","if ((!$perm_utils:controls(this, dobj)) && (this != dobj))","player:tell(\"You may only @move your own things.\");","return;","endif","old_loc = dobj.location;","if (old_loc == iobj)","player:tell(dobj.name, \" is already \", valid(iobj) ? \"in \" + iobj.name | \"nowhere\", \".\");","return;","endif","dobj:moveto(iobj);","if (dobj.location == iobj)","player:tell(\"Moved.\");","if (is_player(dobj))","if (valid(old_loc))","old_loc:announce_all(dobj.name, \" disappears suddenly for parts unknown.\");","if (dobj != player)","dobj:tell(\"You have been moved by \", player.name, \".\");","endif","endif","if (valid(dobj.location))","dobj.location:announce(dobj.name, \" materializes out of thin air.\");","endif","endif","elseif (dobj.location == old_loc)","if ($object_utils:contains(dobj, iobj))","player:tell(iobj.name, \" is inside of \", dobj.name, \"!\");","else","player:tell($string_utils:pronoun_sub(\"Either %d doesn't want to go, or %i doesn't want to accept %[dpo].\"));","endif","elseif (dobj == player)","player:tell(\"You have been deflected from your original destination.\");","else","player:tell($string_utils:pronoun_sub(\"%D has been deflected from %[dpp] original destination.\"));","endif"]},{"name":"@eject @eject! @eject!!","owner":2,"perms":89,"preposition":5,"code":["set_task_perms(player);","if (iobjstr == \"here\")","iobj = player.location;","elseif (iobjstr == \"me\")","iobj = player;","elseif ($command_utils:object_match_failed(iobj, iobjstr))","return;","endif","if (!$perm_utils:controls(player, iobj))","player:notify(tostr(\"You are not the owner of \", iobj.name, \".\"));","return;","endif","if (dobjstr == \"me\")","dobj = player;","elseif (($failed_match == (dobj = $string_utils:literal_object(dobjstr))) && $command_utils:object_match_failed(dobj = iobj:match(dobjstr), dobjstr))","return;","endif","if (dobj.location != iobj)","player:notify(tostr(dobj.name, \"(\", dobj, \") is not in \", iobj.name, \"(\", iobj, \").\"));","return;","endif","if (dobj.wizard)","player:notify(tostr(\"Sorry, you can't \", verb, \" a wizard.\"));","dobj:tell(player.name, \" tried to \", verb, \" you.\");","return;","endif","iobj:((verb == \"@eject\") ? \"eject\" | \"eject_basic\")(dobj);","player:notify($object_utils:has_callable_verb(iobj, \"ejection_msg\") ? iobj:ejection_msg() | $room:ejection_msg());","if (verb != \"@eject!!\")","dobj:tell($object_utils:has_callable_verb(iobj, \"victim_ejection_msg\") ? iobj:victim_ejection_msg() | $room:victim_ejection_msg());","endif","iobj:announce_all_but({player, dobj}, $object_utils:has_callable_verb(iobj, \"oejection_msg\") ? iobj:oejection_msg() | $room:oejection_msg());"]},{"name":"where*is @where*is","owner":2,"perms":93,"preposition":-2,"code":["if (!args)","them = connected_players();","else","who = $command_utils:player_match_result($string_utils:match_player(args), args);","if (length(who) <= 1)","if (!who[1])","player:notify(\"Where is who?\");","endif","return;","elseif (who[1])","player:notify(\"\");","endif","them = listdelete(who, 1);","endif","lmax = rmax = 0;","for p in (them)","player:notify(tostr($string_utils:left($string_utils:nn(p), 25), \" \", $string_utils:nn(p.location)));","endfor"]},{"name":"@who","owner":2,"perms":93,"preposition":-2,"code":["if (caller != player)","return E_PERM;","endif","plyrs = args ? listdelete($command_utils:player_match_result($string_utils:match_player(args), args), 1) | connected_players();","if (!plyrs)","return;","elseif (length(plyrs) > 100)","player:tell(\"You have requested a listing of \", length(plyrs), \" players.  Please either specify individual players you are interested in, to reduce the number of players in any single request, or else use the `@users' command instead.  The lag thanks you.\");","return;","endif","$code_utils:show_who_listing(plyrs);"]},{"name":"@wizards","owner":2,"perms":29,"preposition":-1,"code":["\"@wizards [all]\";","if (caller != player)","return E_PERM;","endif","if (args)","$code_utils:show_who_listing($wiz_utils:all_wizards());","else","$code_utils:show_who_listing($wiz_utils:connected_wizards()) || player:notify(\"No wizards currently logged in.\");","endif"]},{"name":"?* help info*rmation @help","owner":2,"perms":93,"preposition":-2,"code":["set_task_perms(callers() ? caller_perms() | player);","\"...this code explicitly relies on being !d in several places...\";","if ((index(verb, \"?\") != 1) || (length(verb) <= 1))","what = $string_utils:trimr(argstr);","elseif (argstr)","what = tostr(verb[2..$], \" \", $string_utils:trimr(argstr));","else","what = verb[2..$];","endif","\"...find a db that claims to know about `what'...\";","dblist = $code_utils:help_db_list();","result = $code_utils:help_db_search(what, dblist);","if (!result)","\"... note: all of the last-resort stuff...\";","\"... is now located on $help:find_topics/get_topic...\";","$wiz_utils:missed_help(what, result);","player:notify(tostr(\"Sorry, but no help is available on `\", what, \"'.\"));","elseif (result[1] == $ambiguous_match)","$wiz_utils:missed_help(what, result);","player:notify_lines(tostr(\"Sorry, but the topic-name `\", what, \"' is ambiguous.  I don't know which of the following topics you mean:\"));","for x in ($help:columnize(@$help:sort_topics(result[2])))","player:notify(tostr(\"   \", x));","endfor","else","{help, topic} = result;","if (topic != what)","player:notify(tostr(\"Showing help on `\", topic, \"':\"));","player:notify(\"----\");","endif","dblist = dblist[1 + (help in dblist)..$];","if (1 == (text = help:get_topic(topic, dblist)))","\"...get_topic took matters into its own hands...\";","elseif (text)","\"...these can get long...\";","for line in ((typeof(text) == LIST) ? text | {text})","if (typeof(line) != STR)","player:notify(\"Odd results from help -- complain to a wizard.\");","else","player:notify(line);","endif","$command_utils:suspend_if_needed(0);","endfor","else","player:notify(tostr(\"Help DB \", help, \" thinks it knows about `\", what, \"' but something's messed up.\"));","player:notify(tostr(\"Tell \", help.owner.wizard ? \"\" | tostr(help.owner.name, \" (\", help.owner, \") or \"), \"a wizard.\"));","endif","endif"]},{"name":"display_option","owner":2,"perms":173,"preposition":-1,"code":["\":display_option(name) => returns the value of the specified @display option\";","if ((caller == this) || $perm_utils:controls(caller_perms(), this))","return $display_options:get(this.display_options, args[1]);","else","return E_PERM;","endif"]},{"name":"edit_option","owner":2,"perms":173,"preposition":-1,"code":["\":edit_option(name) => returns the value of the specified edit option\";","if ((caller == this) || ($object_utils:isa(caller, $generic_editor) || $perm_utils:controls(caller_perms(), this)))","return $edit_options:get(this.edit_options, args[1]);","else","return E_PERM;","endif"]},{"name":"set_mail_option set_edit_option set_display_option","owner":2,"perms":173,"preposition":-1,"code":["\":set_edit_option(oname,value)\";","\":set_display_option(oname,value)\";","\":set_mail_option(oname,value)\";","\"Changes the value of the named option.\";","\"Returns a string error if something goes wrong.\";","if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))","return tostr(E_PERM);","endif","\"...this is kludgy, but it saves me from writing the same verb 3 times.\";","\"...there's got to be a better way to do this...\";","verb[1..4] = \"\";","foo_options = verb + \"s\";","\"...\";","if (typeof(s = #0.(foo_options):set(this.(foo_options), @args)) == STR)","return s;","elseif (s == this.(foo_options))","return 0;","else","this.(foo_options) = s;","return 1;","endif"]},{"name":"@mailo*ptions @mail-o*ptions @edito*ptions @edit-o*ptions @displayo*ptions @display-o*ptions","owner":2,"perms":89,"preposition":-2,"code":["\"@<what>-option <option> [is] <value>   sets <option> to <value>\";","\"@<what>-option <option>=<value>        sets <option> to <value>\";","\"@<what>-option +<option>     sets <option>   (usually equiv. to <option>=1\";","\"@<what>-option -<option>     resets <option> (equiv. to <option>=0)\";","\"@<what>-option !<option>     resets <option> (equiv. to <option>=0)\";","\"@<what>-option <option>      displays value of <option>\";","set_task_perms(player);","what = {\"mail\", \"edit\", \"display\"}[index(\"med\", verb[2])];","options = what + \"_options\";","option_pkg = #0.(options);","set_option = (\"set_\" + what) + \"_option\";","if (!args)","player:notify_lines({(\"Current \" + what) + \" options:\", \"\", @option_pkg:show(this.(options), option_pkg.names)});","return;","elseif (typeof(presult = option_pkg:parse(args)) == STR)","player:notify(presult);","return;","else","if (length(presult) > 1)","if (typeof(sresult = this:(set_option)(@presult)) == STR)","player:notify(sresult);","return;","elseif (!sresult)","player:notify(\"No change.\");","return;","endif","endif","player:notify_lines(option_pkg:show(this.(options), presult[1]));","endif"]},{"name":"set_name","owner":2,"perms":173,"preposition":-1,"code":["\"set_name(newname) attempts to change this.name to newname\";","\"  => E_PERM   if you don't own this\";","\"  => E_INVARG if the name is already taken or prohibited for some reason\";","\"  => E_NACC   if the player database is not taking new names right now.\";","\"  => E_ARGS   if the name is too long (controlled by $login.max_player_name)\";","if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))","return E_PERM;","elseif (!is_player(this))","\"we don't worry about the names of player classes.\";","set_task_perms(caller_perms());","return pass(@args);","elseif ($player_db.frozen)","return E_NACC;","elseif (length(name = args[1]) > $login.max_player_name)","return E_ARGS;","elseif (!($player_db:available(name, this) in {this, 1}))","return E_INVARG;","else","old = this.name;","this.name = name;","if ((name != old) && (!(old in this.aliases)))","$player_db:delete(old);","endif","$player_db:insert(name, this);","return 1;","endif"]},{"name":"set_aliases","owner":2,"perms":173,"preposition":-1,"code":["\"set_aliases(alias_list)\";","\"For changing player aliases, we check to make sure that none of the aliases match existing player names/aliases.  Aliases containing spaces are not entered in the $player_db and so are not subject to this restriction ($string_utils:match_player will not match on them, however, so they only match if used in the immediate room, e.g., with match_object() or somesuch).\";","\"Also we make sure that the .name is included in the .alias list.  In any situation where .name and .aliases are both being changed, do the name change first.\";","\"  => 1        if successful, and aliases changed from previous setting.\";","\"  => 0        if resulting work didn't change aliases from previous.\";","\"  => E_PERM   if you don't own this\";","\"  => E_NACC   if the player database is not taking new aliases right now.\";","\"  => E_TYPE   if alias_list is not a list\";","\"  => E_INVARG if any element of alias_list is not a string\";","if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))","return E_PERM;","elseif (!is_player(this))","\"we don't worry about the names of player classes.\";","return pass(@args);","elseif ($player_db.frozen)","return E_NACC;","elseif (typeof(aliases = args[1]) != LIST)","return E_TYPE;","elseif ((length(aliases = setadd(aliases, this.name)) > ($object_utils:has_property($local, \"max_player_aliases\") ? $local.max_player_aliases | $maxint)) && (length(aliases) >= length(this.aliases)))","return E_INVARG;","else","for a in (aliases)","if (typeof(a) != STR)","return E_INVARG;","endif","if ((!(index(a, \" \") || index(a, \"\t\"))) && (!($player_db:available(a, this) in {this, 1})))","aliases = setremove(aliases, a);","endif","endfor","changed = 0;","old = this.aliases;","this.aliases = aliases;","for a in (old)","if (!(a in aliases))","$player_db:delete2(a, this);","changed = 1;","endif","endfor","for a in (aliases)","if (!(index(a, \" \") || index(a, \"\t\")))","$player_db:insert(a, this);","if (!(a in old))","changed = 1;","endif","endif","endfor","return changed;","endif"]},{"name":"@rename*#","owner":2,"perms":89,"preposition":1,"code":["if ((player != caller) || (player != this))","return;","endif","set_task_perms(player);","bynumber = verb == \"@rename#\";","spec = $code_utils:parse_verbref(dobjstr);","if (spec)","if (!player.programmer)","return player:notify(tostr(E_PERM));","endif","object = this:my_match_object(spec[1]);","if (!$command_utils:object_match_failed(object, spec[1]))","vname = spec[2];","if (bynumber)","vname = $code_utils:toint(vname);","if (vname == E_TYPE)","return player:notify(\"Verb number expected.\");","elseif ((vname < 1) || `vname > length(verbs(object)) ! E_PERM => 0')","return player:notify(\"Verb number out of range.\");","endif","endif","try","info = verb_info(object, vname);","try","result = set_verb_info(object, vname, listset(info, iobjstr, 3));","player:notify(\"Verb name changed.\");","except e (ANY)","player:notify(e[2]);","endtry","except (E_VERBNF)","player:notify(\"That object does not define that verb.\");","except e (ANY)","player:notify(e[2]);","endtry","endif","elseif (bynumber)","player:notify(\"@rename# can only be used with verbs.\");","elseif (pspec = $code_utils:parse_propref(dobjstr))","if (!player.programmer)","return player:notify(tostr(E_PERM));","endif","object = this:my_match_object(pspec[1]);","if (!$command_utils:object_match_failed(object, pspec[1]))","pname = pspec[2];","try","info = property_info(object, pname);","try","result = set_property_info(object, pname, {@info, iobjstr});","player:notify(\"Property name changed.\");","except e (ANY)","player:notify(e[2]);","endtry","except (E_PROPNF)","player:notify(\"That object does not define that property.\");","except e (ANY)","player:notify(e[2]);","endtry","endif","else","object = this:my_match_object(dobjstr);","if (!$command_utils:object_match_failed(object, dobjstr))","old_name = object.name;","old_aliases = object.aliases;","if (e = $building_utils:set_names(object, iobjstr))","if (strcmp(object.name, old_name) == 0)","name_message = tostr(\"Name of \", object, \" (\", old_name, \") is unchanged\");","else","name_message = tostr(\"Name of \", object, \" changed to \\\"\", object.name, \"\\\"\");","endif","aliases = $string_utils:from_value(object.aliases, 1);","if (object.aliases == old_aliases)","alias_message = tostr(\".  Aliases are unchanged (\", aliases, \").\");","else","alias_message = tostr(\", with aliases \", aliases, \".\");","endif","player:notify(name_message + alias_message);","elseif (e == E_INVARG)","player:notify(\"That particular name change not allowed (see help @rename).\");","if (object == player)","player:notify($player_db:why_bad_name(player, iobjstr));","endif","elseif (e == E_NACC)","player:notify(\"Oops.  You can't update that name right now; try again in a few minutes.\");","elseif (e == E_ARGS)","player:notify(tostr(\"Sorry, name too long.  Maximum number of characters in a name:  \", $login.max_player_name));","elseif (e == 0)","player:notify(\"Name and aliases remain unchanged.\");","else","player:notify(tostr(e));","endif","endif","endif"]},{"name":"@addalias*# @add-alias*#","owner":2,"perms":89,"preposition":1,"code":["\"Syntax: @addalias <alias>[,...,<alias>] to <object>\";","\"        @addalias <alias>[,...,<alias>] to <object>:<verb>\";","\"\";","\"The first form is used to add aliases to an object's list of aliases.  You can separate multiple aliases with commas.  The aliases will be checked against the object's current aliases and all aliases not already in the object's list of aliases will be added.\";","\"\";","\"Example:\";","\"Muchkin wants to add new aliases to Rover the Wonder Dog:\";","\"  @addalias Dog,Wonder Dog to Rover\";","\"Since Rover the Wonder Dog already has the alias \\\"Dog\\\" but does not have the alias \\\"Wonder Dog\\\", Munchkin sees:\";","\"  Rover the Wonder Dog(#4237) already has the alias Dog.\";","\"  Alias Wonder Dog added to Rover the Wonder Dog(#4237).\";","\"\";","\"If the object is a player, spaces will also be assumed to be separations between aliases and each alias will be checked against the Player Name Database to make sure no one else is using it. Any already used aliases will be identified.\";","\"\";","\"Example:\";","\"Munchkin wants to add his nicknames to his own list of aliases:\";","\"  @addalias Foobar Davey to me\";","\"@Addalias recognizes that Munchkin is trying to add an alias to a valid player and checks the aliases against the Player Name Database.  Unfortunately, DaveTheMan is already using the alias \\\"Davey\\\" so Munchkin sees:\";","\"  DaveTheMan(#5432) is already using the alias Davey\";","\"  Alias Foobar added to Munchkin(#1523).\";","\"\";","\"The second form of the @addalias command is for use by programmers, to add aliases to a verb they own.  All commas and spaces are assumed to be separations between aliases.\";","if (player != this)","return;","endif","set_task_perms(player);","bynumber = verb[$] == \"#\";","spec = $code_utils:parse_verbref(iobjstr);","if (spec)","if (!player.programmer)","return player:notify(tostr(E_PERM));","endif","object = player:my_match_object(spec[1]);","if (!$command_utils:object_match_failed(object, spec[1]))","vname = spec[2];","if (bynumber)","if ((vname = $code_utils:toint(vname)) == E_TYPE)","return player:notify(\"Verb number expected.\");","elseif ((vname < 1) || `vname > length(verbs(object)) ! E_PERM => 0')","return player:notify(\"Verb number out of range.\");","endif","endif","try","info = verb_info(object, vname);","old_aliases = $string_utils:explode(info[3]);","used = {};","for alias in (new_aliases = $list_utils:remove_duplicates($string_utils:explode(strsub(dobjstr, \",\", \" \"))))","if (alias in old_aliases)","used = {@used, alias};","new_aliases = setremove(new_aliases, alias);","endif","endfor","if (used)","player:notify(tostr(object.name, \"(\", object, \"):\", vname, \" already has the alias\", (length(used) > 1) ? \"es\" | \"\", \" \", $string_utils:english_list(used), \".\"));","endif","if (new_aliases)","info = listset(info, aliases = $string_utils:from_list({@old_aliases, @new_aliases}, \" \"), 3);","try","result = set_verb_info(object, vname, info);","player:notify(tostr(\"Alias\", (length(new_aliases) > 1) ? \"es\" | \"\", \" \", $string_utils:english_list(new_aliases), \" added to verb \", object.name, \"(\", object, \"):\", vname));","player:notify(tostr(\"Verbname is now \", object.name, \"(\", object, \"):\\\"\", aliases, \"\\\"\"));","except e (ANY)","player:notify(e[2]);","endtry","endif","except (E_VERBNF)","player:notify(\"That object does not define that verb.\");","except e (ANY)","player:notify(e[2]);","endtry","endif","elseif (bynumber)","player:notify(tostr(verb, \" can only be used with verbs.\"));","else","object = player:my_match_object(iobjstr);","if (!$command_utils:object_match_failed(object, iobjstr))","old_aliases = object.aliases;","used = {};","for alias in (new_aliases = $list_utils:remove_duplicates($list_utils:map_arg($string_utils, \"trim\", $string_utils:explode(is_player(object) ? strsub(dobjstr, \" \", \",\") | dobjstr, \",\"))))","if (alias in old_aliases)","used = {@used, alias};","new_aliases = setremove(new_aliases, alias);","elseif (is_player(object) && valid(someone = $player_db:find_exact(alias)))","player:notify(tostr(someone.name, \"(\", someone, \") is already using the alias \", alias, \".\"));","new_aliases = setremove(new_aliases, alias);","endif","endfor","if (used)","player:notify(tostr(object.name, \"(\", object, \") already has the alias\", (length(used) > 1) ? \"es\" | \"\", \" \", $string_utils:english_list(used), \".\"));","endif","if (new_aliases)","if ((e = object:set_aliases(aliases = {@old_aliases, @new_aliases})) && (object.aliases == aliases))","player:notify(tostr(\"Alias\", (length(new_aliases) > 1) ? \"es\" | \"\", \" \", $string_utils:english_list(new_aliases), \" added to \", object.name, \"(\", object, \").\"));","player:notify(tostr(\"Aliases for \", $string_utils:nn(object), \" are now \", $string_utils:from_value(aliases, 1)));","elseif (e)","player:notify(\"That particular name change not allowed (see help @rename or help @addalias).\");","elseif (e == E_INVARG)","if ($object_utils:has_property(#0, \"local\"))","if ($object_utils:has_property($local, \"max_player_aliases\"))","max = $local.max_player_aliases;","player:notify((\"You are not allowed more than \" + tostr(max)) + \" aliases.\");","endif","else","player:notify(\"You are not allowed any more aliases.\");","endif","elseif (e == E_NACC)","player:notify(\"Oops.  You can't update that object's aliases right now; try again in a few minutes.\");","elseif (e == 0)","player:notify(\"Aliases not changed as expected!\");","player:notify(tostr(\"Aliases for \", $string_utils:nn(object), \" are now \", $string_utils:from_value(object.aliases, 1)));","else","player:notify(tostr(e));","endif","endif","endif","endif"]},{"name":"@rmalias*# @rm-alias*#","owner":2,"perms":89,"preposition":5,"code":["\"Syntax: @rmalias <alias>[,...,<alias>] from <object>\";","\"        @rmalias <alias>[,...,<alias>] from <object>:<verb>\";","\"\";","\"The first form is used to remove aliases from an object.  If the object is a valid player, space and commas will be assumed to be separations between unwanted aliases.  Otherwise, only commas will be assumed to be separations.\";","\"[5/10/93 Nosredna: flushed above is_player feature\";","\"Note that @rmalias will not affect the object's name, only its aliases.\";","\"\";","\"The second form is for use by programmers, to remove aliases from a verb they own.  All spaces and commas are assumed to be separations between unwanted aliases.\";","if (player != this)","return;","endif","set_task_perms(player);","bynumber = verb[$] == \"#\";","spec = $code_utils:parse_verbref(iobjstr);","if (spec)","if (!player.programmer)","player:notify(tostr(E_PERM));","endif","object = player:my_match_object(spec[1]);","if (!$command_utils:object_match_failed(object, spec[1]))","vname = spec[2];","if (bynumber)","if ((vname = $code_utils:toint(vname)) == E_TYPE)","return player:notify(\"Verb number expected.\");","elseif ((vname < 1) || `vname > length(verbs(object)) ! E_PERM => 0')","return player:notify(\"Verb number out of range.\");","endif","endif","try","info = verb_info(object, vname);","old_aliases = $string_utils:explode(info[3]);","not_used = {};","for alias in (bad_aliases = $list_utils:remove_duplicates($string_utils:explode(strsub(dobjstr, \",\", \" \"))))","if (!(alias in old_aliases))","not_used = {@not_used, alias};","bad_aliases = setremove(bad_aliases, alias);","else","old_aliases = setremove(old_aliases, alias);","endif","endfor","if (not_used)","player:notify(tostr(object.name, \"(\", object, \"):\", vname, \" does not have the alias\", (length(not_used) > 1) ? \"es\" | \"\", \" \", $string_utils:english_list(not_used), \".\"));","endif","if (bad_aliases && old_aliases)","info = listset(info, aliases = $string_utils:from_list(old_aliases, \" \"), 3);","try","result = set_verb_info(object, vname, info);","player:notify(tostr(\"Alias\", (length(bad_aliases) > 1) ? \"es\" | \"\", \" \", $string_utils:english_list(bad_aliases), \" removed from verb \", object.name, \"(\", object, \"):\", vname));","player:notify(tostr(\"Verbname is now \", object.name, \"(\", object, \"):\\\"\", aliases, \"\\\"\"));","except e (ANY)","player:notify(e[2]);","endtry","elseif (!old_aliases)","player:notify(\"You have to leave a verb with at least one alias.\");","endif","except (E_VERBNF)","player:notify(\"That object does not define that verb.\");","except e (ANY)","player:notify(e[2]);","endtry","endif","elseif (bynumber)","player:notify(tostr(verb, \" can only be used with verbs.\"));","else","object = player:my_match_object(iobjstr);","if (!$command_utils:object_match_failed(object, iobjstr))","old_aliases = object.aliases;","not_used = {};","for alias in (bad_aliases = $list_utils:remove_duplicates($list_utils:map_arg($string_utils, \"trim\", $string_utils:explode(dobjstr, \",\"))))","\"removed is_player(object) ? strsub(dobjstr, \\\" \\\", \\\",\\\") | --Nosredna\";","if (!(alias in old_aliases))","not_used = {@not_used, alias};","bad_aliases = setremove(bad_aliases, alias);","else","old_aliases = setremove(old_aliases, alias);","endif","endfor","if (not_used)","player:notify(tostr(object.name, \"(\", object, \") does not have the alias\", (length(not_used) > 1) ? \"es\" | \"\", \" \", $string_utils:english_list(not_used), \".\"));","endif","if (bad_aliases)","if (e = object:set_aliases(old_aliases))","player:notify(tostr(\"Alias\", (length(bad_aliases) > 1) ? \"es\" | \"\", \" \", $string_utils:english_list(bad_aliases), \" removed from \", object.name, \"(\", object, \").\"));","player:notify(tostr(\"Aliases for \", object.name, \"(\", object, \") are now \", $string_utils:from_value(old_aliases, 1)));","elseif (e == E_INVARG)","player:notify(\"That particular name change not allowed (see help @rename or help @rmalias).\");","elseif (e == E_NACC)","player:notify(\"Oops.  You can't update that object's aliases right now; try again in a few minutes.\");","elseif (e == 0)","player:notify(\"Aliases not changed as expected!\");","player:notify(tostr(\"Aliases for \", $string_utils:nn(object), \" are \", $string_utils:from_value(object.aliases, 1)));","else","player:notify(tostr(e));","endif","endif","endif","endif"]},{"name":"@desc*ribe","owner":2,"perms":89,"preposition":13,"code":["set_task_perms(player);","dobj = player:my_match_object(dobjstr);","if ($command_utils:object_match_failed(dobj, dobjstr))","\"...lose...\";","elseif (e = dobj:set_description(iobjstr))","player:notify(\"Description set.\");","else","player:notify(tostr(e));","endif"]},{"name":"@mess*ages","owner":2,"perms":25,"preposition":-1,"code":["set_task_perms(player);","if (dobjstr == \"\")","player:notify(tostr(\"Usage:  \", verb, \" <object>\"));","return;","endif","dobj = player:my_match_object(dobjstr);","if ($command_utils:object_match_failed(dobj, dobjstr))","return;","endif","found_one = 0;","props = $object_utils:all_properties(dobj);","if (typeof(props) == ERR)","player:notify(\"You can't read the messages on that.\");","return;","endif","for pname in (props)","len = length(pname);","if ((len > 4) && (pname[len - 3..len] == \"_msg\"))","found_one = 1;","msg = `dobj.(pname) ! ANY';","if (msg == E_PERM)","value = \"isn't readable by you.\";","elseif (!msg)","value = \"isn't set.\";","elseif (typeof(msg) == LIST)","value = \"is a list.\";","elseif (typeof(msg) != STR)","value = \"is corrupted! **\";","else","value = \"is \" + $string_utils:print(msg);","endif","player:notify(tostr(\"@\", pname[1..len - 4], \" \", dobjstr, \" \", value));","endif","endfor","if (!found_one)","player:notify(\"That object doesn't have any messages to set.\");","endif"]},{"name":"@notedit","owner":36,"perms":25,"preposition":-1,"code":["$note_editor:invoke(dobjstr, verb);"]},{"name":"@last-c*onnection","owner":2,"perms":29,"preposition":-1,"code":["\"@last-c           reports when and from where you last connected.\";","\"@last-c all       adds the 10 most recent places you connected from.\";","\"@last-c confunc   is like `@last-c' but is silent on first login.\";","opts = {\"all\", \"confunc\"};","i = 0;","if (caller != this)","return E_PERM;","elseif (args && ((length(args) > 1) || (!(i = $string_utils:find_prefix(args[1], opts)))))","this:notify(tostr(\"Usage:  \", verb, \" [all]\"));","return;","endif","opt_all = i && (opts[i] == \"all\");","opt_confunc = i && (opts[i] == \"confunc\");","if (!(prev = this.previous_connection))","this:notify(\"Something was broken when you logged in; tell a wizard.\");","elseif (prev[1] == 0)","opt_confunc || this:notify(\"Your previous connection was before we started keeping track.\");","elseif (prev[1] > time())","this:notify(\"This is your first time connected.\");","else","this:notify(tostr(\"Last connected \", this:ctime(prev[1]), \" from \", prev[2]));","if (opt_all)","this:notify(\"Previous connections have been from the following sites:\");","for l in (this.all_connect_places)","this:notify(\"   \" + l);","endfor","endif","endif"]},{"name":"set_gender","owner":2,"perms":173,"preposition":-1,"code":["\"set_gender(newgender) attempts to change this.gender to newgender\";","\"  => E_PERM   if you don't own this or aren't its parent\";","\"  => Other return values as from $gender_utils:set.\";","if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))","return E_PERM;","else","result = $gender_utils:set(this, args[1]);","this.gender = (typeof(result) == STR) ? result | args[1];","return result;","endif"]},{"name":"@gender","owner":2,"perms":25,"preposition":-1,"code":["set_task_perms(valid(caller_perms()) ? caller_perms() | player);","if (!args)","player:notify(tostr(\"Your gender is currently \", this.gender, \".\"));","player:notify($string_utils:pronoun_sub(\"Your pronouns:  %s,%o,%p,%q,%r,%S,%O,%P,%Q,%R\"));","player:notify(tostr(\"Available genders:  \", $string_utils:english_list($gender_utils.genders, \"\", \" or \")));","else","result = this:set_gender(args[1]);","quote = (result == E_NONE) ? \"\\\"\" | \"\";","player:notify(tostr(\"Gender set to \", quote, this.gender, quote, \".\"));","if (typeof(result) != ERR)","player:notify($string_utils:pronoun_sub(\"Your pronouns:  %s,%o,%p,%q,%r,%S,%O,%P,%Q,%R\"));","elseif (result != E_NONE)","player:notify(tostr(\"Couldn't set pronouns:  \", result));","else","player:notify(\"Pronouns unchanged.\");","endif","endif"]},{"name":"set_brief","owner":2,"perms":173,"preposition":-1,"code":["\"set_brief(value)\";","\"set_brief(value, anything)\";","\"If <anything> is given, add value to the current value; otherwise, just set the value.\";","if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))","return E_PERM;","else","if (length(args) == 1)","this.brief = args[1];","else","this.brief = this.brief + args[1];","endif","endif"]},{"name":"@mode","owner":2,"perms":89,"preposition":-2,"code":["\"@mode <mode>\";","\"Current modes are brief and verbose.\";","\"General verb for setting player `modes'.\";","\"Modes are coded right here in the verb.\";","if (caller != this)","player:tell(\"You can't set someone else's modes.\");","return E_PERM;","endif","modes = {\"brief\", \"verbose\"};","mode = `modes[$string_utils:find_prefix(dobjstr, modes)] ! E_TYPE, E_RANGE => 0';","if (!mode)","player:tell(\"Unknown mode \\\"\", dobjstr, \"\\\".  Known modes:\");","for mode in (modes)","player:tell(\"  \", mode);","endfor","return 0;","elseif (mode == \"brief\")","this:set_brief(1);","elseif (mode == \"verbose\")","this:set_brief(0);","endif","player:tell($string_utils:capitalize(mode), \" mode set.\");","return 1;"]},{"name":"@exam*ine","owner":2,"perms":29,"preposition":-1,"code":["\"This verb should probably go away once 'examine' is in place.\";","if (dobjstr == \"\")","player:notify(tostr(\"Usage:  \", verb, \" <object>\"));","return;","endif","what = $string_utils:match_object(dobjstr, player.location);","if ($command_utils:object_match_failed(what, dobjstr))","return;","endif","player:notify(tostr(what.name, \" (\", what, \") is owned by \", valid(what.owner) ? what.owner.name | \"a recycled player\", \" (\", what.owner, \").\"));","player:notify(tostr(\"Aliases:  \", $string_utils:english_list(what.aliases)));","desc = what:description();","if (desc)","player:notify_lines(desc);","else","player:notify(\"(No description set.)\");","endif","if ($perm_utils:controls(player, what))","player:notify(tostr(\"Key:  \", $lock_utils:unparse_key(what.key)));","endif","contents = what.contents;","if (contents)","player:notify(\"Contents:\");","for item in (contents)","player:notify(tostr(\"  \", item.name, \" (\", item, \")\"));","endfor","endif","\"Use dobjstr, not shortest alias.\";","name = dobjstr;","\"name = what.name;\";","\"if (typeof(what.aliases) == LIST && what.aliases != {})\";","\"for alias in (what.aliases)\";","\"if (length(alias) <= length(name))\";","\"name = alias;\";","\"endif\";","\"endfor\";","\"endif\";","vrbs = {};","commands_ok = what in {player, player.location};","dull_classes = {$root_class, $room, $player, $prog};","what = what;","printed_working_msg = 0;","while (what != $nothing)","if ($command_utils:running_out_of_time())","if (!printed_working_msg)","player:notify(\"Working on list of obvious verbs...\");","printed_working_msg = 1;","endif","suspend(0);","endif","if (!(what in dull_classes))","for i in [1..length(verbs(what))]","if ($command_utils:running_out_of_time())","if (!printed_working_msg)","player:notify(\"Working on list of obvious verbs...\");","printed_working_msg = 1;","endif","suspend(0);","endif","info = verb_info(what, i);","syntax = verb_args(what, i);","if ((index(info[2], \"r\") && ((syntax[2..3] != {\"none\", \"this\"}) && (commands_ok || (\"this\" in syntax)))) && verb_code(what, i))","{dobj, prep, iobj} = syntax;","if (syntax == {\"any\", \"any\", \"any\"})","prep = \"none\";","endif","if (prep != \"none\")","for x in ($string_utils:explode(prep, \"/\"))","if (length(x) <= length(prep))","prep = x;","endif","endfor","endif","\"This is the correct way to handle verbs ending in *\";","vname = info[3];","while (j = index(vname, \"* \"))","vname = tostr(vname[1..j - 1], \"<anything>\", vname[j + 1..$]);","endwhile","if (vname[$] == \"*\")","vname = vname[1..$ - 1] + \"<anything>\";","endif","vname = strsub(vname, \" \", \"/\");","rest = \"\";","if (prep != \"none\")","rest = \" \" + ((prep == \"any\") ? \"<anything>\" | prep);","if (iobj != \"none\")","rest = tostr(rest, \" \", (iobj == \"this\") ? name | \"<anything>\");","endif","endif","if (dobj != \"none\")","rest = tostr(\" \", (dobj == \"this\") ? name | \"<anything>\", rest);","endif","vrbs = setadd(vrbs, (\"  \" + vname) + rest);","endif","endfor","endif","what = parent(what);","endwhile","if (vrbs)","player:notify(\"Obvious Verbs:\");","player:notify_lines(vrbs);","printed_working_msg && player:notify(\"(End of list.)\");","elseif (printed_working_msg)","player:notify(\"No obvious verbs found.\");","endif"]},{"name":"exam*ine","owner":2,"perms":25,"preposition":-1,"code":["set_task_perms(player);","if (!dobjstr)","player:notify(tostr(\"Usage:  \", verb, \" <object>\"));","return E_INVARG;","endif","what = player.location:match_object(dobjstr);","if ($command_utils:object_match_failed(what, dobjstr))","return;","endif","what:do_examine(player);"]},{"name":"add_feature","owner":36,"perms":173,"preposition":-1,"code":["\"Add a feature to this player's features list.  Caller must be this or have suitable permissions (this or wizardly).\";","\"If this is a nonprogrammer, then ask feature if it is feature_ok (that is, if it has a verb :feature_ok which returns a true value, or a property .feature_ok which is true).\";","\"After adding feature, call feature:feature_add(this).\";","\"Returns true if successful, E_INVARG if not a valid object, and E_PERM if !feature_ok or if caller doesn't have permission.\";","if ((caller == this) || $perm_utils:controls(caller_perms(), this))","feature = args[1];","if ((typeof(feature) != OBJ) || (!valid(feature)))","return E_INVARG;","\"Not a valid object.\";","endif","if ($code_utils:verb_or_property(feature, \"feature_ok\", this))","\"The object is willing to be a feature.\";","if (typeof(this.features) == LIST)","\"If list, we can simply setadd the feature.\";","this.features = setadd(this.features, feature);","else","\"If not, we erase the old value and create a new list.\";","this.features = {feature};","endif","\"Tell the feature it's just been added.\";","try","feature:feature_add(this);","except (ANY)","\"just ignore errors.\";","endtry","return 1;","\"We're done.\";","else","return E_PERM;","\"Feature isn't feature_ok.\";","endif","else","return E_PERM;","\"Caller doesn't have permission.\";","endif"]},{"name":"remove_feature","owner":36,"perms":173,"preposition":-1,"code":["\"Remove a feature from this player's features list.  Caller must be this, or have permissions of this, a wizard, or feature.owner.\";","\"Returns true if successful, E_PERM if caller didn't have permission.\";","feature = args[1];","if (((caller == this) || $perm_utils:controls(caller_perms(), this)) || (caller_perms() == feature.owner))","if (typeof(this.features) == LIST)","\"If this is a list, we can just setremove...\";","this.features = setremove(this.features, feature);","\"Otherwise, we leave it alone.\";","endif","\"Let the feature know it's been removed.\";","try","feature:feature_remove(this);","except (ANY)","\"just ignore errors.\";","endtry","return 1;","\"We're done.\";","else","return E_PERM;","\"Caller didn't have permission.\";","endif"]},{"name":"@add-feature @addfeature","owner":2,"perms":25,"preposition":-1,"code":["\"Usage:\";","\"  @add-feature\";","\"  @add-feature <feature object>\";","\"Modified 10 Oct 94, by Michele, to check the warehouse and match.\";","\"Lists all features or adds an object to your features list.\";","set_task_perms(player);","if (dobjstr)","if (dobj == $failed_match)","dobj = $feature.warehouse:match_object(dobjstr);","endif","if (!$command_utils:object_match_failed(dobj, dobjstr))","if (dobj in player.features)","player:tell(dobjstr, \" is already one of your features.\");","elseif (player:add_feature(dobj))","player:tell(dobj, \" (\", dobj.name, \") added as a feature.\");","else","player:tell(\"You can't seem to add \", dobj, \" (\", dobj.name, \") to your features list.\");","endif","endif","else","player:tell(\"Usage:  @add-feature <object>\");","if (length($feature.warehouse.contents) < 20)","player:tell(\"Available features include:\");","player:tell(\"--------------------------\");","fe = {};","for c in ($feature.warehouse.contents)","fe = {(c in player.features) ? c:title() + \" (*)\" | c:title()};","player:tell(\"  \" + $string_utils:english_list(fe));","endfor","player:tell(\"--------------------------\");","player:tell(\"A * after the feature name means that you already have that feature.\");","endif","endif"]},{"name":"@remove-feature @rmfeature","owner":2,"perms":25,"preposition":-1,"code":["\"Usage:  @remove-feature <feature object>\";","\"Remove an object from your .features list.\";","set_task_perms(player);","if (dobjstr)","features = player.features;","if (!valid(dobj))","dobj = $string_utils:match(dobjstr, features, \"name\", features, \"aliases\");","endif","if (!$command_utils:object_match_failed(dobj, dobjstr))","if (dobj in features)","player:remove_feature(dobj);","player:tell(dobj, \" (\", dobj.name, \") removed from your features list.\");","else","player:tell(dobjstr, \" is not one of your features.\");","endif","endif","else","player:tell(\"Usage:  @remove-feature <object>\");","endif"]},{"name":"@features","owner":2,"perms":93,"preposition":11,"code":["\"Usage:  @features [<name>] for <player>\";","\"List the feature objects matching <name> used by <player>.\";","if (!iobjstr)","player:tell(\"Usage: @features [<name>] for <player>\");","return;","elseif ($command_utils:player_match_failed(whose = $string_utils:match_player(iobjstr), iobjstr))","return;","endif","features = {};","for feature in (whose.features)","if (!valid(feature))","whose:remove_feature(feature);","elseif ((!dobjstr) || ((dobjstr in feature.aliases) || ((pref = $string_utils:find_prefix(dobjstr, feature.aliases)) || (pref == $ambiguous_match))))","features = listappend(features, feature);","endif","endfor","if (features)","len = max(length(\"Feature\"), length(tostr(max_object()))) + 1;","player:tell($string_utils:left(\"Feature\", len), \"Name\");","player:tell($string_utils:left(\"-------\", len), \"----\");","for feature in (features)","player:tell($string_utils:left(tostr(feature), len), feature.name);","endfor","player:tell($string_utils:left(\"-------\", len), \"----\");","cstr = ((tostr(length(features)) + \" feature\") + ((length(features) > 1) ? \"s\" | \"\")) + \" found\";","if (whose != this)","cstr = ((((cstr + \" on \") + whose.name) + \" (\") + tostr(whose)) + \")\";","endif","if (dobjstr)","cstr = ((cstr + \" matching \\\"\") + dobjstr) + \"\\\"\";","endif","cstr = cstr + \".\";","player:tell(cstr);","elseif (dobjstr)","player:tell(\"No features found on \", whose.name, \" (\", whose, \") matching \\\"\", dobjstr, \"\\\".\");","else","player:tell(\"No features found on \", whose.name, \" (\", whose, \").\");","endif"]},{"name":"@features","owner":2,"perms":25,"preposition":-1,"code":["\"Usage:  @features [<name>]\";","\"List the feature objects matching <name> used by player.\";","iobjstr = player.name;","iobj = player;","this:(\"@features\")();"]},{"name":"@memory","owner":36,"perms":9,"preposition":-1,"code":["stats = memory_usage();","if (!stats)","player:notify(\"Sorry, but no memory-usage statistics are available for this server.\");","return;","endif","su = $string_utils;","player:notify(\"Block Size   # In Use    # Free    Bytes In Use   Bytes Free\");","player:notify(\"----------   --------   --------   ------------   ----------\");","nused = nfree = bytesused = bytesfree = 0;","kilo = 1024;","meg = kilo * kilo;","for x in (stats)","if (x[2..3] != {0, 0})","bsize = x[1];","if ((bsize % meg) == 0)","bsize = tostr(bsize / meg, \" M\");","elseif ((bsize % kilo) == 0)","bsize = tostr(bsize / kilo, \" K\");","endif","bused = x[1] * x[2];","bfree = x[1] * x[3];","player:notify(tostr(su:left(bsize, 10), \"   \", su:right(su:group_number(x[2]), 8), \"   \", su:right(su:group_number(x[3]), 8), \"   \", su:right(su:group_number(bused), 12), \"   \", su:right(su:group_number(bfree), 10)));","nused = nused + x[2];","nfree = nfree + x[3];","bytesused = bytesused + bused;","bytesfree = bytesfree + bfree;","endif","endfor","player:notify(\"\");","player:notify(tostr(su:left(\"Totals:\", 10), \"   \", su:right(su:group_number(nused), 8), \"   \", su:right(su:group_number(nfree), 8), \"   \", su:right(su:group_number(bytesused), 12), \"   \", su:right(su:group_number(bytesfree), 10)));","player:notify(\"\");","player:notify(tostr(\"Total Memory Size: \", su:group_number(bytesused + bytesfree), \" bytes.\"));"]},{"name":"@version","owner":36,"perms":9,"preposition":-1,"code":["if ($object_utils:has_property($local, \"server_hardware\"))","hw = (\" on \" + $local.server_hardware) + \".\";","else","hw = \".\";","endif","player:notify(tostr(\"The MOO is currently running version \", server_version(), \" of the LambdaMOO server code\", hw));","try","{MOOname, sversion, coretime} = $core_history[1];","player:notify(tostr(\"The database was derived from a core created on \", $time_utils:time_sub(\"$n $t, $Y\", coretime), \" at \", MOOname, \" for version \", sversion, \" of the server.\"));","except (E_RANGE)","player:notify(\"The database was created from scratch.\");","except (ANY)","player:notify(\"No information is available on the database version.\");","endtry"]},{"name":"@uptime","owner":36,"perms":9,"preposition":-1,"code":["player:notify(tostr(\"The server has been up for \", $time_utils:english_time(time() - $last_restart_time), \".\"));"]},{"name":"@quit","owner":2,"perms":9,"preposition":-1,"code":["boot_player(player);","\"-- argh, let the player decide; #3:disfunc() takes care of this --Rog\";","\"player:moveto(player.home)\";"]},{"name":"examine_commands_ok","owner":2,"perms":173,"preposition":-1,"code":["return this == args[1];"]},{"name":"is_listening","owner":2,"perms":173,"preposition":-1,"code":["\"return true if player is active.\";","return typeof(`idle_seconds(this) ! ANY') != ERR;"]},{"name":"moveto","owner":2,"perms":173,"preposition":-1,"code":["if (args[1] == #-1)","return E_INVARG;","this:notify(\"You are now in #-1, The Void.  Type `home' to get back.\");","endif","set_task_perms(caller_perms());","pass(@args);"]},{"name":"announce*_all_but","owner":2,"perms":173,"preposition":-1,"code":["return this.location:(verb)(@args);","\"temporarily let player:announce be noisy to player\";","if (verb == \"announce_all_but\")","if (this in args[1])","return;","endif","args = args[2..$];","endif","this:tell(\"(from within you) \", @args);"]},{"name":"linewrap","owner":36,"perms":173,"preposition":-1,"code":["\"Return a true value if this needs linewrapping.\";","\"default is true if .linelen > 0\";","return this.linelen > 0;"]},{"name":"@set-note-string @set-note-text","owner":2,"perms":25,"preposition":-1,"code":["\"Usage:  @set-note-{string | text} {#xx | #xx.pname}\";","\"        ...lines of text...\";","\"        .\";","\"\";","\"For use by clients' local editors, to save new text for a note or object property.  See $note_editor:local_editing_info() for details.\";","set_task_perms(player);","text = $command_utils:read_lines_escape((active = player in $note_editor.active) ? {} | {\"@edit\"}, {tostr(\"Changing \", argstr, \".\"), @active ? {} | {\"Type `@edit' to take this into the note editor.\"}});","if (text && (text[1] == \"@edit\"))","$note_editor:invoke(argstr, verb);","who = $note_editor:loaded(player);","$note_editor.texts[who] = text[2];","return;","endif","text = text[2];","if ((verb == \"@set-note-string\") && (length(text) <= 1))","text = text ? text[1] | \"\";","endif","if (spec = $code_utils:parse_propref(argstr))","o = player:my_match_object(spec[1]);","p = spec[2];","if ($object_utils:has_verb(o, vb = \"set_\" + p) && (typeof(e = o:(vb)(text)) != ERR))","player:tell(\"Set \", p, \" property of \", o.name, \" (\", o, \") via :\", vb, \".\");","elseif (text != (e = `o.(p) = text ! ANY'))","player:tell(\"Error:  \", e);","else","player:tell(\"Set \", p, \" property of \", o.name, \" (\", o, \").\");","endif","elseif (typeof(note = $code_utils:toobj(argstr)) == OBJ)","e = note:set_text(text);","if (typeof(e) == ERR)","player:tell(\"Error:  \", e);","else","player:tell(\"Set text of \", note.name, \" (\", note, \").\");","endif","else","player:tell(\"Error:  Malformed argument to \", verb, \": \", argstr);","endif"]},{"name":"verb_sub","owner":2,"perms":173,"preposition":-1,"code":["text = args[1];","if (a = `$list_utils:assoc(text, this.verb_subs) ! ANY')","return a[2];","else","return $gender_utils:get_conj(text, this);","endif"]},{"name":"ownership_quota","owner":2,"perms":173,"preposition":-1,"code":["if ($perm_utils:controls(caller_perms(), this))","return this.(verb);","else","return E_PERM;","endif"]},{"name":"tell_lines","owner":2,"perms":173,"preposition":-1,"code":["lines = args[1];","if (typeof(lines) != LIST)","lines = {lines};","endif","if (this.gaglist || this.paranoid)","\"Check the above first, default case, to save ticks.  Paranoid gaggers are cost an extra three or so ticks by this, probably a net savings.\";","if (this:gag_p())","return;","endif","if (this.paranoid == 2)","z = this:whodunnit({@callers(1), {player, \"\", player}}, {this, $no_one}, {})[3];","lines = {(((\"[start text by \" + z.name) + \" (\") + tostr(z)) + \")]\", @lines, (((\"[end text by \" + z.name) + \" (\") + tostr(z)) + \")]\"};","elseif (this.paranoid == 1)","$paranoid_db:add_data(this, {{@callers(1), {player, \"<cmd-line>\", player}}, lines});","endif","endif","\"don't gather stats for now: $list_utils:check_nonstring_tell_lines(lines)\";","this:notify_lines(lines);"]},{"name":"@lastlog","owner":2,"perms":29,"preposition":-1,"code":["\"Copied from generic room (#3):@lastlog by Haakon (#2) Wed Dec 30 13:30:02 1992 PST\";","if (dobjstr != \"\")","dobj = $string_utils:match_player(dobjstr);","if (!valid(dobj))","player:tell(\"Who?\");","return;","endif","folks = {dobj};","else","folks = players();","endif","day = week = month = ever = never = {};","a_day = (24 * 60) * 60;","a_week = 7 * a_day;","a_month = 30 * a_day;","now = time();","for x in (folks)","when = x.last_connect_time;","how_long = now - when;","if ((when == 0) || (when > now))","never = {@never, x};","elseif (how_long < a_day)","day = {@day, x};","elseif (how_long < a_week)","week = {@week, x};","elseif (how_long < a_month)","month = {@month, x};","else","ever = {@ever, x};","endif","endfor","for entry in ({{day, \"the last day\"}, {week, \"the last week\"}, {month, \"the last 30 days\"}, {ever, \"recorded history\"}})","if (entry[1])","player:tell(\"Players who have connected within \", entry[2], \":\");","for x in (entry[1])","player:tell(\"  \", x.name, \" last connected \", ctime(x.last_connect_time), \".\");","endfor","endif","endfor","if (never)","player:tell(\"Players who have never connected:\");","player:tell(\"  \", $string_utils:english_list($list_utils:map_prop(never, \"name\")));","endif"]},{"name":"set_linelength","owner":2,"perms":173,"preposition":-1,"code":["\"Set linelength.  Linelength must be an integer >= 10.\";","\"If wrap is currently off (i.e. linelength is less than 0), maintains sign.  That is, this function *takes* an absolute value, and coerces the sign to be appropriate.\";","\"If you want to override the dwimming of wrap, pass in a second argument.\";","\"returns E_PERM if not allowed, E_INVARG if linelength is too low, otherwise the linelength.\";","if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))","return E_PERM;","elseif (abs(len = args[1]) < 10)","return E_INVARG;","elseif (length(args) > 1)","this.linelen = len;","else","\"DWIM here.\";","this.linelen = (this.linelen > 0) ? len | (-len);","return len;","endif"]},{"name":"set_pagelength","owner":2,"perms":173,"preposition":-1,"code":["\"Set pagelength. Must be an integer >= 5, or 0 to turn pagelength off.\";","\"Returns E_PERM if you shouldn't be doing this, E_INVARG if it's too low, otherwise, what it got set to.\";","if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))","return E_PERM;","elseif (((len = args[1]) < 5) && (len != 0))","return E_INVARG;","else","if ((this.pagelen = len) == 0)","if (lb = this.linebuffer)","\"queued text remains\";","this:notify_lines(lb);","clear_property(this, \"linebuffer\");","endif","endif","return len;","endif"]},{"name":"set_home","owner":2,"perms":173,"preposition":-1,"code":["\"set_home(newhome) attempts to change this.home to newhome\";","\"E_TYPE   if newhome doesn't have a callable :accept_for_abode verb.\";","\"E_INVARG if newhome won't accept you as a resident.\";","\"E_PERM   if you don't own this and aren't its parent.\";","\"1        if it works.\";","newhome = args[1];","if ((caller == this) || $perm_utils:controls(caller_perms(), this))","if ($object_utils:has_callable_verb(newhome, \"accept_for_abode\"))","if (newhome:accept_for_abode(this))","return (typeof(e = `this.home = args[1] ! ANY') != ERR) || e;","else","return E_INVARG;","endif","else","return E_TYPE;","endif","else","return E_PERM;","endif"]},{"name":"@registerme","owner":2,"perms":89,"preposition":-2,"code":["\"@registerme as <email-address> -- enter a new email address for player\";","\"   will change the database entry, assign a new password, and mail the new password to the player at the given email address.\";","if (player != this)","return player:notify(tostr(E_PERM));","endif","who = this;","if ($object_utils:isa(this, $guest))","who:notify(\"Sorry, guests should use the '@request' command to request a character.\");","return;","endif","connection = $string_utils:connection_hostname(connection_name(who));","if (!argstr)","if ($wiz_utils:get_email_address(who))","player:tell(\"You are currently registered as:  \", $wiz_utils:get_email_address(who));","else","player:tell(\"You are not currently registered.\");","endif","player:tell(\"Use @registerme as <address> to change this.\");","return;","elseif (((prepstr != \"as\") || (!iobjstr)) || dobjstr)","player:tell(\"Usage: @registerme as <address>\");","return;","endif","email = iobjstr;","if (email == $wiz_utils:get_email_address(this))","who:notify(\"That is your current address.  Not changed.\");","return;","elseif (reason = $wiz_utils:check_reregistration(this, email, connection))","if (reason[1] == \"-\")","if (!$command_utils:yes_or_no(reason[2..$] + \". Automatic registration not allowed. Ask to be registered at this address anyway?\"))","who:notify(\"Okay.\");","return;","endif","else","return who:notify(tostr(reason, \" Please try again.\"));","endif","endif","if ($network.active && (!reason))","if (!$command_utils:yes_or_no(tostr(\"If you continue, your password will be changed, the new password mailed to `\", email, \"'. Do you want to continue?\")))","return who:notify(\"Registration terminated.\");","endif","password = $wiz_utils:random_password(5);","old = $wiz_utils:get_email_address(who) || \"[ unregistered ]\";","who:notify(tostr(\"Registering you, and changing your password and mailing new one to \", email, \".\"));","result = $network:sendmail(email, tostr(\"Your \", $network.MOO_Name, \" character, \", who.name), \"Reply-to: \" + $login.registration_address, @$generic_editor:fill_string(tostr(\"Your \", $network.MOO_name, \" character, \", $string_utils:nn(who), \" has been registered to this email address (\", email, \"), and a new password assigned.  The new password is `\", password, \"'. Please keep your password secure. You can change your password with the @password command.\"), 75));","if (result != 0)","who:notify(tostr(\"Mail sending did not work: \", reason, \". Reregistration terminated.\"));","return;","endif","who:notify(tostr(\"Mail with your new password forwarded. If you do not get it, send regular email to \", $login.registration_address, \" with your character name.\"));","$mail_agent:send_message($new_player_log, $new_player_log, \"reg \" + $string_utils:nn(this), {email, tostr(\"formerly \", old)});","$registration_db:add(this, email, \"Reregistered at \" + ctime());","$wiz_utils:set_email_address(this, email);","who.password = crypt(password);","who.last_password_time = time();","else","who:notify(\"No automatic reregistration: your request will be forwarded.\");","if (typeof(curreg = $registration_db:find(email)) == LIST)","additional_info = {\"Current registration information for this email address:\", @$registration_db:describe_registration(curreg)};","else","additional_info = {};","endif","$mail_agent:send_message(this, $registration_db.registrar, \"Registration request\", {(((\"Reregistration request from \" + $string_utils:nn(who)) + \" connected via \") + connection) + \":\", \"\", ((\"@register \" + who.name) + \" \") + email, (\"@new-password \" + who.name) + \" is \", \"\", \"Reason this request was forwarded:\", reason, @additional_info});","endif"]},{"name":"ctime","owner":2,"perms":173,"preposition":-1,"code":["\":ctime([INT time]) => STR as the function.\";","\"May be hacked by players and player-classes to reflect differences in time-zone.\";","return ctime(@args);"]},{"name":"@age","owner":36,"perms":25,"preposition":-1,"code":["if ((dobjstr == \"\") || (dobj == player))","dobj = player;","else","dobj = $string_utils:match_player(dobjstr);","if (!valid(dobj))","$command_utils:player_match_failed(dobj, dobjstr);","return;","endif","endif","time = dobj.first_connect_time;","if (time == $maxint)","duration = time() - dobj.last_disconnect_time;","if (duration < 86400)","notice = $string_utils:from_seconds(duration);","else","notice = $time_utils:english_time((duration / 86400) * 86400);","endif","player:notify(tostr(dobj.name, \" has never connected.  It was created \", notice, \" ago.\"));","elseif (time == 0)","player:notify(tostr(dobj.name, \" first connected before initial connections were being recorded.\"));","else","player:notify(tostr(dobj.name, \" first connected on \", ctime(time)));","duration = time() - time;","if (duration < 86400)","notice = $string_utils:from_seconds(duration);","else","notice = $time_utils:english_time((duration / 86400) * 86400);","endif","player:notify(tostr($string_utils:pronoun_sub(\"%S %<is> \", dobj), notice, \" old.\"));","endif"]},{"name":"news","owner":2,"perms":29,"preposition":-1,"code":["\"Usage: news [contents] [articles]\";","\"\";","\"Common uses:\";","\"news           -- display all current news, or as @mail-options decree\";","\"news new       -- display articles you haven't seen yet\";","\"news all       -- display all current news\";","\"news contents  -- display headers of current news\";","\"news <article> -- display article\";","\"news archive   -- display news which has been marked as archived.\";","set_task_perms(player);","cur = this:get_current_message($news) || {0, 0};","arch = 0;","if (((!args) && (o = player:mail_option(\"news\"))) && (o != \"all\"))","\"no arguments, use the player's default\";","args = {o};","elseif (args == {\"all\"})","args = {};","elseif (args == {\"archive\"})","arch = 1;","args = {};","endif","if (hdrs_only = args && (args[1] == \"contents\"))","\"Do the mail contents list\";","args[1..1] = {};","endif","if (args)","if (typeof(seq = $news:_parse(args, @cur)) == STR)","player:notify(seq);","return;","elseif (seq = $seq_utils:intersection(seq, $news.current_news))","else","player:notify((args == {\"new\"}) ? \"No new news.\" | \"None of those are current articles.\");","return;","endif","elseif (arch && (seq = $news.archive_news))","\"yduJ hates this coding style.  Just so you know.\";","elseif (seq = $news.current_news)","else","player:notify(\"No news\");","return;","endif","if (hdrs_only)","$news:display_seq_headers(seq, @cur);","else","player:set_current_message($news, @$news:news_display_seq_full(seq));","endif"]},{"name":"@edit","owner":36,"perms":89,"preposition":-2,"code":["\"Calls the verb editor on verbs, the note editor on properties, and on anything else assumes it's an object for which you want to edit the .description.\";","if (!args)","((player in $note_editor.active) ? $note_editor | $verb_editor):invoke(dobjstr, verb);","elseif ($code_utils:parse_verbref(args[1]))","if (player.programmer)","$verb_editor:invoke(argstr, verb);","else","player:notify(\"You need to be a programmer to do this.\");","player:notify(\"If you want to become a programmer, talk to a wizard.\");","return;","endif","else","$note_editor:invoke(dobjstr, verb);","endif"]},{"name":"erase_paranoid_data","owner":2,"perms":173,"preposition":-1,"code":["if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))","return E_PERM;","else","$paranoid_db:erase_data(this);","endif"]},{"name":"@move-new","owner":2,"perms":89,"preposition":-2,"code":["\"'@move <object> to <place>' - Teleport an object. Example: '@move trash to #11' to move trash to the closet.\";","set_task_perms((caller == this) ? this | $no_one);","if ((prepstr != \"to\") || (!iobjstr))","player:tell(\"Usage: @move <object> to <location>\");","return;","endif","if ((!dobjstr) || (dobjstr == \"me\"))","dobj = this;","else","dobj = here:match_object(dobjstr);","if (!valid(dobj))","dobj = player:my_match_object(dobjstr);","endif","endif","if ($command_utils:object_match_failed(dobj, dobjstr))","return;","endif","iobj = this:lookup_room(iobjstr);","if ((iobj != $nothing) && $command_utils:object_match_failed(iobj, iobjstr))","return;","endif","if (((!player.programmer) && (!$perm_utils:controls(this, dobj))) && (this != dobj))","player:tell(\"You may only @move your own things.\");","return;","endif","this:teleport(dobj, iobj);"]},{"name":"notify_lines_suspended","owner":2,"perms":173,"preposition":-1,"code":["if (($perm_utils:controls(caller_perms(), this) || (caller == this)) || (caller_perms() == this))","set_task_perms(caller_perms());","for line in ((typeof(lines = args[1]) != LIST) ? {lines} | lines)","$command_utils:suspend_if_needed(0);","this:notify(tostr(line));","endfor","else","return E_PERM;","endif"]},{"name":"_chparent","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","return chparent(@args);"]},{"name":"@users","owner":36,"perms":13,"preposition":-1,"code":["\"Prints a count and compact list of the currently-connected players.\";","cp = connected_players();","linelen = abs(player.linelen) || 79;","player:tell_lines({tostr(\"There are \", length(cp), \" players connected:\"), @$generic_editor:fill_string($string_utils:english_list($list_utils:sort_suspended(0, $list_utils:map_prop(cp, \"name\"))), linelen)});"]},{"name":"@password","owner":2,"perms":89,"preposition":-2,"code":["if (typeof(player.password) != STR)","if (length(args) != 1)","return player:notify(tostr(\"Usage:  \", verb, \" <new-password>\"));","else","new_password = args[1];","endif","elseif (length(args) != 2)","player:notify(tostr(\"Usage:  \", verb, \" <old-password> <new-password>\"));","return;","elseif (player.password != crypt(tostr(args[1]), player.password))","player:notify(\"That's not your old password.\");","return;","elseif (is_clear_property(player, \"password\"))","player:notify(\"Your password has a `clear' property.  Please refer to a wizard for assistance in changing it.\");","return;","else","new_password = args[2];","endif","if (r = $password_verifier:reject_password(new_password, player))","player:notify(r);","return;","endif","player.password = crypt(tostr(new_password));","player.last_password_time = time();","player:notify(\"New password set.\");"]},{"name":"recycle","owner":2,"perms":173,"preposition":-1,"code":["if ((caller == this) || $perm_utils:controls(caller_perms(), this))","pass(@args);","features = this.features;","\"Have to do this, or :feature_remove thinks you're a liar and doesn't believe.\";","this.features = {};","for x in (features)","try","x:feature_remove(this);","except (ANY)","\"Ignore errors\";","endtry","$command_utils:suspend_if_needed(0);","endfor","endif"]},{"name":"gc_gaglist","owner":2,"perms":173,"preposition":-1,"code":["((caller == this) || $perm_utils:controls(caller_perms(), this)) || raise(E_PERM);","if (g = this.gaglist)","recycler = $recycler;","for o in (g)","if (!recycler:valid(o))","g = setremove(g, o);","endif","endfor","this.gaglist = g;","endif"]},{"name":"email_address","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","return this.email_address;"]},{"name":"set_email_address","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","this.email_address = args[1];"]},{"name":"reconfunc","owner":2,"perms":173,"preposition":-1,"code":["if (((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (caller != $sysobj))","return E_PERM;","endif","return this:confunc(@args);"]},{"name":"invoke","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","this:move(player);"]},{"name":"move","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","what = args[1];","\"if ((what.location != this.source) || (!(this in this.source.exits)))\";","\"  player:tell(\\\"You can't go that way.\\\");\";","\"  return;\";","\"endif\";","unlocked = this:is_unlocked_for(what);","if (unlocked)","this.dest:bless_for_entry(what);","endif","if (unlocked && this.dest:acceptable(what))","start = what.location;","if (msg = this:leave_msg(what))","what:tell_lines(msg);","endif","what:moveto(this.dest);","if (what.location != start)","\"Don't print oleave messages if WHAT didn't actually go anywhere...\";","this:announce_msg(start, what, (this:oleave_msg(what) || this:defaulting_oleave_msg(what)) || \"has left.\");","endif","if (what.location == this.dest)","\"Don't print arrive messages if WHAT didn't really end up there...\";","if (msg = this:arrive_msg(what))","what:tell_lines(msg);","endif","this:announce_msg(what.location, what, this:oarrive_msg(what) || \"has arrived.\");","endif","else","if (msg = this:nogo_msg(what))","what:tell_lines(msg);","else","what:tell(\"You can't go that way.\");","endif","if (msg = this:onogo_msg(what))","this:announce_msg(what.location, what, msg);","endif","endif"]},{"name":"recycle","owner":2,"perms":173,"preposition":-1,"code":["if ((caller == this) || $perm_utils:controls(caller_perms(), this))","try","this.source:remove_exit(this);","this.dest:remove_entrance(this);","except id (ANY)","endtry","return pass(@args);","else","return E_PERM;","endif"]},{"name":"leave_msg oleave_msg arrive_msg oarrive_msg nogo_msg onogo_msg","owner":2,"perms":173,"preposition":-1,"code":["msg = this.(verb);","return msg ? $string_utils:pronoun_sub(msg, @args) | \"\";"]},{"name":"set_name","owner":2,"perms":173,"preposition":-1,"code":["if ($perm_utils:controls(cp = caller_perms(), this) || (valid(this.source) && (this.source.owner == cp)))","return (typeof(e = `this.name = args[1] ! ANY') != ERR) || e;","else","return E_PERM;","endif"]},{"name":"set_aliases","owner":2,"perms":173,"preposition":-1,"code":["if ($perm_utils:controls(cp = caller_perms(), this) || (valid(this.source) && (this.source.owner == cp)))","if (typeof(e = `this.aliases = args[1] ! ANY') == ERR)","return e;","else","return 1;","endif","else","return E_PERM;","endif"]},{"name":"announce_all_but","owner":2,"perms":173,"preposition":-1,"code":["\"This is intended to be called only by exits, for announcing various oxxx messages.  First argument is room to announce in.  Second argument is as in $room:announce_all_but's first arg, who not to announce to.  Rest args are what to say.  If the final arg is a list, prepends all the other rest args to the first line and emits the lines separately.\";","where = args[1];","whobut = args[2];","last = args[$];","if (typeof(last) == LIST)","where:announce_all_but(whobut, @args[3..$ - 1], last[1]);","for line in (last[2..$])","where:announce_all_but(whobut, line);","endfor","else","where:announce_all_but(@args[3..$]);","endif"]},{"name":"defaulting_oleave_msg","owner":2,"perms":173,"preposition":-1,"code":["for k in ({this.name, @this.aliases})","if (k in {\"east\", \"west\", \"south\", \"north\", \"northeast\", \"southeast\", \"southwest\", \"northwest\", \"out\", \"up\", \"down\", \"nw\", \"sw\", \"ne\", \"se\", \"in\"})","return (\"goes \" + k) + \".\";","elseif (k in {\"leave\", \"out\", \"exit\"})","return \"leaves\";","endif","endfor","if ((index(this.name, \"an \") == 1) || (index(this.name, \"a \") == 1))","return (\"leaves for \" + this.name) + \".\";","else","return (\"leaves for the \" + this.name) + \".\";","endif"]},{"name":"moveto","owner":2,"perms":173,"preposition":-1,"code":["if ((caller in {this, this.owner}) || $perm_utils:controls(caller_perms(), this))","return pass(@args);","else","return E_PERM;","endif"]},{"name":"examine_key","owner":2,"perms":173,"preposition":-1,"code":["\"examine_key(examiner)\";","\"return a list of strings to be told to the player, indicating what the key on this type of object means, and what this object's key is set to.\";","\"the default will only tell the key to a wizard or this object's owner.\";","who = args[1];","if (((caller == this) && $perm_utils:controls(who, this)) && (this.key != 0))","return {tostr(this:title(), \" will only transport objects matching this key:\"), tostr(\"  \", $lock_utils:unparse_key(this.key))};","endif"]},{"name":"announce_msg","owner":2,"perms":173,"preposition":-1,"code":["\":announce_msg(place, what, msg)\";","\"  announce msg in place (except to what). Prepend with what:title if it isn't part of the string\";","msg = args[3];","what = args[2];","title = what:titlec();","if (!$string_utils:index_delimited(msg, title))","msg = tostr(title, \" \", msg);","endif","args[1]:announce_all_but({what}, msg);"]},{"name":"p*ut in*sert d*rop","owner":2,"perms":157,"preposition":3,"code":["if ((this.location != player) && (this.location != player.location))","player:tell(\"You can't get at \", this.name, \".\");","elseif (dobj == $nothing)","player:tell(\"What do you want to put \", prepstr, \" \", this.name, \"?\");","elseif ($command_utils:object_match_failed(dobj, dobjstr))","elseif ((dobj.location != player) && (dobj.location != player.location))","player:tell(\"You don't have \", dobj.name, \".\");","elseif (!this.opened)","player:tell(this.name, \" is closed.\");","else","set_task_perms(callers() ? caller_perms() | player);","dobj:moveto(this);","if (dobj.location == this)","player:tell(this:put_msg());","if (msg = this:oput_msg())","player.location:announce(player.name, \" \", msg);","endif","else","player:tell(this:put_fail_msg());","if (msg = this:oput_fail_msg())","player.location:announce(player.name, \" \", msg);","endif","endif","endif"]},{"name":"re*move ta*ke g*et","owner":2,"perms":157,"preposition":5,"code":["if (!(this.location in {player, player.location}))","player:tell(\"Sorry, you're too far away.\");","elseif (!this.opened)","player:tell(this.name, \" is not open.\");","elseif (this.dark)","player:tell(\"You can't see into \", this.name, \" to remove anything.\");","elseif ((dobj = this:match_object(dobjstr)) == $nothing)","player:tell(\"What do you want to take from \", this.name, \"?\");","elseif ($command_utils:object_match_failed(dobj, dobjstr))","elseif (!(dobj in this:contents()))","player:tell(dobj.name, \" isn't in \", this.name, \".\");","else","set_task_perms(callers() ? caller_perms() | player);","dobj:moveto(player);","if (dobj.location == player)","player:tell(this:remove_msg());","if (msg = this:oremove_msg())","player.location:announce(player.name, \" \", msg);","endif","else","dobj:moveto(this.location);","if (dobj.location == this.location)","player:tell(this:remove_msg());","if (msg = this:oremove_msg())","player.location:announce(player.name, \" \", msg);","endif","player:tell(\"You can't pick up \", dobj.name, \", so it tumbles onto the floor.\");","else","player:tell(this:remove_fail_msg());","if (msg = this:oremove_fail_msg())","player.location:announce(player.name, \" \", msg);","endif","endif","endif","endif"]},{"name":"look_self","owner":2,"perms":173,"preposition":-1,"code":["pass();","if (!this.dark)","this:tell_contents();","endif"]},{"name":"acceptable","owner":2,"perms":173,"preposition":-1,"code":["return !is_player(args[1]);"]},{"name":"open","owner":2,"perms":45,"preposition":-1,"code":["perms = (callers() && (caller != this)) ? caller_perms() | player;","if (this.opened)","player:tell(\"It's already open.\");","\"elseif (this:is_openable_by(player))\";","elseif (this:is_openable_by(perms))","this:set_opened(1);","player:tell(this:open_msg());","if (msg = this:oopen_msg())","player.location:announce(player.name, \" \", msg);","endif","else","player:tell(this:open_fail_msg());","if (msg = this:oopen_fail_msg())","player.location:announce(player.name, \" \", msg);","endif","endif"]},{"name":"@lock_for_open","owner":2,"perms":105,"preposition":0,"code":["set_task_perms(player);","key = $lock_utils:parse_keyexp(iobjstr, player);","if (typeof(key) == STR)","player:tell(\"That key expression is malformed:\");","player:tell(\"  \", key);","else","try","this.open_key = key;","player:tell(\"Locked opening of \", this.name, \" with this key:\");","player:tell(\"  \", $lock_utils:unparse_key(key));","except error (ANY)","player:tell(error[2], \".\");","endtry","endif"]},{"name":"is_openable_by","owner":2,"perms":173,"preposition":-1,"code":["return (this.open_key == 0) || $lock_utils:eval_key(this.open_key, args[1]);"]},{"name":"close","owner":2,"perms":45,"preposition":-1,"code":["if (!this.opened)","player:tell(\"It's already closed.\");","else","this:set_opened(0);","player:tell(this:close_msg());","if (msg = this:oclose_msg())","player.location:announce(player.name, \" \", msg);","endif","endif"]},{"name":"@unlock_for_open","owner":2,"perms":41,"preposition":-1,"code":["set_task_perms(player);","try","dobj.open_key = 0;","player:tell(\"Unlocked \", dobj.name, \" for opening.\");","except error (ANY)","player:tell(error[2], \".\");","endtry"]},{"name":"tell_contents","owner":2,"perms":173,"preposition":-1,"code":["if (this.contents)","player:tell(\"Contents:\");","for thing in (this:contents())","player:tell(\"  \", thing:title());","endfor","elseif (msg = this:empty_msg())","player:tell(msg);","endif"]},{"name":"set_opened","owner":2,"perms":173,"preposition":-1,"code":["if (!$perm_utils:controls(caller.owner, this))","return E_PERM;","else","this.opened = opened = !(!args[1]);","this.dark = this.opaque > opened;","return opened;","endif"]},{"name":"@opacity","owner":2,"perms":105,"preposition":12,"code":["if (!$perm_utils:controls(player, this))","player:tell(\"Can't set opacity of something you don't own.\");","elseif ((iobjstr != \"0\") && (!toint(iobjstr)))","player:tell(\"Opacity must be an integer (0, 1, 2).\");","else","player:tell(\"Opacity changed:  Now \" + {\"transparent.\", \"opaque.\", \"a black hole.\"}[1 + this:set_opaque(toint(iobjstr))]);","endif"]},{"name":"set_opaque","owner":2,"perms":173,"preposition":-1,"code":["if (!$perm_utils:controls(caller.owner, this))","return E_PERM;","elseif (typeof(number = args[1]) != INT)","return E_INVARG;","else","number = (number < 0) ? 0 | ((number > 2) ? 2 | number);","this.dark = number > this.opened;","return this.opaque = number;","endif"]},{"name":"oclose_msg close_msg oopen_msg open_msg oput_fail_msg put_fail_msg oremove_fail_msg oremove_msg remove_fail_msg remove_msg oput_msg put_msg oopen_fail_msg open_fail_msg empty_msg","owner":36,"perms":173,"preposition":-1,"code":["return (msg = `this.(verb) ! ANY') ? $string_utils:pronoun_sub(msg) | \"\";"]},{"name":"dark","owner":2,"perms":173,"preposition":-1,"code":["return this.(verb);"]},{"name":"r*ead","owner":2,"perms":45,"preposition":-1,"code":["if (!this:is_readable_by(valid(caller_perms()) ? caller_perms() | player))","player:tell(\"Sorry, but it seems to be written in some code that you can't read.\");","else","this:look_self();","player:tell();","player:tell_lines_suspended(this:text());","player:tell();","player:tell(\"(You finish reading.)\");","endif"]},{"name":"er*ase","owner":2,"perms":45,"preposition":-1,"code":["if (this:is_writable_by(valid(caller_perms()) ? caller_perms() | player))","this:set_text({});","player:tell(\"Note erased.\");","else","player:tell(\"You can't erase this note.\");","endif"]},{"name":"wr*ite","owner":2,"perms":157,"preposition":4,"code":["if (this:is_writable_by(valid(caller_perms()) ? caller_perms() | player))","this:set_text({@this.text, dobjstr});","player:tell(\"Line added to note.\");","else","player:tell(\"You can't write on this note.\");","endif"]},{"name":"del*ete rem*ove","owner":2,"perms":153,"preposition":5,"code":["if (!this:is_writable_by(player))","player:tell(\"You can't modify this note.\");","elseif (!dobjstr)","player:tell(\"You must tell me which line to delete.\");","else","line = toint(dobjstr);","if (line < 0)","line = (line + length(this.text)) + 1;","endif","if ((line <= 0) || (line > length(this.text)))","player:tell(\"Line out of range.\");","else","this:set_text(listdelete(this.text, line));","player:tell(\"Line deleted.\");","endif","endif"]},{"name":"encrypt","owner":2,"perms":105,"preposition":0,"code":["set_task_perms(player);","key = $lock_utils:parse_keyexp(iobjstr, player);","if (typeof(key) == STR)","player:tell(\"That key expression is malformed:\");","player:tell(\"  \", key);","else","try","this.encryption_key = key;","player:tell(\"Encrypted \", this.name, \" with this key:\");","player:tell(\"  \", $lock_utils:unparse_key(key));","except error (ANY)","player:tell(error[2], \".\");","endtry","endif"]},{"name":"decrypt","owner":2,"perms":41,"preposition":-1,"code":["set_task_perms(player);","try","dobj.encryption_key = 0;","player:tell(\"Decrypted \", dobj.name, \".\");","except error (ANY)","player:tell(error[2], \".\");","endtry"]},{"name":"text","owner":2,"perms":173,"preposition":-1,"code":["cp = caller_perms();","if ($perm_utils:controls(cp, this) || this:is_readable_by(cp))","return this.text;","else","return E_PERM;","endif"]},{"name":"is_readable_by","owner":2,"perms":173,"preposition":-1,"code":["key = this.encryption_key;","return (key == 0) || $lock_utils:eval_key(key, args[1]);"]},{"name":"set_text","owner":2,"perms":173,"preposition":-1,"code":["cp = caller_perms();","newtext = args[1];","if ($perm_utils:controls(cp, this) || this:is_writable_by(cp))","if (typeof(newtext) == LIST)","this.text = newtext;","else","return E_TYPE;","endif","else","return E_PERM;","endif"]},{"name":"is_writable_by","owner":2,"perms":173,"preposition":-1,"code":["who = args[1];","wr = this.writers;","if ($perm_utils:controls(who, this))","return 1;","elseif (typeof(wr) == LIST)","return who in wr;","else","return wr;","endif"]},{"name":"mailme @mailme","owner":2,"perms":41,"preposition":-1,"code":["\"Usage:  mailme <note>\";","\"  uses $network to sends the text of this note to your REAL internet email address.\";","if (!this:is_readable_by(player))","return player:tell(\"Sorry, but it seems to be written in some code that you can't read.\");","elseif (!$wiz_utils:get_email_address(player))","return player:tell(\"Sorry, you don't have a registered email address.\");","elseif (!$network.active)","return player:tell(\"Sorry, internet mail is disabled.\");","elseif (!(text = this:text()))","return player:tell($string_utils:pronoun_sub(\"%T is empty--there wouldn't be any point to mailing it.\"));","endif","player:tell(\"Mailing \", this:title(), \" to \", $wiz_utils:get_email_address(player), \".\");","player:tell(\"... \", length(text), \" lines ...\");","suspend(0);","$network:sendmail($wiz_utils:get_email_address(player), this:titlec(), \"\", @text);"]},{"name":"?","owner":2,"perms":93,"preposition":-1,"code":["if ((caller != #0) && (caller != this))","return E_PERM;","else","clist = {};","for j in ({this, @$object_utils:ancestors(this)})","for i in [1..length(verbs(j))]","if ((verb_args(j, i) == {\"any\", \"none\", \"any\"}) && index((info = verb_info(j, i))[2], \"x\"))","vname = $string_utils:explode(info[3])[1];","star = index(vname + \"*\", \"*\");","clist = {@clist, $string_utils:uppercase(vname[1..star - 1]) + strsub(vname[star..$], \"*\", \"\")};","endif","endfor","endfor","notify(player, \"I don't understand that.  Valid commands at this point are\");","notify(player, \"   \" + $string_utils:english_list(setremove(clist, \"?\"), \"\", \" or \"));","return 0;","endif"]},{"name":"wel*come @wel*come","owner":2,"perms":93,"preposition":-1,"code":["if ((caller != #0) && (caller != this))","return E_PERM;","else","msg = this.welcome_message;","version = server_version();","for line in ((typeof(msg) == LIST) ? msg | {msg})","if (typeof(line) == STR)","notify(player, strsub(line, \"%v\", version));","endif","endfor","this:check_player_db();","this:check_for_shutdown();","this:check_for_checkpoint();","this:maybe_print_lag();","return 0;","endif"]},{"name":"w*ho @w*ho","owner":2,"perms":93,"preposition":-1,"code":["masked = $login.who_masks_wizards ? $wiz_utils:connected_wizards() | {};","if ((caller != #0) && (caller != this))","return E_PERM;","elseif (!args)","plyrs = connected_players();","if (length(plyrs) > 100)","this:notify(tostr(\"You have requested a listing of \", length(plyrs), \" players.  Please restrict the number of players in any single request to a smaller number.  The lag thanks you.\"));","return 0;","else","$code_utils:show_who_listing($set_utils:difference(plyrs, masked)) || this:notify(\"No one logged in.\");","endif","else","plyrs = listdelete($command_utils:player_match_result($string_utils:match_player(args), args), 1);","if (length(plyrs) > 100)","this:notify(tostr(\"You have requested a listing of \", length(plyrs), \" players.  Please restrict the number of players in any single request to a smaller number.  The lag thanks you.\"));","return 0;","endif","$code_utils:show_who_listing(plyrs, $set_utils:intersection(plyrs, masked));","endif","return 0;"]},{"name":"co*nnect @co*nnect","owner":2,"perms":93,"preposition":-1,"code":["\"$login:connect(player-name [, password])\";","\" => 0 (for failed connections)\";","\" => objnum (for successful connections)\";","((caller == #0) || (caller == this)) || raise(E_PERM);","\"=================================================================\";","\"=== Check arguments, print usage notice if necessary\";","try","{name, ?password = 0} = args;","name = strsub(name, \" \", \"_\");","except (E_ARGS)","notify(player, tostr(\"Usage:  \", verb, \" <existing-player-name> <password>\"));","return 0;","endtry","try","\"=================================================================\";","\"=== Is our candidate name invalid?\";","if (!valid(candidate = orig_candidate = this:_match_player(name)))","raise(E_INVARG, tostr(\"`\", name, \"' matches no player name.\"));","endif","\"=================================================================\";","\"=== Is our candidate unable to connect for generic security\";","\"=== reasons (ie clear password, non-player object)?\";","if (`is_clear_property(candidate, \"password\") ! E_PROPNF' || (!$object_utils:isa(candidate, $player)))","server_log(tostr(\"FAILED CONNECT: \", name, \" (\", candidate, \") on \", connection_name(player), ($string_utils:connection_hostname(connection_name(player)) in candidate.all_connect_places) ? \"\" | \"******\"));","raise(E_INVARG);","endif","\"=================================================================\";","\"=== Check password\";","if (typeof(cp = candidate.password) == STR)","\"=== Candidate requires a password\";","if (password)","\"=== Candidate requires a password, and one was provided\";","if (strcmp(crypt(password, cp), cp))","\"=== Candidate requires a password, and one was provided, which was wrong\";","server_log(tostr(\"FAILED CONNECT: \", name, \" (\", candidate, \") on \", connection_name(player), ($string_utils:connection_hostname(connection_name(player)) in candidate.all_connect_places) ? \"\" | \"******\"));","raise(E_INVARG, \"Invalid password.\");","else","\"=== Candidate requires a password, and one was provided, which was right\";","endif","else","\"=== Candidate requires a password, and none was provided\";","set_connection_option(player, \"binary\", 1);","notify(player, \"Password: \");","set_connection_option(player, \"binary\", 0);","set_connection_option(player, \"client-echo\", 0);","this:add_interception(player, \"intercepted_password\", candidate);","return 0;","endif","elseif (cp == 0)","\"=== Candidate does not require a password\";","else","\"=== Candidate has a nonstandard password; something's wrong\";","raise(E_INVARG);","endif","\"=================================================================\";","\"=== Is the player locked out?\";","if ($no_connect_message && (!candidate.wizard))","notify(player, $no_connect_message);","server_log(tostr(\"REJECTED CONNECT: \", name, \" (\", candidate, \") on \", connection_name(player)));","return 0;","endif","\"=================================================================\";","\"=== Check guest connections\";","if ($object_utils:isa(candidate, $guest) && (!valid(candidate = candidate:defer())))","if (candidate == #-2)","server_log(tostr(\"GUEST DENIED: \", connection_name(player)));","notify(player, \"Sorry, guest characters are not allowed from your site at the current time.\");","else","notify(player, \"Sorry, all of our guest characters are in use right now.\");","endif","return 0;","endif","\"=================================================================\";","\"=== Check newts\";","if (candidate in this.newted)","if (entry = $list_utils:assoc(candidate, this.temporary_newts))","if ((uptime = this:uptime_since(entry[2])) > entry[3])","\"Temporary newting period is over.  Remove entry.  Oh, send mail, too.\";","this.temporary_newts = setremove(this.temporary_newts, entry);","this.newted = setremove(this.newted, candidate);","fork (0)","player = this.owner;","$mail_agent:send_message(player, $newt_log, tostr(\"automatic @unnewt \", candidate.name, \" (\", candidate, \")\"), {\"message sent from $login:connect\"});","endfork","else","notify(player, \"\");","notify(player, this:temp_newt_registration_string(entry[3] - uptime));","boot_player(player);","return 0;","endif","else","notify(player, \"\");","notify(player, this:newt_registration_string());","boot_player(player);","return 0;","endif","endif","\"=================================================================\";","\"=== Connection limits based on lag\";","if ((((!candidate.wizard) && (!(candidate in this.lag_exemptions))) && ((howmany = length(connected_players())) >= (max = this:max_connections()))) && (!$object_utils:connected(candidate)))","notify(player, $string_utils:subst(this.connection_limit_msg, {{\"%n\", tostr(howmany)}, {\"%m\", tostr(max)}, {\"%l\", tostr(this:current_lag())}, {\"%t\", candidate.last_connect_attempt ? ctime(candidate.last_connect_attempt) | \"not recorded\"}}));","if ($object_utils:has_property($local, \"mudlist\"))","notify(player, \"You may wish to try another MUD while waiting for the MOO to unlag.  Here are a few that we know of:\");","for l in ($local.mudlist:choose(3))","notify(player, l);","endfor","endif","candidate.last_connect_attempt = time();","server_log(tostr(\"CONNECTION LIMIT EXCEEDED: \", name, \" (\", candidate, \") on \", connection_name(player)));","boot_player(player);","return 0;","endif","\"=================================================================\";","\"=== Log the player on!\";","if (candidate != orig_candidate)","notify(player, tostr(\"Okay,... \", name, \" is in use.  Logging you in as `\", candidate.name, \"'\"));","endif","this:record_connection(candidate);","return candidate;","except (E_INVARG)","notify(player, \"Either that player does not exist, or has a different password.\");","return 0;","endtry"]},{"name":"cr*eate @cr*eate","owner":2,"perms":93,"preposition":-1,"code":["if ((caller != #0) && (caller != this))","return E_PERM;","\"... caller isn't :do_login_command()...\";","elseif (!this:player_creation_enabled(player))","notify(player, this:registration_string());","\"... we've disabled player creation ...\";","elseif (length(args) != 2)","notify(player, tostr(\"Usage:  \", verb, \" <new-player-name> <new-password>\"));","elseif ($player_db.frozen)","notify(player, \"Sorry, can't create any new players right now.  Try again in a few minutes.\");","elseif ((!(name = args[1])) || (name == \"<>\"))","notify(player, \"You can't have a blank name!\");","if (name)","notify(player, \"Also, don't use angle brackets (<>).\");","endif","elseif ((name[1] == \"<\") && (name[$] == \">\"))","notify(player, \"Try that again but without the angle brackets, e.g.,\");","notify(player, tostr(\" \", verb, \" \", name[2..$ - 1], \" \", strsub(strsub(args[2], \"<\", \"\"), \">\", \"\")));","notify(player, \"This goes for other commands as well.\");","elseif (index(name, \" \"))","notify(player, \"Sorry, no spaces are allowed in player names.  Use dashes or underscores.\");","\"... lots of routines depend on there not being spaces in player names...\";","elseif ((!$player_db:available(name)) || (this:_match_player(name) != $failed_match))","notify(player, \"Sorry, that name is not available.  Please choose another.\");","\"... note the :_match_player call is not strictly necessary...\";","\"... it is merely there to handle the case that $player_db gets corrupted.\";","elseif (!(password = args[2]))","notify(player, \"You must set a password for your player.\");","else","new = $quota_utils:bi_create($player_class, $nothing);","set_player_flag(new, 1);","new.name = name;","new.aliases = {name};","new.programmer = $player_class.programmer;","new.password = crypt(password);","new.last_password_time = time();","new.last_connect_time = $maxint;","\"Last disconnect time is creation time, until they login.\";","new.last_disconnect_time = time();","\"make sure the owership quota isn't clear!\";","$quota_utils:initialize_quota(new);","this:record_connection(new);","$player_db:insert(name, new);","`move(new, $player_start) ! ANY';","return new;","endif","return 0;"]},{"name":"q*uit @q*uit","owner":2,"perms":93,"preposition":-1,"code":["if ((caller != #0) && (caller != this))","return E_PERM;","else","boot_player(player);","return 0;","endif"]},{"name":"up*time @up*time","owner":2,"perms":93,"preposition":-1,"code":["if ((caller != #0) && (caller != this))","return E_PERM;","else","notify(player, tostr(\"The server has been up for \", $time_utils:english_time(time() - $last_restart_time), \".\"));","return 0;","endif"]},{"name":"v*ersion @v*ersion","owner":2,"perms":93,"preposition":-1,"code":["if ((caller != #0) && (caller != this))","return E_PERM;","else","notify(player, tostr(\"The MOO is currently running version \", server_version(), \" of the LambdaMOO server code.\"));","return 0;","endif"]},{"name":"parse_command","owner":2,"perms":173,"preposition":-1,"code":["\":parse_command(@args) => {verb, args}\";","\"Given the args from #0:do_login_command,\";","\"  returns the actual $login verb to call and the args to use.\";","\"Commands available to not-logged-in users should be located on this object and given the verb_args \\\"any none any\\\"\";","if ((caller != #0) && (caller != this))","return E_PERM;","endif","if (li = this:interception(player))","return {@li, @args};","endif","if (!args)","return {this.blank_command, @args};","elseif ((verb = args[1]) && (!$string_utils:is_numeric(verb)))","for i in ({this, @$object_utils:ancestors(this)})","try","if ((verb_args(i, verb) == {\"any\", \"none\", \"any\"}) && index(verb_info(i, verb)[2], \"x\"))","return args;","endif","except (ANY)","continue i;","endtry","endfor","endif","return {this.bogus_command, @args};"]},{"name":"check_for_shutdown","owner":2,"perms":173,"preposition":-1,"code":["when = $shutdown_time - time();","if (when >= 0)","line = \"***************************************************************************\";","notify(player, \"\");","notify(player, \"\");","notify(player, line);","notify(player, line);","notify(player, \"****\");","notify(player, (\"****  WARNING:  The server will shut down in \" + $time_utils:english_time(when - (when % 60))) + \".\");","for piece in ($generic_editor:fill_string($shutdown_message, 60))","notify(player, \"****            \" + piece);","endfor","notify(player, \"****\");","notify(player, line);","notify(player, line);","notify(player, \"\");","notify(player, \"\");","endif"]},{"name":"check_player_db","owner":2,"perms":173,"preposition":-1,"code":["if ($player_db.frozen)","line = \"***************************************************************************\";","notify(player, \"\");","notify(player, line);","notify(player, \"***\");","for piece in ($generic_editor:fill_string(\"The character-name matcher is currently being reloaded.  This means your character name might not be recognized even though it still exists.  Don't panic.  You can either wait for the reload to finish or you can connect using your object number if you remember it (e.g., `connect #1234 yourpassword').\", 65))","notify(player, \"***       \" + piece);","endfor","notify(player, \"***\");","for piece in ($generic_editor:fill_string(\"Repeat:  Do not panic.  In particular, please do not send mail to any wizards or the registrar asking about this.  It will finish in time.  Thank you for your patience.\", 65))","notify(player, \"***       \" + piece);","endfor","if (this:player_creation_enabled(player))","notify(player, \"***       This also means that character creation is disabled.\");","endif","notify(player, \"***\");","notify(player, line);","notify(player, \"\");","endif"]},{"name":"_match_player","owner":2,"perms":173,"preposition":-1,"code":["\":_match_player(name)\";","\"This is the matching routine used by @connect.\";","\"returns either a valid player corresponding to name or $failed_match.\";","name = args[1];","if (valid(candidate = $string_utils:literal_object(name)) && is_player(candidate))","return candidate;","endif","\".....uncomment this to trust $player_db and have `connect' recognize aliases\";","if (valid(candidate = $player_db:find_exact(name)) && is_player(candidate))","return candidate;","endif","\".....uncomment this if $player_db gets hosed and you want by-name login\";","\". for candidate in (players())\";","\".   if (candidate.name == name)\";","\".     return candidate; \";","\".   endif \";","\". endfor \";","\".....\";","return $failed_match;"]},{"name":"notify","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","`notify(player, args[1]) ! ANY';"]},{"name":"tell","owner":36,"perms":173,"preposition":-1,"code":["\"keeps bad things from happening if someone brings this object into a room and talks to it.\";","return 0;"]},{"name":"player_creation_enabled","owner":2,"perms":173,"preposition":-1,"code":["\"Accepts a player object.  If player creation is enabled for that player object, then return true.  Otherwise, return false.\";","\"Default implementation checks the player's connecting host via $login:blacklisted to decide.\";","if (caller_perms().wizard)","return this.create_enabled && (!this:blacklisted($string_utils:connection_hostname(connection_name(args[1]))));","else","return E_PERM;","endif"]},{"name":"newt_registration_string registration_string","owner":2,"perms":173,"preposition":-1,"code":["return $string_utils:subst(this.(verb), {{\"%e\", this.registration_address}, {\"%%\", \"%\"}});"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","pass();","this.lag_exemptions = {};","this.max_connections = 99999;","this.lag_samples = {0, 0, 0, 0, 0};","this.print_lag = 0;","this.last_lag_sample = 0;","this.bogus_command = \"?\";","this.blank_command = \"welcome\";","this.create_enabled = 1;","this.registration_address = \"\";","this.registration_string = \"Character creation is disabled.\";","this.newt_registration_string = \"Your character is temporarily hosed.\";","this.welcome_message = {\"Welcome to the LambdaCore database.\", \"\", \"Type 'connect wizard' to log in.\", \"\", \"You will probably want to change this text and the output of the `help' command, which are stored in $login.welcome_message and $login.help_message, respectively.\"};","this.help_message = {\"Sorry, but there's no help here yet.  Type `?' for a list of commands.\"};","this.redlist = this.blacklist = this.graylist = this.spooflist = {{}, {}};","this.temporary_redlist = this.temporary_blacklist = this.temporary_graylist = this.temporary_spooflist = {{}, {}};","this.who_masks_wizards = 0;","this.newted = this.temporary_newts = {};","this.downtimes = {};","if (\"monitor\" in properties(this))","delete_property(this, \"monitor\");","endif","if (\"monitor\" in verbs(this))","delete_verb(this, \"monitor\");","endif","if (\"record_connection(real)\" in verbs(this))","delete_verb(this, \"record_connection\");","info = verb_info(this, \"record_connection(real)\");","set_verb_info(this, \"record_connection(real)\", {info[1], \"rxd\", \"record_connection\"});","endif","if (\"special_action\" in verbs(this))","set_verb_code(this, \"special_action\", {});","endif","endif"]},{"name":"special_action","owner":2,"perms":164,"preposition":-1,"code":[]},{"name":"blacklisted graylisted redlisted spooflisted","owner":2,"perms":173,"preposition":-1,"code":["\":blacklisted(hostname) => is hostname on the .blacklist\";","\":graylisted(hostname)  => is hostname on the .graylist\";","\":redlisted(hostname)   => is hostname on the .redlist\";","sitelist = this.(this:listname(verb));","if (!caller_perms().wizard)","return E_PERM;","elseif (((hostname = args[1]) in sitelist[1]) || (hostname in sitelist[2]))","return 1;","elseif ($site_db:domain_literal(hostname))","for lit in (sitelist[1])","if ((index(hostname, lit) == 1) && ((hostname + \".\")[length(lit) + 1] == \".\"))","return 1;","endif","endfor","else","for dom in (sitelist[2])","if (index(dom, \"*\"))","\"...we have a wildcard; let :match_string deal with it...\";","if ($string_utils:match_string(hostname, dom))","return 1;","endif","else","\"...tail of hostname ...\";","if ((r = rindex(hostname, dom)) && (((\".\" + hostname)[r] == \".\") && (((r - 1) + length(dom)) == length(hostname))))","return 1;","endif","endif","endfor","endif","return this:(verb + \"_temp\")(hostname);"]},{"name":"blacklist_add*_temp graylist_add*_temp redlist_add*_temp spooflist_add*_temp","owner":2,"perms":173,"preposition":-1,"code":["\"To add a temporary entry, only call the `temp' version.\";","\"blacklist_add_temp(Site, start time, duration)\";","if (!caller_perms().wizard)","return E_PERM;","endif","{where, ?start, ?duration} = args;","lname = this:listname(verb);","which = 1 + (!$site_db:domain_literal(where));","if (index(verb, \"temp\"))","lname = \"temporary_\" + lname;","this.(lname)[which] = setadd(this.(lname)[which], {where, start, duration});","else","this.(lname)[which] = setadd(this.(lname)[which], where);","endif","return 1;"]},{"name":"blacklist_remove*_temp graylist_remove*_temp redlist_remove*_temp spooflist_remove*_temp","owner":2,"perms":173,"preposition":-1,"code":["\"The temp version removes from the temporary property if it exists.\";","if (!caller_perms().wizard)","return E_PERM;","endif","where = args[1];","lname = this:listname(verb);","which = 1 + (!$site_db:domain_literal(where));","if (index(verb, \"temp\"))","lname = \"temporary_\" + lname;","if (entry = $list_utils:assoc(where, this.(lname)[which]))","this.(lname)[which] = setremove(this.(lname)[which], entry);","return 1;","else","return E_INVARG;","endif","elseif (where in this.(lname)[which])","this.(lname)[which] = setremove(this.(lname)[which], where);","return 1;","else","return E_INVARG;","endif"]},{"name":"listname","owner":2,"perms":173,"preposition":-1,"code":["return {\"???\", \"blacklist\", \"graylist\", \"redlist\", \"spooflist\"}[1 + index(\"bgrs\", (args[1] || \"?\")[1])];"]},{"name":"who(vanilla)","owner":2,"perms":173,"preposition":-1,"code":["if (caller != #0)","return E_PERM;","elseif (!args)","$code_utils:show_who_listing(connected_players()) || this:notify(\"No one logged in.\");","else","plyrs = listdelete($command_utils:player_match_result($string_utils:match_player(args), args), 1);","$code_utils:show_who_listing(plyrs);","endif","return 0;"]},{"name":"record_connection","owner":2,"perms":173,"preposition":-1,"code":["\":record_connection(plyr) update plyr's connection information\";","\"to reflect impending login.\";","if (!caller_perms().wizard)","return E_PERM;","else","plyr = args[1];","plyr.first_connect_time = min(time(), plyr.first_connect_time);","plyr.previous_connection = {plyr.last_connect_time, $string_utils:connection_hostname(plyr.last_connect_place)};","plyr.last_connect_time = time();","plyr.last_connect_place = cn = connection_name(player);","chost = $string_utils:connection_hostname(cn);","acp = setremove(plyr.all_connect_places, chost);","plyr.all_connect_places = {chost, @acp[1..min($, 15)]};","if (!$object_utils:isa(plyr, $guest))","$site_db:add(plyr, chost);","endif","endif"]},{"name":"sample_lag","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return E_PERM;","endif","lag = (time() - this.last_lag_sample) - 15;","this.lag_samples = {lag, @this.lag_samples[1..3]};","\"Now compute the current lag and store it in a property, instead of computing it in :current_lag, which is called a hundred times a second.\";","thislag = max(0, (time() - this.last_lag_sample) - this.lag_sample_interval);","if (thislag > (60 * 60))","\"more than an hour, probably the lag sampler stopped\";","this.current_lag = 0;","else","samples = this.lag_samples;","sum = 0;","cnt = 0;","for x in (listdelete(samples, 1))","sum = sum + x;","cnt = cnt + 1;","endfor","this.current_lag = max(thislag, samples[1], samples[2], sum / cnt);","endif","fork (15)","this:sample_lag();","endfork","this.last_lag_sample = time();"]},{"name":"is_lagging","owner":2,"perms":173,"preposition":-1,"code":["return this:current_lag() > this.lag_cutoff;"]},{"name":"max_connections","owner":2,"perms":173,"preposition":-1,"code":["max = this.max_connections;","if (typeof(max) == LIST)","if (this:is_lagging())","max = max[1];","else","max = max[2];","endif","endif","return max;"]},{"name":"request_character","owner":2,"perms":173,"preposition":-1,"code":["\"request_character(player, name, address)\";","\"return true if succeeded\";","if (!caller_perms().wizard)","return E_PERM;","endif","{who, name, address} = args;","connection = $string_utils:connection_hostname(connection_name(who));","if (reason = $wiz_utils:check_player_request(name, address, connection))","prefix = \"\";","if (reason[1] == \"-\")","reason = reason[2..$];","prefix = \"Please\";","else","prefix = \"Please try again, or, to register another way,\";","endif","notify(who, reason);","msg = tostr(prefix, \" send mail to \", $login.registration_address, \", with the character name you want.\");","for l in ($generic_editor:fill_string(msg, 70))","notify(who, l);","endfor","return 0;","endif","if (lines = $no_one:eval_d(\"$local.help.(\\\"multiple-characters\\\")\")[2])","notify(who, \"Remember, in general, only one character per person is allowed.\");","notify(who, tostr(\"Do you already have a \", $network.moo_name, \" character? [enter `yes' or `no']\"));","answer = read(who);","if (answer == \"yes\")","notify(who, \"Process terminated *without* creating a character.\");","return 0;","elseif (answer != \"no\")","return notify(who, tostr(\"Please try again; when you get this question, answer `yes' or `no'. You answered `\", answer, \"'\"));","endif","notify(who, \"For future reference, do you want to see the full policy (from `help multiple-characters'?\");","notify(who, \"[enter `yes' or `no']\");","if (read(who) == \"yes\")","for x in (lines)","for y in ($generic_editor:fill_string(x, 70))","notify(who, y);","endfor","endfor","endif","endif","notify(who, tostr(\"A character named `\", name, \"' will be created.\"));","notify(who, tostr(\"A random password will be generated, and e-mailed along with\"));","notify(who, tostr(\" an explanatory message to: \", address));","notify(who, tostr(\" [Please double-check your email address and answer `no' if it is incorrect.]\"));","notify(who, \"Is this OK? [enter `yes' or `no']\");","if (read(who) != \"yes\")","notify(who, \"Process terminated *without* creating a character.\");","return 0;","endif","if (!$network.active)","$mail_agent:send_message(this.owner, $registration_db.registrar, \"Player request\", {\"Player request from \" + connection, \":\", \"\", ((\"@make-player \" + name) + \" \") + address});","notify(who, tostr(\"Request for new character \", name, \" email address '\", address, \"' accepted.\"));","notify(who, tostr(\"Please be patient until the registrar gets around to it.\"));","notify(who, tostr(\"If you don't get email within a week, please send regular\"));","notify(who, tostr(\"  email to: \", $login.registration_address, \".\"));","elseif ($player_db.frozen)","notify(who, \"Sorry, can't create any new players right now.  Try again in a few minutes.\");","else","new = $wiz_utils:make_player(name, address);","password = new[2];","new = new[1];","notify(who, tostr(\"Character \", name, \" (\", new, \") created.\"));","notify(who, tostr(\"Mailing password to \", address, \"; you should get the mail very soon.\"));","notify(who, tostr(\"If you do not get it, please do NOT request another character.\"));","notify(who, tostr(\"Instead, send regular email to \", $login.registration_address, \",\"));","notify(who, tostr(\"with the name of the character you requested.\"));","$mail_agent:send_message(this.owner, $new_player_log, tostr(name, \" (\", new, \")\"), {address, tostr(\" Automatically created at request of \", valid(player) ? player.name | \"unconnected player\", \" from \", connection, \".\")});","$wiz_utils:send_new_player_mail(tostr(\"Someone connected from \", connection, \" at \", ctime(), \" requested a character on \", $network.moo_name, \" for email address \", address, \".\"), name, address, new, password);","return 1;","endif"]},{"name":"req*uest @req*uest","owner":2,"perms":93,"preposition":-1,"code":["if ((caller != #0) && (caller != this))","return E_PERM;","endif","\"must be #0:do_login_command\";","if (!this.request_enabled)","for line in ($generic_editor:fill_string(this:registration_string(), 70))","notify(player, line);","endfor","elseif ((length(args) != 3) || (args[2] != \"for\"))","notify(player, tostr(\"Usage:  \", verb, \" <new-player-name> for <email-address>\"));","elseif ($login:request_character(player, args[1], args[3]))","boot_player(player);","endif"]},{"name":"h*elp @h*elp","owner":2,"perms":93,"preposition":-1,"code":["if ((caller != #0) && (caller != this))","return E_PERM;","else","msg = this.help_message;","for line in ((typeof(msg) == LIST) ? msg | {msg})","if (typeof(line) == STR)","notify(player, line);","endif","endfor","return 0;","endif"]},{"name":"maybe_print_lag","owner":2,"perms":173,"preposition":-1,"code":["if ((caller == this) || (caller_perms() == player))","if (this.print_lag)","lag = this:current_lag();","if (lag > 1)","lagstr = tostr(\"approximately \", lag, \" seconds\");","elseif (lag == 1)","lagstr = \"approximately 1 second\";","else","lagstr = \"low\";","endif","notify(player, tostr(\"The lag is \", lagstr, \"; there \", ((l = length(connected_players())) == 1) ? \"is \" | \"are \", l, \" connected.\"));","endif","endif"]},{"name":"current_lag","owner":2,"perms":173,"preposition":-1,"code":["return this.current_lag;"]},{"name":"maybe_limit_commands","owner":2,"perms":173,"preposition":-1,"code":["\"This limits the number of commands that can be issued from the login prompt to prevent haywire login programs from lagging the MOO.\";","\"$login.current_connections has the current player id's of people at the login prompt.\";","\"$login.current_numcommands has the number of commands they have issued at the prompt so far.\";","\"$login.max_numcommands has the maximum number of commands they may try before being booted.\";","if (!caller_perms().wizard)","return E_PERM;","else","if (iconn = player in this.current_connections)","knocks = this.current_numcommands[iconn] = this.current_numcommands[iconn] + 1;","else","this.current_connections = {@this.current_connections, player};","this.current_numcommands = {@this.current_numcommands, 1};","knocks = 1;","\"...sweep idle connections...\";","for p in (this.current_connections)","if (typeof(`idle_seconds(p) ! ANY') == ERR)","n = p in this.current_connections;","this.current_connections = listdelete(this.current_connections, n);","this.current_numcommands = listdelete(this.current_numcommands, n);","endif","endfor","endif","if (knocks > this.max_numcommands)","notify(player, \"Sorry, too many commands issued without connecting.\");","boot_player(player);","return 1;","else","return 0;","endif","endif"]},{"name":"server_started","owner":2,"perms":173,"preposition":-1,"code":["\"Called by #0:server_started when the server restarts.\";","if (caller_perms().wizard)","this.lag_samples = {0, 0, 0, 0, 0};","this.downtimes = {{time(), this.last_lag_sample}, @this.downtimes[1..min($, 100)]};","this.intercepted_players = this.intercepted_actions = {};","endif"]},{"name":"uptime_since","owner":2,"perms":173,"preposition":-1,"code":["\"uptime_since(time): How much time has LambdaMOO been up since `time'\";","since = args[1];","up = time() - since;","for x in (this.downtimes)","if (x[1] < since)","\"downtime predates when we're asking about\";","return up;","endif","\"since the server was down between x[2] and x[1], don't count it as uptime\";","up = up - (x[1] - max(x[2], since));","endfor","return up;"]},{"name":"count_bg_players","owner":2,"perms":173,"preposition":-1,"code":["caller_perms().wizard || $error:raise(E_PERM);","now = time();","tasks = queued_tasks();","sum = 0;","for t in (tasks)","delay = t[2] - now;","interval = (delay <= 0) ? 1 | (delay * 2);","\"SUM is measured in hundredths of a player for the moment...\";","(delay <= 300) && (sum = sum + (2000 / interval));","endfor","count = sum / 100;","return count;"]},{"name":"blacklisted_temp graylisted_temp redlisted_temp spooflisted_temp","owner":2,"perms":173,"preposition":-1,"code":["\":blacklisted_temp(hostname) => is hostname on the .blacklist...\";","\":graylisted_temp(hostname)  => is hostname on the .graylist...\";","\":redlisted_temp(hostname)   => is hostname on the .redlist...\";","\":spooflisted_temp(hostname) => is hostname on the .spooflist...\";","\"\";","\"... and the time limit hasn't run out.\";","lname = this:listname(verb);","sitelist = this.(\"temporary_\" + lname);","if (!caller_perms().wizard)","return E_PERM;","elseif (entry = $list_utils:assoc(hostname = args[1], sitelist[1]))","return this:templist_expired(lname, @entry);","elseif (entry = $list_utils:assoc(hostname, sitelist[2]))","return this:templist_expired(lname, @entry);","elseif ($site_db:domain_literal(hostname))","for lit in (sitelist[1])","if ((index(hostname, lit[1]) == 1) && ((hostname + \".\")[length(lit[1]) + 1] == \".\"))","return this:templist_expired(lname, @lit);","endif","endfor","else","for dom in (sitelist[2])","if (index(dom[1], \"*\"))","\"...we have a wildcard; let :match_string deal with it...\";","if ($string_utils:match_string(hostname, dom[1]))","return this:templist_expired(lname, @dom);","endif","else","\"...tail of hostname ...\";","if ((r = rindex(hostname, dom[1])) && (((\".\" + hostname)[r] == \".\") && (((r - 1) + length(dom[1])) == length(hostname))))","return this:templist_expired(lname, @dom);","endif","endif","endfor","endif","return 0;"]},{"name":"templist_expired","owner":2,"perms":173,"preposition":-1,"code":["\"check to see if duration has expired on temporary_<colorlist>. Removes entry if so, returns true if still <colorlisted>\";","\":(listname, hostname, start time, duration)\";","{lname, hname, start, duration} = args;","if (!caller_perms().wizard)","return E_PERM;","endif","if (this:uptime_since(start) > duration)","this:(lname + \"_remove_temp\")(hname);","return 0;","else","return 1;","endif"]},{"name":"temp_newt_registration_string","owner":2,"perms":173,"preposition":-1,"code":["return (\"Your character is unavailable for another \" + $time_utils:english_time(args[1])) + \".\";"]},{"name":"add_interception","owner":36,"perms":173,"preposition":-1,"code":["(caller == this) || raise(E_PERM);","{who, verbname, @arguments} = args;","(who in this.intercepted_players) && raise(E_INVARG, \"Player already has an interception set.\");","this.intercepted_players = {@this.intercepted_players, who};","this.intercepted_actions = {@this.intercepted_actions, {verbname, @arguments}};","return 1;"]},{"name":"delete_interception","owner":36,"perms":173,"preposition":-1,"code":["(caller == this) || raise(E_PERM);","{who} = args;","if (loc = who in this.intercepted_players)","this.intercepted_players = listdelete(this.intercepted_players, loc);","this.intercepted_actions = listdelete(this.intercepted_actions, loc);","return 1;","else","\"raise an error?  nah.\";","return 0;","endif"]},{"name":"interception","owner":36,"perms":173,"preposition":-1,"code":["(caller == this) || raise(E_PERM);","{who} = args;","return (loc = who in this.intercepted_players) ? this.intercepted_actions[loc] | 0;"]},{"name":"intercepted_password","owner":2,"perms":173,"preposition":-1,"code":["(caller == #0) || raise(E_PERM);","this:delete_interception(player);","set_connection_option(player, \"client-echo\", 1);","notify(player, \"\");","try","{candidate, ?password = \"\"} = args;","except (E_ARGS)","return 0;","endtry","return this:connect(tostr(candidate), password);"]},{"name":"do_out_of_band_command doobc","owner":36,"perms":173,"preposition":-1,"code":["\"This is where oob handlers need to be put to handle oob commands issued prior to assigning a connection to a player object.  Right now it simply returns.\";","return;"]},{"name":"check_for_checkpoint","owner":2,"perms":173,"preposition":-1,"code":["if (this.checkpoint_in_progress)","line = \"***************************************************************************\";","notify(player, \"\");","notify(player, \"\");","notify(player, line);","notify(player, line);","notify(player, \"****\");","notify(player, \"****  NOTICE:  The server is very slow now.\");","notify(player, \"****           The database is being saved to disk.\");","notify(player, \"****\");","notify(player, line);","notify(player, line);","notify(player, \"\");","notify(player, \"\");","endif"]},{"name":"@*","owner":2,"perms":173,"preposition":-1,"code":["\"{last_huh}  @<msg_name> <object> is [<text>]\";","\"If <text> is given calls <object>:set_message(<msg_name>,<text>),\";","\"otherwise prints the value of the specified message property\";","set_task_perms(caller_perms());","nargs = length(args);","pos = \"is\" in args;","if (pos == 1)","player:notify(tostr(\"Usage:  \", verb, \" <object> is <message>\"));","return;","endif","dobjstr = $string_utils:from_list(args[1..pos - 1], \" \");","message = $string_utils:from_list(args[pos + 1..nargs], \" \");","msg_name = verb[2..$];","dobj = player:my_match_object(dobjstr);","if ($command_utils:object_match_failed(dobj, dobjstr))","\"... oh well ...\";","elseif (pos == nargs)","if (E_PROPNF == (get = `dobj.(msg_name + \"_msg\") ! ANY'))","player:notify(tostr(dobj.name, \" (\", dobj, \") has no \\\"\", msg_name, \"\\\" message.\"));","elseif (typeof(get) == ERR)","player:notify(tostr(get));","elseif (!get)","player:notify(\"Message is not set.\");","else","player:notify(tostr(\"The \\\"\", msg_name, \"\\\" message of \", dobj.name, \" (\", dobj, \"):\"));","player:notify(tostr(get));","endif","else","set = dobj:set_message(msg_name, message);","if (set)","if (typeof(set) == STR)","player:notify(set);","else","player:notify(tostr(\"You set the \\\"\", msg_name, \"\\\" message of \", dobj.name, \" (\", dobj, \").\"));","endif","elseif (set == E_PROPNF)","player:notify(tostr(dobj.name, \" (\", dobj, \") has no \\\"\", msg_name, \"\\\" message to set.\"));","elseif (typeof(set) == ERR)","player:notify(tostr(set));","else","player:notify(tostr(\"You clear the \\\"\", msg_name, \"\\\" message of \", dobj.name, \" (\", dobj, \").\"));","endif","endif"]},{"name":"give hand","owner":2,"perms":173,"preposition":-1,"code":["\"{last_huh}  give any to any\";","\"a give \\\"verb\\\" that works for non-$things.\";","set_task_perms(caller_perms());","if (((verb == \"give\") && (dobjstr == \"up\")) && (!prepstr))","player:tell(\"Try this instead: @quit\");","elseif (dobj == $nothing)","player:tell(\"What do you want to give?\");","elseif (iobj == $nothing)","player:tell(\"To whom/what do you want to give it?\");","elseif ($command_utils:object_match_failed(dobj, dobjstr) || $command_utils:object_match_failed(iobj, iobjstr))","\"...lose...\";","elseif (dobj.location != player)","player:tell(\"You don't have that!\");","elseif (iobj.location != player.location)","player:tell(\"I don't see \", iobj.name, \" here.\");","else","dobj:moveto(iobj);","if (dobj.location == iobj)","player:tell(\"You give \", dobj:title(), \" to \", iobj.name, \".\");","iobj:tell(player.name, \" gives you \", dobj:title(), \".\");","else","player:tell(\"Either that doesn't want to be given away or \", iobj.name, \" doesn't want it.\");","endif","endif"]},{"name":"get take","owner":2,"perms":173,"preposition":-1,"code":["\"{last_huh}  get/take any\";","\"a take \\\"verb\\\" that works for non-$things.\";","set_task_perms(caller_perms());","if (dobj == $nothing)","player:tell(verb, \" what?\");","elseif ($command_utils:object_match_failed(dobj, dobjstr))","\"...lose...\";","elseif (dobj.location == player)","player:tell(\"You already have that!\");","elseif (dobj.location != player.location)","player:tell(\"I don't see that here.\");","else","dobj:moveto(player);","if (dobj.location == player)","player:tell(\"Taken.\");","player.location:announce(player.name, \" takes \", dobj.name, \".\");","else","player:tell(\"You can't pick that up.\");","endif","endif"]},{"name":"drop throw","owner":2,"perms":173,"preposition":-1,"code":["\"{last_huh}  drop/throw any\";","\"a drop \\\"verb\\\" that works for non-$things.\";","set_task_perms(caller_perms());","if (dobj == $nothing)","player:tell(verb, \" what?\");","elseif ($command_utils:object_match_failed(dobj, dobjstr))","\"...lose...\";","elseif (dobj.location != player)","player:tell(\"You don't have that.\");","elseif (!player.location:acceptable(dobj))","player:tell(\"You can't drop that here.\");","else","dobj:moveto(player.location);","if (dobj.location == player.location)","player:tell_lines((verb[1] == \"d\") ? \"Dropped.\" | \"Thrown.\");","player.location:announce(player.name, (verb[1] == \"d\") ? \" dropped \" | \" threw away \", dobj.name, \".\");","else","player:tell_lines(\"You can't seem to drop that here.\");","endif","endif"]},{"name":"enter","owner":2,"perms":173,"preposition":-1,"code":["\":enter(who,islogin,time,site)\";","\"adds an entry to the connection log for a given guest (caller).\";","if ($object_utils:isa(caller, $guest))","$guest_log.connections = {{caller, @args}, @$guest_log.connections[1..min($guest_log.max_entries, $)]};","else","return E_PERM;","endif"]},{"name":"last","owner":2,"perms":173,"preposition":-1,"code":["\":last([n,[guest_list]])\";","\"print list of the last n entries in the guest log\";","\" (use n=0 if you want all entries)\";","\" optional second arg limits listing to the specified guest(s)\";","set_task_perms(caller_perms());","{?howmany = 0, ?which = 0} = args;","howmany = min(howmany || $maxint, length($guest_log.connections));","if (!caller_perms().wizard)","player:notify(\"Sorry.\");","else","current = {};","listing = {};","last = 0;","for c in ($guest_log.connections[1..howmany])","if (which && (!(c[1] in which)))","elseif (c[2])","\"...login...\";","if (a = $list_utils:assoc(c[1], current))","listing[a[2]][3] = c[3];","current = setremove(current, a);","else","listing = {@listing, {c[1], c[4], c[3], $object_utils:connected(c[1]) ? -idle_seconds(c[1]) | 1}};","last = last + 1;","endif","else","\"...logout...\";","listing = {@listing, {c[1], c[4], 0, c[3]}};","last = last + 1;","if (i = $list_utils:iassoc(c[1], current))","current[i][2] = last;","else","current = {@current, {c[1], last}};","endif","endif","$command_utils:suspend_if_needed(2);","endfor","su = $string_utils;","player:notify(su:left(su:left(su:left(\"Guest\", 20) + \"Connected\", 36) + \"Idle/Disconn.\", 52) + \"From\");","player:notify(su:left(su:left(su:left(\"-----\", 20) + \"---------\", 36) + \"-------------\", 52) + \"----\");","for l in (listing)","on = l[3] ? (ct = ctime(l[3]))[1..3] + ct[9..19] | \"earlier\";","off = (l[4] > 0) ? (ct = ctime(l[4]))[1..3] + ct[9..19] | (\"  \" + $string_utils:from_seconds(-l[4]));","player:notify(su:left(su:left(su:right(tostr(strsub(l[1].name, \"uest\", \".\"), \" (\", l[1], \")  \"), -20) + on, 36) + off, 52) + l[2]);","$command_utils:suspend_if_needed(2);","endfor","endif"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","pass(@args);","this.connections = {};","endif"]},{"name":"find","owner":2,"perms":173,"preposition":-1,"code":["\":find(guest_id,time)\";","\" => site name of guest logged in at that time\";","\" => 0 if not logged in\";","\" => E_NACC if this is earlier than the earliest guest recorded\";","set_task_perms(caller_perms());","{who, when} = args;","if (!caller_perms().wizard)","raise(E_PERM);","else","found = (who in connected_players()) ? $string_utils:connection_hostname(who.last_connect_place) | 0;","for c in ($guest_log.connections)","if (c[3] < when)","return found;","elseif (c[1] != who)","\"... different guest...\";","elseif (c[2])","\"...login...\";","if (c[3] == when)","return found;","endif","found = 0;","else","\"...logout...\";","found = c[4];","endif","endfor","return E_NACC;","endif"]},{"name":"length","owner":36,"perms":173,"preposition":-1,"code":["\":length(tree) => number of leaves in tree.\";","return args[1] ? args[1][2] | 0;"]},{"name":"find_nth","owner":36,"perms":173,"preposition":-1,"code":["\":find_nth(tree,n) => nth leaf of tree.  Assumes n in [1..tree[2]]\";","return this:_find_nth(caller, @args);"]},{"name":"find_ord","owner":36,"perms":173,"preposition":-1,"code":["\":_find_ord(tree,n,comp) \";","\" => index of rightmost leaf for which :(comp)(n,:_ord(leaf)) is false.\";","\"returns 0 if true for all leaves.\";","return args[1] ? this:_find_ord(caller, @args) | 0;"]},{"name":"set_nth","owner":36,"perms":173,"preposition":-1,"code":["\":set_nth(tree,n,value) => tree\";","\"modifies tree so that nth leaf == value\";","if (((n = args[2]) < 1) || ((!(tree = args[1])) || (tree[2] < n)))","return E_RANGE;","else","this:_set_nth(caller, @args);","return (n != 1) ? tree | listset(tree, caller:_ord(args[3]), 3);","endif"]},{"name":"kill","owner":36,"perms":173,"preposition":-1,"code":["\":kill(tree[,leafverb]) deletes tree and _kills all of the nodes that it uses.\";","\"if leafverb is given, caller:leafverb is called on all leaves in tree.\";","if (tree = args[1])","lverb = {@args, \"\"}[2];","this:_skill(caller, (typeof(tree) == LIST) ? tree[1] | tree, lverb);","endif","\"... otherwise nothing to do...\";"]},{"name":"insert_after insert_before","owner":36,"perms":173,"preposition":-1,"code":["\":insert_after(tree,subtree,n)\";","\":insert_before(tree,subtree,n)\";","\"  inserts subtree after (before) the nth leaf of tree,\";","\"  returning the resulting tree.\";","subtree = args[2];","if (tree = args[1])","if (subtree)","where = args[3] - (verb == \"insert_before\");","if (where <= 0)","return this:_merge(caller, subtree, tree);","elseif (where >= tree[2])","return this:_merge(caller, tree, subtree);","else","s = this:_split(caller, caller:_get(tree[1])[1], where, tree);","return this:_merge(caller, this:_merge(caller, s[1], subtree), s[2]);","endif","else","return tree;","endif","else","return subtree;","endif"]},{"name":"extract_range","owner":36,"perms":173,"preposition":-1,"code":["\":extract_range(tree,first,last) => {newtree,extraction}\";","return this:_extract(caller, @args);"]},{"name":"delete_range","owner":36,"perms":173,"preposition":-1,"code":["\":delete_range(tree,first,last[,leafkill]) => newtree\";","extract = this:_extract(caller, @args);","if (die = extract[2])","this:_skill(caller, die[1], {@args, \"\"}[4]);","endif","return extract[1];"]},{"name":"keep_range","owner":36,"perms":173,"preposition":-1,"code":["\":keep_range(tree,first,last[,leafkill]) => range\";","extract = this:_extract(caller, @args);","if (die = extract[1])","this:_skill(caller, die[1], {@args, \"\"}[4]);","endif","return extract[2];"]},{"name":"insert_last","owner":36,"perms":173,"preposition":-1,"code":["\":insert_last(tree,insert) => newtree\";","\"insert a new leaf to be inserted at the righthand end of the tree\";","tree = args[1];","insert = args[2];","if (!tree)","return {caller:_make(0, {insert}), 1, caller:_ord(insert)};","endif","hgt = caller:_get(tree[1]);","rspine = {{tree, plen = length(kids = hgt[2])}};","for i in [1..hgt[1]]","parent = kids[plen];","kids = caller:_get(parent[1])[2];","plen = length(kids);","rspine = {{parent, plen}, @rspine};","endfor","iord = caller:_ord(insert);","for h in [1..length(rspine)]","\"... tree is the plen'th (rightmost) child of parent...\";","if (rspine[h][2] < this.maxfanout)","parent = rspine[h][1];","hgp = caller:_get(parent[1]);","caller:_put(parent[1], @listset(hgp, {@hgp[2], insert}, 2));","for p in (rspine[h + 1..length(rspine)])","rkid = listset(parent, parent[2] + 1, 2);","parent = p[1];","hgp = caller:_get(parent[1]);","caller:_put(parent[1], @listset(hgp, listset(hgp[2], rkid, p[2]), 2));","endfor","return listset(tree, tree[2] + 1, 2);","endif","insert = {caller:_make(h - 1, {insert}), 1, iord};","endfor","return {caller:_make(length(rspine), {tree, insert}), tree[2] + 1, tree[3]};"]},{"name":"start","owner":36,"perms":173,"preposition":-1,"code":["\":start(tree,first,last) => {list of leaf nodes, @handle}\";","\"handle is of the form {{node,next,size}...}\";","if (tree = args[1])","before = max(0, args[2] - 1);","howmany = min(args[3], tree[2]) - before;","if (howmany <= 0)","return {};","else","spine = {};","for h in [1..caller:_get(tree[1])[1]]","ik = this:_listfind_nth(kids = caller:_get(tree[1])[2], before);","newh = kids[ik[1]][2] - ik[2];","if (newh < howmany)","spine = {{tree[1], ik[1] + 1, howmany - newh}, @spine};","howmany = newh;","endif","tree = kids[ik[1]];","before = ik[2];","endfor","return {caller:_get(tree[1])[2][before + 1..before + howmany], @spine};","endif","else","return {};","endif"]},{"name":"next","owner":36,"perms":173,"preposition":-1,"code":["\":next(@handle) => {list of more leaf nodes, @newhandle}\";","if (args)","spine = listdelete(args, 1);","node = args[1][1];","n = args[1][2];","size = args[1][3];","for h in [1..caller:_get(node)[1]]","nnode = caller:_get(node)[2][n];","if (size > nnode[2])","spine = {{node, n + 1, size - nnode[2]}, @spine};","size = nnode[2];","endif","n = 1;","node = nnode[1];","endfor","test = caller:_get(node);","return {test[2][n..size], @spine};","else","return {};","endif"]},{"name":"_find_nth","owner":36,"perms":173,"preposition":-1,"code":["\":_find_nth(home,tree,n) => nth leaf of tree.\";","\"...Assumes n in [1..tree[2]]\";","if (caller != this)","return E_PERM;","endif","{home, tree, n} = args;","if ((p = home:_get(tree[1]))[1])","for k in (p[2])","if (n > k[2])","n = n - k[2];","else","return this:_find_nth(home, k, n);","endif","endfor","return E_RANGE;","else","return p[2][n];","endif"]},{"name":"_find_ord","owner":36,"perms":173,"preposition":-1,"code":["\":_find_ord(home,tree,n,less_than) \";","\" => index of rightmost leaf for which :(less_than)(n,:_ord(leaf)) is false.\";","\"returns 0 if true for all leaves.\";","if (caller != this)","return E_PERM;","endif","{home, tree, n, less_than} = args;","if ((p = home:_get(tree[1]))[1])","sz = tree[2];","for i in [-length(p[2])..-1]","k = p[2][-i];","sz = sz - k[2];","if (!this:_call(home, less_than, n, k[3]))","return sz + this:_find_ord(home, k, n, less_than);","endif","endfor","return 0;","else","for i in [1..r = length(p[2])]","if (this:_call(home, less_than, n, home:_ord(p[2][i])))","return i - 1;","endif","endfor","return r;","endif"]},{"name":"_set_nth","owner":36,"perms":173,"preposition":-1,"code":["\":_set_nth(home,tree,n,value) => tree[n] = value\";","\"Assumes n in [1..tree[2]]\";","if (caller != this)","return E_PERM;","endif","{home, tree, n, value} = args;","if ((p = home:_get(tree[1]))[1])","ik = this:_listfind_nth(p[2], n - 1);","this:_set_nth(home, p[2][ik[1]], ik[2] + 1, value);","if (!ik[2])","p[2][ik[1]][3] = home:_ord(value);","home:_put(tree[1], @p);","endif","else","p[2][n] = value;","home:_put(tree[1], @p);","endif"]},{"name":"_skill","owner":36,"perms":173,"preposition":-1,"code":["\":_skill(home,node,kill_leaf)\";","\"home:_kill's node and all descendants, home:(kill_leaf)'s all leaves\";","if (caller != this)","return E_PERM;","endif","{home, node, kill_leaf} = args;","try","{height, subtrees} = home:_get(node) || {0, {}};","except (E_PROPNF)","return;","endtry","if (height)","for kid in (subtrees)","this:_skill(home, kid[1], kill_leaf);","endfor","elseif (kill_leaf)","for kid in (subtrees)","this:_call(home, kill_leaf, kid);","endfor","endif","home:_kill(node);"]},{"name":"_extract","owner":36,"perms":173,"preposition":-1,"code":["\":_extract(home,tree,first,last) => {newtree,extraction}\";","if (caller != this)","return E_PERM;","endif","home = args[1];","if (!(tree = args[2]))","return {{}, {}};","endif","before = max(0, args[3] - 1);","end = min(tree[2], args[4]);","if ((end <= 0) || (before >= end))","return {tree, {}};","endif","height = home:_get(tree[1])[1];","if (end < tree[2])","r = this:_split(home, height, end, tree);","if (before)","l = this:_split(home, height, before, r[1]);","extract = l[2];","newtree = this:_merge(home, l[1], r[2]);","else","extract = r[1];","newtree = r[2];","endif","elseif (before)","l = this:_split(home, height, before, tree);","extract = l[2];","newtree = l[1];","else","return {{}, tree};","endif","return {this:_scrunch(home, newtree), this:_scrunch(home, extract)};"]},{"name":"_merge","owner":36,"perms":173,"preposition":-1,"code":["\"_merge(home,ltree,rtree) => newtree\";","\"assumes ltree and rtree to be nonempty.\";","if (caller != this)","return E_PERM;","endif","{home, lnode, rnode} = args;","lh = home:_get(lnode[1])[1];","rh = home:_get(rnode[1])[1];","if (lh > rh)","return this:_rmerge(home, lnode, rnode);","endif","for h in [lh + 1..rh]","lnode[1] = home:_make(h, {lnode});","endfor","m = this:_smerge(home, rh, lnode, rnode);","return (length(m) <= 1) ? m[1] | {home:_make(rh + 1, m), m[1][2] + m[2][2], m[1][3]};"]},{"name":"_smerge","owner":36,"perms":173,"preposition":-1,"code":["\"_smerge(home, height, ltree, rtree) =>{ltree[,rtree]}\";","\"assumes ltree and rtree are at the given height.\";","\"merges the trees if the combined number of children is <= maxfanout\";","\"otherwise returns two trees where ltree is guaranteed minfanout children and rtree is guaranteed the minimum of minfanout and however many children it started with.\";","if (caller != this)","return E_PERM;","endif","{home, height, ltree, rtree} = args;","llen = length(lkids = home:_get(ltree[1])[2]);","rlen = length(rkids = home:_get(rtree[1])[2]);","if (height)","m = this:_smerge(home, height - 1, lkids[llen], rkids[1]);","mlen = length(mkids = {@listdelete(lkids, llen), @m, @listdelete(rkids, 1)});","if (mlen <= this.maxfanout)","home:_put(ltree[1], height, mkids);","home:_kill(rtree[1]);","ltree[2] = ltree[2] + rtree[2];","return {ltree};","else","S = max(llen - 1, (mlen + 1) / 2);","home:_put(ltree[1], height, mkids[1..S]);","home:_put(rtree[1], height, mkids[S + 1..$]);","xfer = -lkids[llen][2];","for k in (mkids[llen..S])","xfer = xfer + k[2];","endfor","ltree[2] = ltree[2] + xfer;","rtree[2] = rtree[2] - xfer;","rtree[3] = mkids[S + 1][3];","return {ltree, rtree};","endif","elseif ((llen * 2) >= this.maxfanout)","return {ltree, rtree};","elseif (this.maxfanout < (llen + rlen))","T = ((rlen - llen) + 1) / 2;","home:_put(ltree[1], 0, {@lkids, @rkids[1..T]});","home:_put(rtree[1], 0, rkids[T + 1..rlen]);","ltree[2] = ltree[2] + T;","rtree[2] = rtree[2] - T;","rtree[3] = home:_ord(rkids[T + 1]);","return {ltree, rtree};","else","home:_put(ltree[1], 0, {@lkids, @rkids});","home:_kill(rtree[1]);","ltree[2] = ltree[2] + rtree[2];","return {ltree};","endif"]},{"name":"_split","owner":36,"perms":173,"preposition":-1,"code":["\"_split(home, height,lmax,ltree[,@rtrees]}) => {ltree,[mtree,]@rtrees}\";","\"ltree is split after the lmax'th leaf, the righthand portion grafted onto the leftmost of the rtrees, if possible.  Otherwise we create a new tree mtree, stealing from rtrees[1] if necessary.\";","\"Assumes 1<=lmax<ltree[2]\";","if (caller != this)","return E_PERM;","endif","{home, height, lmax, ltree, @rtrees} = args;","llen = length(lkids = home:_get(ltree[1])[2]);","rlen = length(rkids = rtrees ? home:_get(rtrees[1][1])[2] | {});","if (height)","ik = this:_listfind_nth(lkids, lmax);","if (ik[2])","llast = ik[1];","m = this:_split(home, height - 1, ik[2], lkids[llast], @lkids[llast + 1..llen], @rkids);","lkids[llast] = m[1];","mkids = listdelete(m, 1);","else","llast = ik[1] - 1;","mkids = {@lkids[ik[1]..llen], @rkids};","endif","home:_put(ltree[1], height, lkids[1..llast]);","mlen = length(mkids);","if ((((mlen - rlen) * 2) >= this.maxfanout) || (!rtrees))","\"...residue left over from splitting ltree can stand by itself...\";","return {listset(ltree, lmax, 2), {home:_make(height, mkids[1..mlen - rlen]), ltree[2] - lmax, mkids[1][3]}, @rtrees};","elseif (mlen <= this.maxfanout)","\"...residue left over from splitting ltree fits in rtrees[1]...\";","home:_put(rtrees[1][1], height, mkids);","rtrees[1][2] = (ltree[2] - lmax) + rtrees[1][2];","rtrees[1][3] = mkids[1][3];","return {listset(ltree, lmax, 2), @rtrees};","else","\"...need to steal from rtrees[1]...\";","if (llast < llen)","msize = ltree[2] - lmax;","R = (mlen - rlen) + 1;","else","msize = 0;","R = 1;","endif","for k in (mkids[R..mlen / 2])","msize = msize + k[2];","endfor","home:_put(rtrees[1][1], height, mkids[(mlen / 2) + 1..mlen]);","rtrees[1][2] = (rtrees[1][2] + ltree[2]) - (lmax + msize);","rtrees[1][3] = mkids[(mlen / 2) + 1][3];","return {listset(ltree, lmax, 2), {home:_make(height, mkids[1..mlen / 2]), msize, mkids[1][3]}, @rtrees};","endif","else","home:_put(ltree[1], 0, lkids[1..lmax]);","if ((((llen - lmax) * 2) >= this.maxfanout) || (!rtrees))","\"...residue left over from splitting ltree can stand by itself...\";","return {listset(ltree, lmax, 2), {home:_make(0, lkids[lmax + 1..llen]), llen - lmax, home:_ord(lkids[lmax + 1])}, @rtrees};","elseif ((mlen = (rlen + llen) - lmax) <= this.maxfanout)","\"...residue left over from splitting ltree fits in rtrees[1]...\";","home:_put(rtrees[1][1], 0, {@lkids[lmax + 1..llen], @rkids});","rtrees[1][2] = mlen;","rtrees[1][3] = home:_ord(lkids[lmax + 1]);","return {listset(ltree, lmax, 2), @rtrees};","else","\"...need to steal from rtrees[1]...\";","home:_put(rtrees[1][1], 0, rkids[(R = ((rlen - llen) + lmax) / 2) + 1..rlen]);","rtrees[1][2] = (mlen + 1) / 2;","rtrees[1][3] = home:_ord(rkids[R + 1]);","return {listset(ltree, lmax, 2), {home:_make(0, {@lkids[lmax + 1..llen], @rkids[1..R]}), mlen / 2, home:_ord(lkids[lmax + 1])}, @rtrees};","endif","endif"]},{"name":"_rmerge","owner":36,"perms":173,"preposition":-1,"code":["\":_rmerge(home, tree, insertree) => newtree \";","\"(newtree is tree with insertree appended to the right)\";","\"insertree is assumed to be of height < tree\";","if (caller != this)","return E_PERM;","endif","{home, tree, insert} = args;","if (!tree)","return insert;","elseif (!insert)","return tree;","endif","iheight = home:_get(insert[1])[1];","rspine = {};","for i in [iheight + 1..home:_get(tree[1])[1]]","kids = home:_get(tree[1])[2];","tlen = length(kids);","rspine = {{tree, tlen}, @rspine};","tree = kids[tlen];","endfor","isize = insert[2];","m = this:_smerge(home, iheight, tree, insert);","for h in [1..length(rspine)]","plen = rspine[h][2];","parent = rspine[h][1];","hgp = home:_get(parent[1]);","if (((length(m) - 1) + plen) > this.maxfanout)","home:_put(parent[1], @listset(hgp, listset(hgp[2], m[1], plen), 2));","parent[2] = (parent[2] + isize) - m[2][2];","m = {parent, listset(m[2], home:_make(h + iheight, {m[2]}), 1)};","else","home:_put(parent[1], @listset(hgp, {@hgp[2][1..plen - 1], @m}, 2));","for p in (rspine[h + 1..length(rspine)])","parent[2] = parent[2] + isize;","tree = parent;","parent = p[1];","hgp = home:_get(parent[1]);","home:_put(parent[1], @listset(hgp, listset(hgp[2], tree, p[2]), 2));","endfor","return listset(parent, parent[2] + isize, 2);","endif","endfor","return {home:_make((length(rspine) + iheight) + 1, m), m[1][2] + m[2][2], m[1][3]};"]},{"name":"_scrunch","owner":36,"perms":173,"preposition":-1,"code":["\":_scrunch(home,tree) => newtree\";","\"decapitates single-child nodes from the top of the tree, returns new root.\";","if (caller != this)","return E_PERM;","endif","if (tree = args[2])","home = args[1];","while ((n = home:_get(tree[1]))[1] && (length(n[2]) == 1))","home:_kill(tree[1]);","tree = n[2][1];","endwhile","endif","return tree;"]},{"name":"_listfind_nth","owner":36,"perms":173,"preposition":-1,"code":["\"_listfind_nth(nodelist,key) => {i,k} where i is the smallest i such that the sum of the first i elements of intlist is > key, and k==key - sum(first i-1 elements).\";","\"1 <= i <= length(intlist)+1\";","{lst, key} = args;","for i in [1..length(lst)]","key = key - lst[i][2];","if (0 > key)","return {i, key + lst[i][2]};","endif","endfor","return {length(lst) + 1, key};"]},{"name":"_insertfirst","owner":36,"perms":173,"preposition":-1,"code":["if (caller != this)","return E_PERM;","endif"]},{"name":"debug","owner":36,"perms":173,"preposition":-1,"code":["return $perm_utils:controls(caller_perms(), this) ? this:(args[1])(@listdelete(args, 1)) | E_PERM;"]},{"name":"_call","owner":2,"perms":173,"preposition":-1,"code":["\":_call(home,verb,@vargs) calls home:verb(@vargs) with $no_one's perms\";","set_task_perms($no_one);","if (caller != this)","raise(E_PERM);","endif","{home, vb, @vargs} = args;","return home:(vb)(@vargs);"]},{"name":"_genprop","owner":36,"perms":173,"preposition":-1,"code":["gp = this._genprop;","ngp = \"\";","for i in [1..length(gp)]","if (gp[i] != \"z\")","ngp = (ngp + \"bcdefghijklmnopqrstuvwxyz\"[index(\"abcdefghijklmnopqrstuvwxy\", gp[i])]) + gp[i + 1..length(gp)];","return \" \" + (this._genprop = ngp);","endif","ngp = ngp + \"a\";","endfor","return \" \" + (this._genprop = ngp + \"a\");"]},{"name":"_make","owner":2,"perms":173,"preposition":-1,"code":["\":_make(...) => new node with value {...}\";","if (!(caller in {this._mgr, this}))","return E_PERM;","endif","prop = this:_genprop();","`add_property(this, prop, args, {this.mowner, \"\"}) ! ANY';","return prop;"]},{"name":"_kill","owner":2,"perms":173,"preposition":-1,"code":["\":_kill(node) destroys the given node.\";","if (!(caller in {this, this._mgr}))","return E_PERM;","endif","`delete_property(this, args[1]) ! ANY';"]},{"name":"_get","owner":36,"perms":173,"preposition":-1,"code":["return (caller == this._mgr) ? `this.(args[1]) ! ANY' | E_PERM;"]},{"name":"_put","owner":36,"perms":173,"preposition":-1,"code":["return (caller == this._mgr) ? this.(args[1]) = listdelete(args, 1) | E_PERM;"]},{"name":"_ord","owner":36,"perms":173,"preposition":-1,"code":["return args[1][2..3];"]},{"name":"_makemsg","owner":36,"perms":173,"preposition":-1,"code":["\":_makemsg(ord,msg) => leafnode for msg\";","\"msg = $mail_agent:__convert_new(@args[2])\";","msg = args[2];","if (caller != this)","return E_PERM;","elseif (h = \"\" in msg)","return {this:_make(@msg[h + 1..$]), args[1], @msg[1..h - 1]};","else","return {0, args[1], @msg};","endif"]},{"name":"_killmsg","owner":36,"perms":173,"preposition":-1,"code":["if (caller != this._mgr)","return E_PERM;","elseif (node = args[1][1])","this:_kill(node);","endif"]},{"name":"_message_num","owner":36,"perms":173,"preposition":-1,"code":["return args[2];"]},{"name":"_message_date","owner":36,"perms":173,"preposition":-1,"code":["return args[3];"]},{"name":"_message_hdr","owner":36,"perms":173,"preposition":-1,"code":["return args[3..$];"]},{"name":"_message_text","owner":36,"perms":173,"preposition":-1,"code":["if ((caller == this) || this:is_readable_by(caller_perms()))","return {@args[3..$], @args[1] ? {\"\", @this.(args[1])} | {}};","else","return E_PERM;","endif"]},{"name":"_lt_msgnum","owner":36,"perms":173,"preposition":-1,"code":["return args[1] < args[2][1];"]},{"name":"_lt_msgdate","owner":36,"perms":173,"preposition":-1,"code":["return args[1] < args[2][2];"]},{"name":"receive_batch","owner":36,"perms":173,"preposition":-1,"code":["if (!this:is_writable_by(caller_perms()))","return E_PERM;","else","new = this:new_message_num();","msgtree = this.messages;","for m in (args)","msgtree = this._mgr:insert_last(msgtree, this:_makemsg(new, m[2]));","new = new + 1;","if ($command_utils:running_out_of_time())","this.messages = msgtree;","player:tell(\"... \", new);","suspend(0);","msgtree = this.messages;","new = this:new_message_num();","endif","endfor","this.messages = msgtree;","this.last_used_time = time();","return 1;","endif"]},{"name":"receive_message","owner":36,"perms":173,"preposition":-1,"code":["if (!this:is_writable_by(caller_perms()))","return E_PERM;","else","this.messages = this._mgr:insert_last(this.messages, msg = this:_makemsg(new = this:new_message_num(), args[1]));","this.last_msg_date = this:_message_date(@msg);","this.last_used_time = time();","return new;","endif"]},{"name":"messages_in_seq","owner":36,"perms":173,"preposition":-1,"code":["if (!this:ok(caller, caller_perms()))","return E_PERM;","elseif (typeof(seq = args[1]) != LIST)","x = this._mgr:find_nth(this.messages, seq);","return {this:_message_num(@x), this:_message_text(@x)};","else","msgs = {};","while (seq)","handle = this._mgr:start(this.messages, seq[1], seq[2] - 1);","while (handle)","for x in (handle[1])","msgs = {@msgs, {this:_message_num(@x), this:_message_text(@x)}};","endfor","handle = this._mgr:next(@listdelete(handle, 1));","$command_utils:suspend_if_needed(0);","endwhile","seq = seq[3..$];","endwhile","return msgs;","endif"]},{"name":"display_seq_headers","owner":36,"perms":173,"preposition":-1,"code":["\":display_seq_headers(msg_seq[,cur[,last_read_date]])\";","\"This is the default header display routine.\";","\"Prints a list of headers of messages on this to player.  msg_seq is the handle returned by this:parse_message_seq(...).  cur is the player's current message.  last_read_date is the date of the last of the already-read messages.\";","if (!this:ok(caller, caller_perms()))","return E_PERM;","endif","getmsg = this.summary_uses_body ? \"_message_text\" | \"_message_hdr\";","{seq, ?cur = 0, ?last_old = $maxint} = args;","keep_seq = {@$seq_utils:contract(this:kept_msg_seq(), $seq_utils:complement(seq, 1, this:length_all_msgs())), $maxint};","k = 1;","mcount = 0;","width = player:linelen();","while (seq)","handle = this._mgr:start(this.messages, seq[1], seq[2] - 1);","while (handle)","for x in (handle[1])","$command_utils:suspend_if_needed(0);","if (keep_seq[k] <= (mcount = mcount + 1))","k = k + 1;","endif","annot = (x[3] > last_old) ? \"+\" | ((k % 2) ? \" \" | \"=\");","line = tostr($string_utils:right(x[2], 5, (cur == x[2]) ? \">\" | \" \"), \":\", annot, \" \", this:msg_summary_line(@this:(getmsg)(@x)));","player:tell(line[1..min(width, $)]);","endfor","handle = this._mgr:next(@listdelete(handle, 1));","endwhile","seq = seq[3..$];","endwhile","player:tell(\"-----+\");"]},{"name":"display_seq_full","owner":36,"perms":173,"preposition":-1,"code":["\":display_seq_full(msg_seq[,preamble]) => {cur}\";","\"This is the default message display routine.\";","\"Prints the indicated messages on folder to player.  msg_seq is the handle returned by folder:parse_message_seq(...).  Returns the number of the final message in the sequence (to be the new current message number).\";","if (!this:ok(caller, caller_perms()))","return E_PERM;","endif","{seq, ?preamble = \"\"} = args;","cur = date = 0;","while (seq)","handle = this._mgr:start(this.messages, seq[1], seq[2] - 1);","while (handle)","for x in (handle[1])","cur = this:_message_num(@x);","date = this:_message_date(@x);","player:display_message(preamble ? strsub(preamble, \"%d\", tostr(cur)) | {}, this:msg_full_text(@this:_message_text(@x)));","endfor","handle = this._mgr:next(@listdelete(handle, 1));","$command_utils:suspend_if_needed(0);","endwhile","seq = seq[3..$];","endwhile","return {cur, date};"]},{"name":"list_rmm","owner":36,"perms":173,"preposition":-1,"code":["if (!this:ok(caller, caller_perms()))","return E_PERM;","endif","len = 0;","getmsg = this.summary_uses_body ? \"_message_text\" | \"_message_hdr\";","going = this.messages_going;","if (going && ((!going[1]) || (typeof(going[1][2]) == INT)))","kept = {@going[1], $maxint};","going = going[2];","else","kept = {$maxint};","endif","k = 1;","mcount = 0;","for s in (going)","if (kept[k] <= (mcount = mcount + s[1]))","k = k + 1;","endif","len = len + s[2][2];","handle = this._mgr:start(s[2], 1, s[2][2]);","while (handle)","for x in (handle[1])","if (kept[k] <= (mcount = mcount + 1))","k = k + 1;","endif","player:tell($string_utils:right(this:_message_num(@x), 4), (k % 2) ? \":  \" | \":= \", this:msg_summary_line(@this:(getmsg)(@x)));","endfor","handle = this._mgr:next(@listdelete(handle, 1));","endwhile","endfor","if (len)","player:tell(\"----+\");","endif","return len;"]},{"name":"undo_rmm","owner":36,"perms":173,"preposition":-1,"code":["if (!this:ok_write(caller, caller_perms()))","return E_PERM;","endif","msgtree = this.messages;","seq = {};","last = 0;","\"there are two possible formats here:\";","\"OLD: {{n,msgs},{n,msgs},...}\";","\"NEW: {kept_seq, {{n,msgs},{n,msgs},...}}\";","going = this.messages_going;","if (going && ((!going[1]) || (typeof(going[1][2]) == INT)))","kept = going[1];","going = going[2];","else","kept = {};","endif","for s in (going)","msgtree = this._mgr:insert_after(msgtree, s[2], last + s[1]);","seq = {@seq, (last + s[1]) + 1, (last = (last + s[1]) + s[2][2]) + 1};","endfor","this.messages = msgtree;","this.messages_going = {};","this.messages_kept = $seq_utils:union(kept, $seq_utils:expand(this.messages_kept, seq));","this:_fix_last_msg_date();","return seq;"]},{"name":"expunge_rmm","owner":36,"perms":173,"preposition":-1,"code":["if (!this:ok_write(caller, caller_perms()))","return E_PERM;","endif","len = 0;","going = this.messages_going;","if (going && ((!going[1]) || (typeof(going[1][2]) == INT)))","going = going[2];","endif","for s in (going)","len = len + s[2][2];","this._mgr:kill(s[2], \"_killmsg\");","endfor","this.messages_going = {};","return len;"]},{"name":"rm_message_seq","owner":36,"perms":173,"preposition":-1,"code":["seq = args[1];","if (!(this:ok_write(caller, caller_perms()) || (this:ok(caller, caller_perms()) && (seq = this:own_messages_filter(caller_perms(), @args)))))","return E_PERM;","endif","msgtree = this.messages;","save = nums = {};","onext = 1;","rmmed = 0;","for i in [1..length(seq) / 2]","if ($command_utils:suspend_if_needed(0))","player:tell(\"... rmm \", onext);","suspend(0);","endif","start = seq[(2 * i) - 1];","next = seq[2 * i];","{msgtree, zmsgs} = this._mgr:extract_range(msgtree, start - rmmed, (next - 1) - rmmed);","save = {@save, {start - onext, zmsgs}};","nums = {@nums, this:_message_num(@this._mgr:find_nth(zmsgs, 1)), this:_message_num(@this._mgr:find_nth(zmsgs, zmsgs[2])) + 1};","onext = next;","rmmed = (rmmed + next) - start;","endfor","tmg = this.messages_going;","save_kept = $seq_utils:intersection(this.messages_kept, seq);","this.messages_kept = $seq_utils:contract(this.messages_kept, seq);","this.messages_going = save_kept ? {save_kept, save} | save;","fork (0)","for s in (tmg)","this._mgr:kill(s[2], \"_killmsg\");","endfor","endfork","this.messages = msgtree;","this:_fix_last_msg_date();","return $seq_utils:tostr(nums);"]},{"name":"renumber","owner":36,"perms":173,"preposition":-1,"code":["\":renumber([cur]) renumbers caller.messages, doing a suspend() if necessary.\";","\"  => {number of messages,new cur}.\";","if (!this:ok_write(caller, caller_perms()))","return E_PERM;","endif","{?cur = 0} = args;","this:expunge_rmm();","\"... blow away @rmm'ed messages since there's no way to tell what their new numbers should be...\";","if (!(msgtree = this.messages))","return {0, 0};","endif","if (cur)","cur = this._mgr:find_ord(msgtree, cur - 1, \"_lt_msgnum\") + 1;","endif","while (1)","\"...find first out-of-sequence message...\";","n = 1;","subtree = msgtree;","if (msgtree[3][1] == 1)","while ((node = this.(subtree[1]))[1])","\"...subtree[3][1]==n...\";","kids = node[2];","n = n + subtree[2];","i = length(kids);","while ((n = n - kids[i][2]) != kids[i][3][1])","i = i - 1;","endwhile","subtree = kids[i];","endwhile","leaves = node[2];","n = ((firstn = n) + length(leaves)) - 1;","while (n != leaves[(n - firstn) + 1][2])","n = n - 1;","endwhile","n = n + 1;","endif","\"... n == first out-of-sequence ...\";","\"...renumber as many messages as we have time for...\";","while ((n <= msgtree[2]) && (!$command_utils:running_out_of_time()))","msg = this._mgr:find_nth(msgtree, n);","msgtree = this._mgr:set_nth(msgtree, n, listset(msg, n, 2));","n = n + 1;","endwhile","this.messages = msgtree;","if (n > msgtree[2])","return {n - 1, cur};","endif","player:tell(\"...(renumbering to \", n - 1, \")\");","suspend(0);","\"...start over... may have received new mail, rmm'ed stuff, etc...\";","\"...so who knows what's there now?...\";","if (this.messages_going)","player:tell(\"Renumber aborted.\");","return;","endif","msgtree = this.messages;","endwhile"]},{"name":"length_all_msgs","owner":36,"perms":173,"preposition":-1,"code":["return this:ok(caller, caller_perms()) ? this.messages ? this.messages[2] | 0 | E_PERM;"]},{"name":"length_num_le","owner":36,"perms":173,"preposition":-1,"code":["return this:ok(caller, caller_perms()) ? this._mgr:find_ord(this.messages, args[1], \"_lt_msgnum\") | E_PERM;"]},{"name":"length_date_le","owner":36,"perms":173,"preposition":-1,"code":["return this:ok(caller, caller_perms()) ? this._mgr:find_ord(this.messages, args[1], \"_lt_msgdate\") | E_PERM;"]},{"name":"exists_num_eq","owner":36,"perms":173,"preposition":-1,"code":["return this:ok(caller, caller_perms()) ? (i = this._mgr:find_ord(this.messages, args[1], \"_lt_msgnum\")) && ((this:_message_num(@this._mgr:find_nth(this.messages, i)) == args[1]) && i) | E_PERM;"]},{"name":"new_message_num","owner":36,"perms":173,"preposition":-1,"code":["if (this:ok(caller, caller_perms()))","new = (msgtree = this.messages) ? this:_message_num(@this._mgr:find_nth(msgtree, msgtree[2])) + 1 | 1;","if (rmsgs = this.messages_going)","lbrm = rmsgs[$][2];","return max(new, this:_message_num(@this._mgr:find_nth(lbrm, lbrm[2])) + 1);","else","return new;","endif","else","return E_PERM;","endif"]},{"name":"from_msg_seq","owner":36,"perms":173,"preposition":-1,"code":["\":from_msg_seq(object or list)\";","\" => msg_seq of messages from any of these senders\";","if (!this:ok(caller, caller_perms()))","return E_PERM;","elseif (!this.messages)","return {};","endif","{plist, ?mask = {1, this.messages[2] + 1}} = args;","if (typeof(plist) != LIST)","plist = {plist};","endif","fseq = {};","for m in [1..length(mask) / 2]","handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);","while (handle)","for msg in (handle[1])","fromline = msg[4];","if (toobj(fromline[rindex(fromline, \"(\") + 1..rindex(fromline, \")\") - 1]) in plist)","fseq = $seq_utils:add(fseq, i, i);","endif","i = i + 1;","$command_utils:suspend_if_needed(0);","endfor","handle = this._mgr:next(@listdelete(handle, 1));","endwhile","endfor","return fseq || (\"%f %<has> no messages from \" + $string_utils:english_list($list_utils:map_arg(2, $string_utils, \"pronoun_sub\", \"%n (%#)\", plist), \"no one\", \" or \"));"]},{"name":"%from_msg_seq","owner":36,"perms":173,"preposition":-1,"code":["\":%from_msg_seq(string or list of strings)\";","\" => msg_seq of messages with one of these strings in the from line\";","if (!this:ok(caller, caller_perms()))","return E_PERM;","elseif (!this.messages)","return {};","endif","{nlist, ?mask = {1, this.messages[2] + 1}} = args;","if (typeof(nlist) != LIST)","nlist = {nlist};","endif","fseq = {};","for m in [1..length(mask) / 2]","handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);","while (handle)","for msg in (handle[1])","fromline = \" \" + msg[4];","for n in (nlist)","if (index(fromline, n))","fseq = $seq_utils:add(fseq, i, i);","endif","endfor","i = i + 1;","$command_utils:suspend_if_needed(0);","endfor","handle = this._mgr:next(@listdelete(handle, 1));","endwhile","endfor","return fseq || (\"%f %<has> no messages from \" + $string_utils:english_list($list_utils:map_arg($string_utils, \"print\", nlist), \"no one\", \" or \"));"]},{"name":"to_msg_seq","owner":36,"perms":173,"preposition":-1,"code":["\":to_msg_seq(object or list) => msg_seq of messages to those people\";","if (!this:ok(caller, caller_perms()))","return E_PERM;","elseif (!this.messages)","return {};","endif","{plist, ?mask = {1, this.messages[2] + 1}} = args;","if (typeof(plist) != LIST)","plist = {plist};","endif","seq = {};","for m in [1..length(mask) / 2]","handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);","while (handle)","for msg in (handle[1])","toline = msg[5];","for r in ($mail_agent:parse_address_field(toline))","if (r in plist)","seq = $seq_utils:add(seq, i, i);","endif","endfor","i = i + 1;","$command_utils:suspend_if_needed(0);","endfor","handle = this._mgr:next(@listdelete(handle, 1));","endwhile","endfor","return seq || (\"%f %<has> no messages to \" + $string_utils:english_list($list_utils:map_arg(2, $string_utils, \"pronoun_sub\", \"%n (%#)\", plist), \"no one\", \" or \"));"]},{"name":"%to_msg_seq","owner":36,"perms":173,"preposition":-1,"code":["\":%to_msg_seq(string or list of strings)\";","\" => msg_seq of messages containing one of strings in the to line\";","if (!this:ok(caller, caller_perms()))","return E_PERM;","elseif (!this.messages)","return {};","endif","{nlist, ?mask = {1, this.messages[2] + 1}} = args;","if (typeof(nlist) != LIST)","nlist = {nlist};","endif","seq = {};","for m in [1..length(mask) / 2]","handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);","while (handle)","for msg in (handle[1])","toline = \" \" + msg[5];","for n in (nlist)","if (index(toline, n))","seq = $seq_utils:add(seq, i, i);","endif","endfor","i = i + 1;","$command_utils:suspend_if_needed(0);","endfor","handle = this._mgr:next(@listdelete(handle, 1));","endwhile","endfor","return seq || (\"%f %<has> no messages to \" + $string_utils:english_list($list_utils:map_arg($string_utils, \"print\", nlist), \"no one\", \" or \"));"]},{"name":"subject_msg_seq","owner":36,"perms":173,"preposition":-1,"code":["\":subject_msg_seq(target) => msg_seq of messages with target in the Subject:\";","if (!this:ok(caller, caller_perms()))","return E_PERM;","elseif (!this.messages)","return {};","endif","{target, ?mask = {1, this.messages[2] + 1}} = args;","seq = {};","for m in [1..length(mask) / 2]","handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);","while (handle)","for msg in (handle[1])","if (((subject = msg[6]) != \" \") && index(subject, target))","seq = $seq_utils:add(seq, i, i);","endif","i = i + 1;","$command_utils:suspend_if_needed(0);","endfor","handle = this._mgr:next(@listdelete(handle, 1));","endwhile","endfor","return seq || ((\"%f %<has> no messages with subjects containing `\" + target) + \"'\");"]},{"name":"body_msg_seq","owner":36,"perms":173,"preposition":-1,"code":["\":body_msg_seq(target) => msg_seq of messages with target in the body\";","if (!this:ok(caller, caller_perms()))","return E_PERM;","elseif (!this.messages)","return {};","endif","{target, ?mask = {1, this.messages[2] + 1}} = args;","seq = {};","for m in [1..length(mask) / 2]","handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);","while (handle)","for msg in (handle[1])","if ((msg[1] && (body = this.(msg[1]))) && index(tostr(@body), target))","seq = $seq_utils:add(seq, i, i);","\"Above saves ticks. Munges the whole message into one string and indexes it. Old code follows.\";","\"l = length(body);\";","\"while (!index(body[l], target) && (l = l - 1))\";","\"$command_utils:suspend_if_needed(0);\";","\"endwhile\";","\"if (l)\";","\"seq = $seq_utils:add(seq, i, i);\";","\"endif\";","endif","i = i + 1;","$command_utils:suspend_if_needed(0);","endfor","handle = this._mgr:next(@listdelete(handle, 1));","endwhile","endfor","return seq || tostr(\"%f %<has> no messages containing `\", target, \"' in the body.\");"]},{"name":"date_sort","owner":36,"perms":173,"preposition":-1,"code":["return E_VERBNF;"]},{"name":"_fix_last_msg_date","owner":36,"perms":173,"preposition":-1,"code":["msgtree = this.messages;","this.last_msg_date = (msgtree && this:_message_hdr(@this._mgr:find_nth(msgtree, msgtree[2]))[1]) || 0;"]},{"name":"__fix","owner":36,"perms":173,"preposition":-1,"code":["if (!this:ok_write(caller, caller_perms()))","return E_PERM;","endif","{?doit = 0} = args;","msgtree = this.messages;","for n in [1..msgtree[2]]","msg = this._mgr:find_nth(msgtree, n);","msg = {@msg[1..2], @$mail_agent:__convert_new(@msg[3..$])};","if (doit)","msgtree = this._mgr:set_nth(msgtree, n, msg);","endif","if ($command_utils:running_out_of_time())","suspend(0);","if (this.messages != msgtree)","player:notify(\"urk.  someone played with this folder.\");","return 0;","endif","endif","endfor","return 1;"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","pass();","this._mgr = $biglist;","this.mowner = $mail_recipient.owner;","endif"]},{"name":"length_date_gt","owner":36,"perms":173,"preposition":-1,"code":["if (this:ok(caller, caller_perms()))","date = args[1];","return (this.last_msg_date <= date) ? 0 | (this.messages[2] - this._mgr:find_ord(this.messages, args[1], \"_lt_msgdate\"));","else","return E_PERM;","endif"]},{"name":"_repair","owner":2,"perms":165,"preposition":-1,"code":["c = callers();","if ((caller != this) && (!((((length(c) > 1) && (c[1][1] == $list_utils)) && (c[1][2] == \"map_arg\")) && (c[2][1] == this))))","raise(E_PERM);","endif","$command_utils:suspend_if_needed(0);","biglist = this;","propname = args[1];","if (!propname)","bestlevel = -1;","best = {};","for prop in (properties(biglist))","$command_utils:suspend_if_needed(0);","if (index(prop, \" \") == 1)","val = biglist.(prop);","if (typeof(val[1]) == INT)","if (bestlevel < val[1])","bestlevel = val[1];","best = {prop};","elseif (bestlevel == val[1])","best = {@best, prop};","endif","endif","endif","endfor","if (!best)","player:notify(\"Can't find a root.\");","raise(E_INVARG);","elseif (length(best) == 1)","propname = best[1];","else","propname = best[1];","val = biglist.(propname);","for prop in (best[2..$])","$command_utils:suspend_if_needed(0);","val[2] = {@val[2], @biglist.(prop)[2]};","endfor","biglist.(propname) = val;","\"Now that the new value is safely stored, delete old values.\";","for prop in (best[2..$])","$command_utils:suspend_if_needed(0);","player:notify(tostr(\"Removing property \", toliteral(prop), \".  Its value, \", toliteral(biglist.(prop)), \", has been merged with property \", toliteral(propname), \".\"));","delete_property(biglist, prop);","endfor","endif","maxlevel = biglist.(propname)[1];","player:notify(tostr(\"Maximum level is \", maxlevel, \".\"));","items = $list_utils:make(maxlevel, {});","\"Arrgh.  Even after finding the root, some nodes might be detached!\";","player:notify(\"Checking for orphans...\");","for prop in (properties(biglist))","$command_utils:suspend_if_needed(0);","if (prop && (prop[1] == \" \"))","val = biglist.(prop);","if (((typeof(val) == LIST) && (typeof(level = val[1]) == INT)) && (level < maxlevel))","items[level + 1] = {@items[level + 1], prop};","endif","endif","endfor","for prop in (properties(biglist))","$command_utils:suspend_if_needed(0);","if (prop && (prop[1] == \" \"))","val = biglist.(prop);","if (((typeof(val) == LIST) && (typeof(level = val[1]) == INT)) && (level > 0))","for item in (val[2])","items[level] = setremove(items[level], item[1]);","endfor","endif","endif","endfor","player:notify(tostr(\"Orphans: \", toliteral(items)));","backbone_prop = propname;","level = maxlevel;","while (level)","backbone = biglist.(backbone_prop);","lastkid = backbone_prop;","for prop in (props = items[level])","backbone[2] = {@backbone[2], {lastkid = prop, 0, {0, 0}}};","endfor","player:notify(tostr(\"Attaching \", nn = length(props), \" propert\", (nn == 1) ? \"y\" | \"ies\", \" to property \", toliteral(backbone_prop), \"...\"));","biglist.(backbone_prop) = backbone;","backbone_prop = lastkid;","level = level - 1;","endwhile","player:notify(tostr(\"Orphans repatriated.\"));","endif","toplevel = \"(top level)\";","context = args[2] || toplevel;","\"This stuff is just paranoia in case something unexpected is in the data structure.  Normally there should be no blowouts here. --Minnie\";","if (typeof(propname) != STR)","player:notify(tostr(\"Context=\", context, \" Prop Name=\", toliteral(propname), \" -- bad property name.\"));","raise(E_INVARG);","endif","val = biglist.(propname);","if (typeof(val) != LIST)","player:notify(tostr(\"Context=\", context, \" Prop Name=\", toliteral(propname), \" -- contents invalid.\"));","raise(E_INVARG);","endif","if (typeof(level = val[1]) != INT)","player:notify(tostr(\"Context=\", context, \" Prop Name=\", toliteral(propname), \" -- contents invalid (bad first argument).\"));","raise(E_INVARG);","endif","\"This is where the real work starts. --Minnie\";","\"First check that the properties referred to really exist.  This must be done for all levels.\";","for item in (val[2])","try","biglist.(item[1]);","except (E_PROPNF)","player:notify(tostr(\"Item \", toliteral(item), \" is invalid in property \", toliteral(propname), \".  It is being removed.\"));","val[2] = setremove(val[2], item);","continue item;","endtry","endfor","\"Next, only for upper levels, check that the message count for inferior levels is correct, but only after recursing into those levels and making repairs.\";","if (level > 0)","new = $list_utils:map_arg(this, verb, $list_utils:slice(val[2]), propname);","if (val[2] != new)","player:notify(tostr(\"Changing \", toliteral(val[2]), \" to \", toliteral(new), \".\"));","val[2] = new;","endif","\"Now that everything is correct, count size of inferiors.\";","endif","\"Bravely stuff the result back into place.\";","biglist.(propname) = val;","\"The result will be of the form:                               \";","\"  {propname, inferior_msgcount, {first_msgnum, first_time}}  \";","if (level == 0)","\"Count the messages for message count.\";","\"Use first message number and time for first_msgnum and first_time.\";","result = {propname, length(val[2]), val[2][1][2..3]};","else","\"Use message count that is sum of inferior counts.\";","\"Just propagate first node's first_msgnum and first_time upward literally.\";","n = 0;","for subnode in (val[2])","n = n + subnode[2];","endfor","result = {propname, n, val[2][1][3]};","endif","if (context == toplevel)","if (result != biglist.messages)","biglist.messages = result;","player:notify(tostr(\"Property \", biglist, \".messages updated.\"));","endif","player:tell(biglist.messages[2], \" messages repaired in \", $mail_agent:name(biglist), \".\");","endif","return result;","\"Last modified Thu Feb 15 23:13:44 1996 MST by Minnie (#123).\";"]},{"name":"repair","owner":2,"perms":41,"preposition":-1,"code":["\"Syntax: repair <biglist>\";","\"\";","\"This tool makes a last-resort attempt to repair broken biglists (ones whose data structures are out of alignment due to an error such as \\\"out of ticks\\\" during some update operation leaving the b-tree in an inconsistent state).  This tool comes with no warranty of any kind.  You should only use it when you have no other choice, and you should make an attempt to @dump or fully copy or otherwise checkpoint your object before attempting to repair it so that you can recover from any failures this might produce.  This operation is NOT undoable.\";","if (!$perm_utils:controls(player, this))","player:tell(\"You do not control that.\");","elseif (!$command_utils:yes_or_no(\"This tool can be used to repair some (but maybe not all) situations involving generic biglists that have had an error (usually \\\"out of ticks\\\") during an update operation and were left inconsistent.  Is this list really and truly broken in such a way?\"))","player:tell(\"No action taken.  PLEASE don't use this except in extreme cases.\");","elseif (!$command_utils:yes_or_no(\"Have you made a best effort to @dump or otherwise save the contents in case this make things worse?\"))","player:tell(\"No action taken.  PLEASE do any saving you can before proceeding.\");","elseif (!$command_utils:yes_or_no(\"This tool comes with no warranty of any kind.  Is this really your last resort and are you prepared to accept the consequences of utter failure?  There is no undoing the actions this takes.  Do you understand and accept the risks?\"))","player:tell(\"No action taken.  I'm not taking any responsibility for this failing.  It's gotta be your choice.\");","else","player:tell(\"OK!  Going ahead with repair attempts...\");","this:_repair();","player:tell(\"All done.  If this worked, you can thank Mickey.  If not, remember the promises you made above about accepting responsibility for failure.\");","endif","\"Last modified Fri Feb 16 08:36:27 1996 MST by Minnie (#123).\";"]},{"name":"restore_from","owner":2,"perms":173,"preposition":-1,"code":["\":restore_from(OLD_MAIL_RECIPIENT, LOST_STRING)\";","\"This clears all biglist properties from this object, then\";","\"scans the properties of OLD_MAIL_RECIPIENT, which must be a descendant\";","\"of $big_mail_recipient, looking for those corresponding to mail messages,\";","\"and then rebuilds the message tree entirely from scratch.\";","\"\";","\"No attempt is made to preserve the original tree structure.\";","\"The live/deleted state of any given message is lost;\";","\"all messages, including formerly rmm-ed ones, are restored to .messages\";","\"\";","\"In the (unlikely) event that message-body properties have been lost, the\";","\"affected messages are given a one-line body consisting of LOST_STRING\";","\"\";","{old, ?lost_body = \"###BODY-LOST###\"} = args;","if (!($perm_utils:controls(caller_perms(), this) && $perm_utils:controls(caller_perms(), old)))","raise(E_PERM);","elseif (!$object_utils:isa(old, $big_mail_recipient))","raise(E_TYPE, \"First argument must be a $big_mail_recipient.\");","elseif (typeof(lost_body) != STR)","raise(E_TYPE, \"Second argument, if given, must be a string.\");","endif","mgr = this._mgr;","\"...\";","\"... destroy everything...\";","for p in (properties(this))","delete_property(this, p);","endfor","this.messages = this.messages_going = {};","\"...\";","\"... look at all properties...\";","msgcount = lostcount = 0;","for p in (properties(old))","if (index(p, \" \") == 1)","pvalue = old.(p);","\"... ignore everything except level-0 nodes...\";","if (pvalue[1..min(1, $)] == {0})","for msg in (pvalue[2])","if ((ticks_left() < 6000) || (seconds_left() < 2))","player:tell(\"...\", msgcount, \" copied.\");","suspend(0);","endif","try","body = old.(msg[1]);","except e (E_PROPNF)","body = {lost_body};","lostcount = lostcount + 1;","endtry","msg[1] = this:_make(@body);","msgtree = mgr:insert_last(this.messages, msg);","msgcount = msgcount + 1;","n = mgr:find_ord(msgtree, this:_message_num(@msg), \"_lt_msgnum\");","if (n < msgcount)","{msgtree, singleton} = mgr:extract_range(msgtree, msgcount, msgcount);","msgtree = mgr:insert_after(msgtree, singleton, n);","endif","this.messages = msgtree;","endfor","endif","endif","endfor","player:tell(msgcount, \" messages installed on \", this.name, \"(\", this, \")\");","if (lostcount)","player:tell(lostcount, \" messages have missing bodies (indicated by \", toliteral(lost_body), \").\");","else","player:tell(\"No message bodies were missing.\");","endif"]},{"name":"acceptable","owner":2,"perms":173,"preposition":-1,"code":["what = args[1];","return is_player(what) && (!(what in connected_players()));"]},{"name":"confunc","owner":2,"perms":173,"preposition":-1,"code":["(caller == #0) || raise(E_PERM);","{who} = args;","\"this:eject(who)\";","if (!$recycler:valid(home = who.home))","clear_property(who, \"home\");","home = who.home;","if (!$recycler:valid(home))","home = who.home = $player_start;","endif","endif","\"Modified 08-22-98 by TheCat to foil people who manually set their home to places they shouldn't.\";","if ((!home:acceptable(who)) || (!home:accept_for_abode(who)))","home = $player_start;","endif","try","move(who, home);","except (ANY)","move(who, $player_start);","endtry","who.location:announce_all_but({who}, who.name, \" has connected.\");"]},{"name":"who_location_msg","owner":36,"perms":173,"preposition":-1,"code":["return $player_start:who_location_msg(@args);"]},{"name":"moveto","owner":36,"perms":173,"preposition":-1,"code":["\"Don't go anywhere.\";"]},{"name":"eject","owner":2,"perms":173,"preposition":-1,"code":["if ($perm_utils:controls(caller_perms(), this))","if ((what = args[1]).wizard && (what.location == this))","move(what, what.home);","else","return pass(@args);","endif","endif"]},{"name":"find* _only* _every*","owner":36,"perms":173,"preposition":-1,"code":["return ((caller == this) || caller_perms().wizard) ? pass(@args) | E_PERM;"]},{"name":"add","owner":36,"perms":173,"preposition":-1,"code":["\":add(player,email[,comment])\";","if (!caller_perms().wizard)","return E_PERM;","endif","{who, email, @comment} = args;","l = this:find_exact(email);","if (l == $failed_match)","this:insert(email, {{who, @comment}});","elseif (i = $list_utils:iassoc(who, l))","this:insert(email, listset(l, {who, @comment}, i));","else","this:insert(email, {@l, {who, @comment}});","endif"]},{"name":"init_for_core","owner":36,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","pass();","this:clearall();","this.registrar = #2;","endif"]},{"name":"suspicious_address","owner":2,"perms":173,"preposition":-1,"code":["\"suspicious(address [,who])\";","\"Determine whether an address appears to be another player in disguise.\";","\"returns a list of similar addresses.\";","\"If second argument given, then if all similar addresses are held by that\";","\"person, let it pass---they're just switching departments at the same school\";","\"or something.\";","\"\";","\"at the moment,\";","\"  foo@bar.baz.bing.boo\";","\"is considered 'similar' to anything matching\";","\"  foo@*.bing.boo\";","if (!caller_perms().wizard)","return E_PERM;","endif","{address, ?allowed = #-1} = args;","{userid, site} = $network:parse_address(address);","exact = (!site) && this:find_exact(address);","if (!site)","site = $network.site;","endif","site = $network:local_domain(site);","sitelen = length(site);","others = this:find_all_keys(userid + \"@\");","for other in (others)","if (other[max(1, ($ - sitelen) + 1)..$] != site)","others = setremove(others, other);","endif","endfor","if (exact)","others = listinsert(others, address);","endif","for x in (others)","allzapped = 1;","for y in (this:find_exact(x))","if ((((length(y) == 2) && ((y[2] == \"zapped due to inactivity\") || (y[2] == \"toaded due to inactivity\"))) || (y[1] == allowed)) || (($object_utils:has_property($local, \"second_char_registry\") && (typeof(them = $local.second_char_registry:other_chars(y[1])) == LIST)) && (allowed in them)))","\"let them change to the address if it is them, or if it is a registered char of theirs.\";","\"Hrm. Need typeof==LIST check because returns E_INVARG for shared characters. bleah Ho_Yan 5/8/95\";","else","allzapped = 0;","endif","endfor","if (allzapped)","others = setremove(others, x);","endif","endfor","return others;"]},{"name":"suspicious_userid","owner":2,"perms":173,"preposition":-1,"code":["\"suspicious_userid(userid)\";","\"Return yes if userid is root or postmaster or something like that.\";","if ($object_utils:has_property(#0, \"local\") && $object_utils:has_property($local, \"suspicious_userids\"))","extra = $local.suspicious_userids;","else","extra = {};","endif","return ((((args[1] in {@$network.suspicious_userids, @extra}) || match(args[1], \"^guest\")) || match(args[1], \"^help\")) || index(args[1], \"-owner\")) || index(args[1], \"owner-\");","\"Thinking about ruling out hyphenated names, on the grounds that they're probably mailing lists.\";"]},{"name":"describe_registration","owner":2,"perms":173,"preposition":-1,"code":["\"Returns a list of strings describing the registration data for an email address.  Args[1] should be the result of this:find.\";","set_task_perms(caller_perms());","result = {};","for x in (args[1])","name = (valid(x[1]) && is_player(x[1])) ? x[1].name | \"<recycled>\";","email = (valid(x[1]) && is_player(x[1])) ? $wiz_utils:get_email_address(x[1]) | \"<???>\";","result = {@result, tostr(\"  \", name, \" (\", x[1], \") current email: \", email, (length(x) > 1) ? (\" [\" + x[2]) + \"]\" | \"\")};","endfor","return result;"]},{"name":"prune","owner":2,"perms":173,"preposition":-1,"code":["\"Carefully loop through the db and delete items associated with reaped objects.  If that results in no objects remaining for a username, delete that username.\";","\"Attempt to keep memory usage down by only asking for a small number of items at a time.  Should probably have some arguments to control this.\";","if (!caller_perms().wizard)","raise(E_PERM);","endif","this.prune_task = task_id();","probe = this.prune_progress;","while (probe < this.prune_stop)","for username in (this:find_all_keys(probe))","items = this:find_exact(username);","orig = items;","for y in (items)","{who, @whys} = y;","if ((!valid(who)) || (!is_player(who)))","nuke = 1;","for why in (whys)","if (((why && (why != \"zapped due to inactivity\")) && (why != \"toaded due to inactivity\")) && (why != \"Additional email address\"))","nuke = 0;","endif","endfor","if (nuke)","items = setremove(items, y);","endif","endif","$command_utils:suspend_if_needed(0);","endfor","if (!items)","this:delete(username);","this.total_pruned_people = this.total_pruned_people + 1;","elseif (items != orig)","this:insert(username, items);","this.total_pruned_characters = (this.total_pruned_characters + length(orig)) - length(items);","endif","$command_utils:suspend_if_needed(0);","endfor","probe = $string_utils:incr_alpha(probe, this.alphabet);","this.prune_progress = probe;","if ($command_utils:running_out_of_time())","set_task_perms($wiz_utils:random_wizard());","suspend(0);","endif","endwhile","player:tell(\"Prune stopped at \", toliteral(this.prune_progress));"]},{"name":"report_prune_progress","owner":2,"perms":173,"preposition":-1,"code":["player:tell(\"Prune is up to \", toliteral(this.prune_progress), \".\");","mine = 0;","alphalen = length(this.alphabet);","if (typeof(this.prune_progress) == STR)","total = (alphalen * alphalen) * alphalen;","for x in [1..3]","mine = ((mine * alphalen) + index(this.alphabet, this.prune_progress[x])) - 1;","endfor","else","total = 256 * 256;","mine = (this.prune_progress[1] * 256) + this.prune_progress[2];","endif","percent = (100.0 * tofloat(mine)) / tofloat(total);","player:tell(\"We have processed \", mine, \" entries out of \", total, \", or \", toint(percent), \".\", toint(10.0 * percent) % 10, \"%.\");","player:tell(\"There were \", this.total_pruned_characters, \" individual list entries removed, and \", this.total_pruned_people, \" whole email addresses removed.\");","if ($code_utils:task_valid(this.prune_task))","player:tell(\"Prune task is \", this.prune_task, \".  Stacktrace:\");","for x in (task_stack(this.prune_task, 1))","if (valid(x[4]))","player:tell(x[4], \":\", x[2], \" [\", x[1], \"]  \", x[3].name, \"  (\", x[6], \")\");","endif","endfor","else","player:tell(\"The recorded task_id is no longer valid.\");","endif"]},{"name":"display_seq_headers","owner":2,"perms":173,"preposition":-1,"code":["\":display_seq_headers(msg_seq[,cur])\";","if (!this:ok(caller, caller_perms()))","return E_PERM;","endif","player:tell(\"       WHEN    BY        WHO                 EMAIL-ADDRESS\");","pass(@args);"]},{"name":"msg_summary_line","owner":2,"perms":173,"preposition":-1,"code":["when = ctime(args[1])[5..10];","from = args[2];","by = $string_utils:left(from[1..index(from, \" (\") - 1], -9);","subject = args[4];","who = subject[1..(open = index(subject, \" (\")) - 1];","if ((close = rindex(subject, \")\")) > open)","who = who[1..min(9, $)] + subject[open..close];","endif","who = $string_utils:left(who, 18);","line = args[(\"\" in args) + 1];","email = line[1..index(line + \" \", \" \") - 1];","if (!index(email, \"@\"))","email = \"??\";","endif","return tostr(when, \"  \", by, \" \", who, \"  \", email);"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","pass();","\"this:rm_message_seq({1, 1 + this:length_all_msgs()})\";","\"this:expunge_rmm()\";","for p in (properties(this))","$command_utils:suspend_if_needed(0);","if (p && (p[1] == \" \"))","delete_property(this, p);","endif","endfor","this.messages = this.messages_going = {};","this:_fix_last_msg_date();","this._genprop = \"\";","this.mail_forward = {};","this.mail_notify = {player};","player.current_message = {@player.current_message, {this, 0, 0}};","for p in ({\"moderator_forward\", \"writers\", \"readers\", \"expire_period\", \"last_used_time\"})","clear_property(this, p);","endfor","this.moderated = {this};","else","return E_PERM;","endif"]},{"name":"is_usable_by","owner":2,"perms":173,"preposition":-1,"code":["\"Copied from Generic Mail Recipient (#6419):is_usable_by by Rog (#4292) Tue Mar  2 10:02:32 1993 PST\";","return (!this.moderated) || ((this:is_writable_by(who = args[1]) || (who in this.moderated)) || who.wizard);"]},{"name":"expire_old_messages","owner":36,"perms":13,"preposition":-1,"code":["\"Stop breaking the expire task completely with out of seconds/ticks.\";","if (this:ok_write(caller, caller_perms()))","fork (0)","pass(@args);","endfork","else","return E_PERM;","endif"]},{"name":"find_topics","owner":36,"perms":173,"preposition":-1,"code":["if ($code_utils:parse_verbref(what = args[1]))","\"... hey wow, I found it!...\";","return {what};","else","return {};","endif"]},{"name":"get_topic","owner":2,"perms":173,"preposition":-1,"code":["\"Help facility for verbs that people have bothered to document.  If the argument is a verb specification, this retrieves the code and prints any documentation lines that might be at the beginning.  Returns true if the arg can actually be interpreted as a verb specification, whether or not it is a correct one.\";","set_task_perms(caller_perms());","if (!(spec = $code_utils:parse_verbref(args[1])))","return 0;","elseif ($command_utils:object_match_failed(object = $string_utils:match_object(spec[1], player.location), spec[1]))","return 1;","elseif (!(hv = $object_utils:has_verb(object, spec[2])))","return \"That object does not define that verb.\";","elseif (typeof(verbdoc = $code_utils:verb_documentation(object = hv[1], spec[2])) == ERR)","return tostr(verbdoc);","elseif (typeof(info = `verb_info(object, spec[2]) ! ANY') == ERR)","return tostr(info);","else","objverb = tostr(object.name, \"(\", object, \"):\", strsub(info[3], \" \", \"/\"));","if (verbdoc)","return {tostr(\"Information about \", objverb), \"----\", @verbdoc};","else","return tostr(\"No information about \", objverb);","endif","endif"]},{"name":"dump_topic","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","if (!(spec = $code_utils:parse_verbref(args[1])))","return E_INVARG;","elseif ($command_utils:object_match_failed(object = $string_utils:match_object(spec[1], player.location), spec[1]))","return E_INVARG;","elseif (!(hv = $object_utils:has_verb(object, spec[2])))","return E_VERBNF;","elseif (typeof(vd = $code_utils:verb_documentation(hv[1], spec[2])) != LIST)","return vd;","else","return {tostr(\";$code_utils:set_verb_documentation(\", $code_utils:corify_object(hv[1]), \",\", $string_utils:print(spec[2]), \",$command_utils:read_lines())\"), @$command_utils:dump_lines(vd)};","endif"]},{"name":"find_topics","owner":36,"perms":173,"preposition":-1,"code":["if (!args)","l = {};","for p in (properties(#0))","if ((p[max(1, $ - 5)..$] == \"_utils\") && `#0.(p):help_msg() ! ANY')","l = {@l, \"$\" + p};","endif","endfor","return {@pass(@args), @l};","elseif (ts = pass(@args))","return ts;","elseif ((what = args[1])[1] != \"$\")","return {};","elseif (ts = pass(\"$generic_\" + what[2..$]))","return ts;","elseif ((r = rindex(w = strsub(what[2..$], \"-\", \"_\"), \"_utils\")) && ((r == (length(w) - 5)) && (`valid(#0.(w)) ! ANY' && `#0.(w):help_msg() ! ANY')))","return {what};","else","return {};","endif"]},{"name":"get_topic","owner":36,"perms":173,"preposition":-1,"code":["topic = args[1];","if ((topic == ((\"$\" + topic[2..$ - 5]) + \"utils\")) && (valid(#0.(w = strsub(topic[2..$], \"-\", \"_\"))) && (uhelp = #0.(w):description())))","return {tostr(\"General information on $\", w, \":\"), \"----\", @(typeof(uhelp) == STR) ? {uhelp} | uhelp};","else","return pass(@args);","endif"]},{"name":"dump_topic","owner":2,"perms":173,"preposition":-1,"code":["if ((E_PROPNF != (text = pass(@args))) || ((args[1][1] != \"$\") || ((!((uprop = args[1][2..$]) in properties(#0))) || (typeof(uobj = #0.(uprop)) != OBJ))))","return text;","else","udesc = uobj.description;","return {tostr(\";;$\", uprop, \".description = $command_utils:read_lines()\"), @$command_utils:dump_lines((typeof(udesc) == LIST) ? udesc | {udesc})};","endif"]},{"name":"space","owner":36,"perms":173,"preposition":-1,"code":["\"space(len,fill) returns a string of length abs(len) consisting of copies of fill.  If len is negative, fill is anchored on the right instead of the left.\";","{n, ?fill = \" \"} = args;","if (typeof(n) == STR)","n = length(n);","endif","if (n > 1000)","\"Prevent someone from crashing the moo with $string_utils:space($maxint)\";","return E_INVARG;","endif","if (\" \" != fill)","fill = fill + fill;","fill = fill + fill;","fill = fill + fill;","elseif ((n = abs(n)) < 70)","return \"                                                                      \"[1..n];","else","fill = \"                                                                      \";","endif","m = (n - 1) / length(fill);","while (m)","fill = fill + fill;","m = m / 2;","endwhile","return (n > 0) ? fill[1..n] | fill[($ + 1) + n..$];"]},{"name":"left","owner":36,"perms":173,"preposition":-1,"code":["\"$string_utils:left(string,width[,filler])\";","\"\";","\"Assures that <string> is at least <width> characters wide.  Returns <string> if it is at least that long, or else <string> followed by enough filler to make it that wide. If <width> is negative and the length of <string> is greater than the absolute value of <width>, then the <string> is cut off at <width>.\";","\"\";","\"The <filler> is optional and defaults to \\\" \\\"; it controls what is used to fill the resulting string when it is too short.  The <filler> is replicated as many times as is necessary to fill the space in question.\";","{text, len, ?fill = \" \"} = args;","abslen = abs(len);","out = tostr(text);","if (length(out) < abslen)","return out + this:space(length(out) - abslen, fill);","else","return (len > 0) ? out | out[1..abslen];","endif"]},{"name":"right","owner":36,"perms":173,"preposition":-1,"code":["\"$string_utils:right(string,width[,filler])\";","\"\";","\"Assures that <string> is at least <width> characters wide.  Returns <string> if it is at least that long, or else <string> preceded by enough filler to make it that wide. If <width> is negative and the length of <string> is greater than the absolute value of <width>, then <string> is cut off at <width> from the right.\";","\"\";","\"The <filler> is optional and defaults to \\\" \\\"; it controls what is used to fill the resulting string when it is too short.  The <filler> is replicated as many times as is necessary to fill the space in question.\";","{text, len, ?fill = \" \"} = args;","abslen = abs(len);","out = tostr(text);","if ((lenout = length(out)) < abslen)","return this:space(abslen - lenout, fill) + out;","else","return (len > 0) ? out | out[($ - abslen) + 1..$];","endif"]},{"name":"centre center","owner":36,"perms":173,"preposition":-1,"code":["\"$string_utils:center(string,width[,lfiller[,rfiller]])\";","\"\";","\"Assures that <string> is at least <width> characters wide.  Returns <string> if it is at least that long, or else <string> preceded and followed by enough filler to make it that wide.  If <width> is negative and the length of <string> is greater than the absolute value of <width>, then the <string> is cut off at <width>.\";","\"\";","\"The <lfiller> is optional and defaults to \\\" \\\"; it controls what is used to fill the left part of the resulting string when it is too short.  The <rfiller> is optional and defaults to the value of <lfiller>; it controls what is used to fill the right part of the resulting string when it is too short.  In both cases, the filler is replicated as many times as is necessary to fill the space in question.\";","{text, len, ?lfill = \" \", ?rfill = lfill} = args;","out = tostr(text);","abslen = abs(len);","if (length(out) < abslen)","return (this:space((abslen - length(out)) / 2, lfill) + out) + this:space(((abslen - length(out)) + 1) / -2, rfill);","else","return (len > 0) ? out | out[1..abslen];","endif"]},{"name":"columnize columnise","owner":36,"perms":173,"preposition":-1,"code":["\"columnize (items, n [, width]) - Turn a one-column list of items into an n-column list. 'width' is the last character position that may be occupied; it defaults to a standard screen width. Example: To tell the player a list of numbers in three columns, do 'player:tell_lines ($string_utils:columnize ({1, 2, 3, 4, 5, 6, 7}, 3));'.\";","{items, n, ?width = 79} = args;","height = ((length(items) + n) - 1) / n;","items = {@items, @$list_utils:make((height * n) - length(items), \"\")};","colwidths = {};","for col in [1..n - 1]","colwidths = listappend(colwidths, 1 - (((width + 1) * col) / n));","endfor","result = {};","for row in [1..height]","line = tostr(items[row]);","for col in [1..n - 1]","line = tostr(this:left(line, colwidths[col]), \" \", items[row + (col * height)]);","endfor","result = listappend(result, line[1..min($, width)]);","endfor","return result;"]},{"name":"from_list","owner":36,"perms":173,"preposition":-1,"code":["\"$string_utils:from_list(list [, separator])\";","\"Return a string being the concatenation of the string representations of the elements of LIST, each pair separated by the string SEPARATOR, which defaults to the empty string.\";","{thelist, ?separator = \"\"} = args;","if (separator == \"\")","return tostr(@thelist);","elseif (thelist)","result = tostr(thelist[1]);","for elt in (listdelete(thelist, 1))","result = tostr(result, separator, elt);","endfor","return result;","else","return \"\";","endif"]},{"name":"english_list","owner":36,"perms":173,"preposition":-1,"code":["\"Prints the argument (must be a list) as an english list, e.g. {1, 2, 3} is printed as \\\"1, 2, and 3\\\", and {1, 2} is printed as \\\"1 and 2\\\".\";","\"Optional arguments are treated as follows:\";","\"  Second argument is the string to use when the empty list is given.  The default is \\\"nothing\\\".\";","\"  Third argument is the string to use in place of \\\" and \\\".  A typical application might be to use \\\" or \\\" instead.\";","\"  Fourth argument is the string to use instead of a comma (and space).  Gary_Severn's deranged mind actually came up with an application for this.  You can ask him.\";","\"  Fifth argument is a string to use after the penultimate element before the \\\" and \\\".  The default is to have a comma without a space.\";","{things, ?nothingstr = \"nothing\", ?andstr = \" and \", ?commastr = \", \", ?finalcommastr = \",\"} = args;","nthings = length(things);","if (nthings == 0)","return nothingstr;","elseif (nthings == 1)","return tostr(things[1]);","elseif (nthings == 2)","return tostr(things[1], andstr, things[2]);","else","ret = \"\";","for k in [1..nthings - 1]","if (k == (nthings - 1))","commastr = finalcommastr;","endif","ret = tostr(ret, things[k], commastr);","endfor","return tostr(ret, andstr, things[nthings]);","endif"]},{"name":"names_of","owner":36,"perms":173,"preposition":-1,"code":["\"Return a string of the names and object numbers of the objects in a list.\";","line = \"\";","for item in (args[1])","if ((typeof(item) == OBJ) && valid(item))","line = (((line + item.name) + \"(\") + tostr(item)) + \")   \";","endif","endfor","return $string_utils:trimr(line);"]},{"name":"from_seconds","owner":36,"perms":173,"preposition":-1,"code":["\":from_seconds(number of seconds) => returns a string containing the rough increment of days, or hours if less than a day, or minutes if less than an hour, or lastly in seconds.\";","\":from_seconds(86400) => \\\"a day\\\"\";","\":from_seconds(7200)  => \\\"two hours\\\"\";","minute = 60;","hour = 60 * minute;","day = 24 * hour;","secs = args[1];","if (secs > day)","count = secs / day;","unit = \"day\";","article = \"a\";","elseif (secs > hour)","count = secs / hour;","unit = \"hour\";","article = \"an\";","elseif (secs > minute)","count = secs / minute;","unit = \"minute\";","article = \"a\";","else","count = secs;","unit = \"second\";","article = \"a\";","endif","if (count == 1)","time = tostr(article, \" \", unit);","else","time = tostr(count, \" \", unit, \"s\");","endif","return time;"]},{"name":"trim","owner":36,"perms":173,"preposition":-1,"code":["\":trim (string [, space]) -- remove leading and trailing spaces\";","\"\";","\"`space' should be a character (single-character string); it defaults to \\\" \\\".  Returns a copy of string with all leading and trailing copies of that character removed.  For example, $string_utils:trim(\\\"***foo***\\\", \\\"*\\\") => \\\"foo\\\".\";","{string, ?space = \" \"} = args;","m = match(string, tostr(\"[^\", space, \"]%(.*[^\", space, \"]%)?%|$\"));","return string[m[1]..m[2]];"]},{"name":"triml","owner":36,"perms":173,"preposition":-1,"code":["\":triml(string [, space]) -- remove leading spaces\";","\"\";","\"`space' should be a character (single-character string); it defaults to \\\" \\\".  Returns a copy of string with all leading copies of that character removed.  For example, $string_utils:triml(\\\"***foo***\\\", \\\"*\\\") => \\\"foo***\\\".\";","{string, ?what = \" \"} = args;","m = match(string, tostr(\"[^\", what, \"]%|$\"));","return string[m[1]..$];"]},{"name":"trimr","owner":36,"perms":173,"preposition":-1,"code":["\":trimr(string [, space]) -- remove trailing spaces\";","\"\";","\"`space' should be a character (single-character string); it defaults to \\\" \\\".  Returns a copy of string with all trailing copies of that character removed.  For example, $string_utils:trimr(\\\"***foo***\\\", \\\"*\\\") => \\\"***foo\\\".\";","{string, ?what = \" \"} = args;","return string[1..rmatch(string, tostr(\"[^\", what, \"]%|^\"))[2]];"]},{"name":"strip_chars","owner":36,"perms":173,"preposition":-1,"code":["\":strip_chars(string,chars) => string with chars removed\";","{subject, stripped} = args;","for i in [1..length(stripped)]","subject = strsub(subject, stripped[i], \"\");","endfor","return subject;"]},{"name":"strip_all_but","owner":36,"perms":173,"preposition":-1,"code":["\":strip_all_but(string,keep) => string with chars not in `keep' removed.\";","\"`keep' is used in match() so if it includes ], ^, or -,\";","\"] should be first, ^ should be other from first, and - should be last.\";","string = args[1];","wanted = (\"[\" + args[2]) + \"]+\";","output = \"\";","while (m = match(string, wanted))","output = output + string[m[1]..m[2]];","string = string[m[2] + 1..$];","endwhile","return output;"]},{"name":"uppercase lowercase","owner":36,"perms":173,"preposition":-1,"code":["\"lowercase(string) -- returns a lowercase version of the string.\";","\"uppercase(string) -- returns the uppercase version of the string.\";","string = args[1];","from = caps = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";","to = lower = \"abcdefghijklmnopqrstuvwxyz\";","if (verb == \"uppercase\")","from = lower;","to = caps;","endif","for i in [1..26]","string = strsub(string, from[i], to[i], 1);","endfor","return string;"]},{"name":"capitalize capitalise","owner":36,"perms":173,"preposition":-1,"code":["\"capitalizes its argument.\";","if ((string = args[1]) && (i = index(\"abcdefghijklmnopqrstuvwxyz\", string[1], 1)))","string[1] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"[i];","endif","return string;"]},{"name":"literal_object","owner":36,"perms":173,"preposition":-1,"code":["\"Matches args[1] against literal objects: #xxxxx, $variables, *mailing-lists, and username.  Returns the object if successful, $failed_match else.\";","string = args[1];","if (!string)","return $nothing;","elseif ((string[1] == \"#\") && (E_TYPE != (object = $code_utils:toobj(string))))","return object;","elseif (string[1] == \"~\")","return this:match_player(string[2..$], #0);","elseif ((string[1] == \"*\") && (length(string) > 1))","return $mail_agent:match_recipient(string);","elseif (string[1] == \"$\")","string[1..1] = \"\";","object = #0;","while (pn = string[1..(dot = index(string, \".\")) ? dot - 1 | $])","if ((!$object_utils:has_property(object, pn)) || (typeof(object = object.(pn)) != OBJ))","return $failed_match;","endif","string = string[length(pn) + 2..$];","endwhile","if ((object == #0) || (typeof(object) == ERR))","return $failed_match;","else","return object;","endif","else","return $failed_match;","endif"]},{"name":"match","owner":36,"perms":173,"preposition":-1,"code":["\"$string_utils:match(string [, obj-list, prop-name]*)\";","\"Each obj-list should be a list of objects or a single object, which is treated as if it were a list of that object.  Each prop-name should be string naming a property on every object in the corresponding obj-list.  The value of that property in each case should be either a string or a list of strings.\";","\"The argument string is matched against all of the strings in the property values.\";","\"If it exactly matches exactly one of them, the object containing that property is returned.  If it exactly matches more than one of them, $ambiguous_match is returned.\";","\"If there are no exact matches, then partial matches are considered, ones in which the given string is a prefix of some property string.  Again, if exactly one match is found, the object with that property is returned, and if there is more than one match, $ambiguous_match is returned.\";","\"Finally, if there are no exact or partial matches, then $failed_match is returned.\";","subject = args[1];","if (subject == \"\")","return $nothing;","endif","no_exact_match = no_partial_match = 1;","for i in [1..length(args) / 2]","prop_name = args[(2 * i) + 1];","for object in ((typeof(olist = args[2 * i]) == LIST) ? olist | {olist})","if (valid(object))","if (typeof(str_list = `object.(prop_name) ! E_PERM, E_PROPNF => {}') != LIST)","str_list = {str_list};","endif","if (subject in str_list)","if (no_exact_match)","no_exact_match = object;","elseif (no_exact_match != object)","return $ambiguous_match;","endif","else","for string in (str_list)","if (index(string, subject) != 1)","elseif (no_partial_match)","no_partial_match = object;","elseif (no_partial_match != object)","no_partial_match = $ambiguous_match;","endif","endfor","endif","endif","endfor","endfor","return no_exact_match && (no_partial_match && $failed_match);"]},{"name":"match_str*ing","owner":36,"perms":173,"preposition":-1,"code":["\"* wildcard matching. Returns a list of what the *s actually matched. Won't cath every match, if there are several ways to parse it.\";","\"Example: $string_utils:match_string(\\\"Jack waves to Jill\\\",\\\"* waves to *\\\") returns {\\\"Jack\\\", \\\"Jill\\\"}\";","\"Optional arguments: numbers are interpreted as case-sensitivity, strings as alternative wildcards.\";","{what, targ, @rest} = args;","wild = \"*\";","case = ret = {};","what = what + \"&^%$\";","targ = targ + \"&^%$\";","for y in (rest)","if (typeof(y) == STR)","wild = y;","elseif (typeof(y) == INT)","case = {y};","endif","endfor","while (targ != \"\")","if (z = index(targ, wild))","part = targ[1..z - 1];","else","z = length(targ);","part = targ;","endif","n = (part == \"\") ? 1 | index(what, part, @case);","if (n)","ret = listappend(ret, what[1..n - 1]);","what = what[(z + n) - 1..$];","targ = targ[z + 1..$];","else","return 0;","endif","endwhile","if (ret == {})","return what == \"\";","elseif (ret == {\"\"})","return 1;","elseif (ret[1] == \"\")","return ret[2..$];","else","return 0;","endif"]},{"name":"match_object","owner":36,"perms":173,"preposition":-1,"code":["\":match_object(string,location[,someone])\";","\"Returns the object matching the given string for someone, on the assumption that s/he is in the given location.  `someone' defaults to player.\";","\"This first tries :literal_object(string), \\\"me\\\"=>someone,\\\"here\\\"=>location, then player:match(string) and finally location:match(string) if location is valid.\";","\"This is the default algorithm for use by room :match_object() and player :my_match_object() verbs.  Player verbs that are calling this directly should probably be calling :my_match_object instead.\";","{string, here, ?who = player} = args;","if ($failed_match != (object = this:literal_object(string)))","return object;","elseif (string == \"me\")","return who;","elseif (string == \"here\")","return here;","elseif ((valid(pobject = who:match(string)) && (string in {@pobject.aliases, pobject.name})) || (!valid(here)))","\"...exact match in player or room is bogus...\";","return pobject;","elseif ((valid(hobject = here:match(string)) && (string in {@hobject.aliases, hobject.name})) || (pobject == $failed_match))","\"...exact match in room or match in player failed completely...\";","return hobject;","else","return pobject;","endif"]},{"name":"match_player","owner":36,"perms":173,"preposition":-1,"code":["\"match_player(name,name,...)      => {obj,obj,...}\";","\"match_player(name[,meobj])       => obj\";","\"match_player({name,...}[,meobj]) => {obj,...}\";","\"objs returned are either players, $failed_match, $ambiguous_match, or $nothing in the case of an empty string.\";","\"meobj (what to return for instances of `me') defaults to player; if given and isn't actually a player, `me' => $failed_match\";","retstr = 0;","me = player;","if ((length(args) < 2) || (typeof(me = args[2]) == OBJ))","me = (valid(me) && is_player(me)) ? me | $failed_match;","if (typeof(args[1]) == STR)","strings = {args[1]};","retstr = 1;","\"return a string, not a list\";","else","strings = args[1];","endif","else","strings = args;","me = player;","endif","found = {};","for astr in (strings)","if (!astr)","aobj = $nothing;","elseif (astr == \"me\")","aobj = me;","elseif (valid(aobj = $string_utils:literal_object(astr)) && is_player(aobj))","\"astr is a valid literal object number of some player, so we are done.\";","else","aobj = $player_db:find(astr);","endif","found = {@found, aobj};","endfor","return retstr ? found[1] | found;"]},{"name":"match_player_or_object","owner":36,"perms":173,"preposition":-1,"code":["\"Accepts any number of strings, attempts to match those strings first against objects in the room, and if no objects by those names exist, matches against player names (and \\\"#xxxx\\\" style strings regardless of location).  Returns a list of valid objects so found.\";","\"Unlike $string_utils:match_player, does not include in the list the failed and ambiguous matches; instead has built-in error messages for such objects.  This should probably be improved.  Volunteers?\";","if (!args)","return;","endif","unknowns = {};","objs = {};","\"We have to do something icky here.  Parallel walk the victims and args lists.  When it's a valid object, then it's a player.  If it's an invalid object, try to get an object match from the room.  If *that* fails, complain.\";","for i in [1..length(args)]","if (valid(o = player.location:match_object(args[i])))","objs = {@objs, o};","else","unknowns = {@unknowns, args[i]};","endif","endfor","victims = $string_utils:match_player(unknowns);","for i in [1..length(victims)]","if (!valid(victims[i]))","player:tell(\"Could not find \", unknowns[i], \" as either an object or a player.\");","else","objs = {@objs, victims[i]};","endif","endfor","return objs;"]},{"name":"find_prefix","owner":36,"perms":173,"preposition":-1,"code":["\"find_prefix(prefix, string-list) => list index of something starting with prefix, or 0 or $ambiguous_match.\";","{subject, choices} = args;","answer = 0;","for i in [1..length(choices)]","if (index(choices[i], subject) == 1)","if (answer == 0)","answer = i;","else","answer = $ambiguous_match;","endif","endif","endfor","return answer;"]},{"name":"index_d*elimited","owner":36,"perms":173,"preposition":-1,"code":["\"index_delimited(string,target[,case_matters]) is just like the corresponding call to the builtin index() but instead only matches on occurences of target delimited by word boundaries (i.e., not preceded or followed by an alphanumeric)\";","args[2] = (\"%(%W%|^%)\" + $string_utils:regexp_quote(args[2])) + \"%(%W%|$%)\";","return (m = match(@args)) ? m[3][1][2] + 1 | 0;"]},{"name":"is_integer is_numeric","owner":36,"perms":173,"preposition":-1,"code":["\"Usage:  is_numeric(string)\";","\"        is_integer(string)\";","\"Is string numeric (composed of one or more digits possibly preceded by a minus sign)? This won't catch floating points.\";","\"Return true or false\";","return match(args[1], \"^ *[-+]?[0-9]+ *$\");","digits = \"1234567890\";","if (!(string = args[1]))","return 0;","endif","if (string[1] == \"-\")","string = string[2..length(string)];","endif","for i in [1..length(string)]","if (!index(digits, string[i]))","return 0;","endif","endfor","return 1;"]},{"name":"ordinal","owner":36,"perms":173,"preposition":-1,"code":["\":short_ordinal(1) => \\\"1st\\\",:short_ordinal(2) => \\\"2nd\\\",etc...\";","string = tostr(n = args[1]);","n = abs(n) % 100;","if (((n / 10) != 1) && ((n % 10) in {1, 2, 3}))","return string + {\"st\", \"nd\", \"rd\"}[n % 10];","else","return string + \"th\";","endif"]},{"name":"group_number","owner":36,"perms":173,"preposition":-1,"code":["\"$string_utils:group_number(INT n [, sep_char])\";","\"$string_utils:group_number(FLOAT n, [INT precision [, scientific [, sep_char]]])\";","\"\";","\"Converts N to a string, inserting commas (or copies of SEP_CHAR, if given) every three digits, counting from the right.  For example, $string_utils:group_number(1234567890) returns the string \\\"1,234,567,890\\\".\";","\"For floats, the arguements precision (defaulting to 4 in this verb) and scientific are the same as given in floatstr().\";","if (typeof(args[1]) == INT)","{n, ?comma = \",\"} = args;","result = \"\";","sign = (n < 0) ? \"-\" | \"\";","n = tostr(abs(n));","elseif (typeof(args[1]) == FLOAT)","{n, ?prec = 4, ?scien = 0, ?comma = \",\"} = args;","sign = (n < 0.0) ? \"-\" | \"\";","n = floatstr(abs(n), prec, scien);","i = index(n, \".\");","result = n[i..$];","n = n[1..i - 1];","else","return E_INVARG;","endif","while ((len = length(n)) > 3)","result = (comma + n[len - 2..len]) + result;","n = n[1..len - 3];","endwhile","return (sign + n) + result;","\"Code contributed by SunRay\";"]},{"name":"english_number","owner":36,"perms":173,"preposition":-1,"code":["\"$string_utils:english_number(n) -- convert the integer N into English\";","\"\";","\"Produces a string containing the English phrase naming the given integer.  For example, $string_utils:english_number(-1234) returns the string `negative one thousand two hundred thirty-four'.\";","numb = toint(args[1]);","if (numb == 0)","return \"zero\";","endif","labels = {\"\", \" thousand\", \" million\", \" billion\"};","numstr = \"\";","mod = abs(numb);","for n in [1..4]","div = mod % 1000;","if (div)","hun = div / 100;","ten = div % 100;","outstr = this:english_tens(ten) + labels[n];","if (hun)","outstr = ((this:english_ones(hun) + \" hundred\") + (ten ? \" \" | \"\")) + outstr;","endif","if (numstr)","numstr = (outstr + \" \") + numstr;","else","numstr = outstr;","endif","endif","mod = mod / 1000;","endfor","return ((numb < 0) ? \"negative \" | \"\") + numstr;"]},{"name":"english_ordinal","owner":36,"perms":173,"preposition":-1,"code":["\"$string_utils:english_ordinal(n) -- convert the integer N into an english ordinal (1 => \\\"first\\\", etc...)\";","numb = toint(args[1]);","if (numb == 0)","return \"zeroth\";","elseif (numb % 100)","hundreds = (abs(numb) > 100) ? this:english_number((numb / 100) * 100) + \" \" | ((numb < 0) ? \"negative \" | \"\");","numb = abs(numb) % 100;","specials = {1, 2, 3, 5, 8, 9, 12, 20, 30, 40, 50, 60, 70, 80, 90};","ordinals = {\"first\", \"second\", \"third\", \"fifth\", \"eighth\", \"ninth\", \"twelfth\", \"twentieth\", \"thirtieth\", \"fortieth\", \"fiftieth\", \"sixtieth\", \"seventieth\", \"eightieth\", \"ninetieth\"};","if (i = numb in specials)","return hundreds + ordinals[i];","elseif ((numb > 20) && (i = (numb % 10) in specials))","return ((hundreds + this:english_tens((numb / 10) * 10)) + \"-\") + ordinals[i];","else","return (hundreds + this:english_number(numb)) + \"th\";","endif","else","return this:english_number(numb) + \"th\";","endif"]},{"name":"english_ones","owner":36,"perms":173,"preposition":-1,"code":["numb = args[1];","ones = {\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};","return ones[numb + 1];"]},{"name":"english_tens","owner":36,"perms":173,"preposition":-1,"code":["numb = args[1];","teens = {\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"};","others = {\"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};","if (numb < 10)","return this:english_ones(numb);","elseif (numb < 20)","return teens[numb - 9];","else","return (others[(numb / 10) - 1] + ((numb % 10) ? \"-\" | \"\")) + this:english_ones(numb % 10);","endif"]},{"name":"subst*itute","owner":36,"perms":173,"preposition":-1,"code":["\"subst(string,{{redex1,repl1},{redex2,repl2},{redex3,repl3}...}[,case])\";","\"  => returns string with all instances of the strings redex<n> replaced respectively by the strings repl<n>.  If the optional argument `case' is given and nonzero, the search for instances of redex<n> is case sensitive.\";","\"  Substitutions are done in parallel, i.e., instances of redex<n> that appear in any of the replacement strings are ignored.  In the event that two redexes overlap, whichever is leftmost in `string' takes precedence.  For two redexes beginning at the same position, the longer one takes precedence.\";","\"\";","\"subst(\\\"hoahooaho\\\",{{\\\"ho\\\",\\\"XhooX\\\"},{\\\"hoo\\\",\\\"mama\\\"}}) => \\\"XhooXamamaaXhooX\\\"\";","\"subst(\\\"Cc: banana\\\",{{\\\"a\\\",\\\"b\\\"},{\\\"b\\\",\\\"c\\\"},{\\\"c\\\",\\\"a\\\"}},1) => \\\"Ca: cbnbnb\\\"\";","{ostr, subs, ?case = 0} = args;","if (typeof(ostr) != STR)","return ostr;","endif","len = length(ostr);","\" - - - find the first instance of each substitution - -\";","indices = {};","substs = {};","for s in (subs)","if (i = index(ostr, s[1], case))","fi = $list_utils:find_insert(indices, i = i - len) - 1;","while (fi && ((indices[fi] == i) && (length(substs[fi][1]) < length(s[1]))))","\"...give preference to longer redexes...\";","fi = fi - 1;","endwhile","indices = listappend(indices, i, fi);","substs = listappend(substs, s, fi);","endif","endfor","\"- - - - - perform substitutions - \";","nstr = \"\";","while (substs)","ind = len + indices[1];","sub = substs[1];","indices = listdelete(indices, 1);","substs = listdelete(substs, 1);","if (ind > 0)","nstr = (nstr + ostr[1..ind - 1]) + sub[2];","ostr = ostr[ind + length(sub[1])..len];","len = length(ostr);","endif","if (next = index(ostr, sub[1], case))","fi = $list_utils:find_insert(indices, next = next - len) - 1;","while (fi && ((indices[fi] == next) && (length(substs[fi][1]) < length(sub[1]))))","\"...give preference to longer redexes...\";","fi = fi - 1;","endwhile","indices = listappend(indices, next, fi);","substs = listappend(substs, sub, fi);","endif","endwhile","return nstr + ostr;"]},{"name":"substitute_d*elimited","owner":2,"perms":13,"preposition":-1,"code":["\"subst(string,{{redex1,repl1},{redex2,repl2},{redex3,repl3}...}[,case])\";","\"Just like :substitute() but it uses index_delimited() instead of index()\";","{ostr, subs, ?case = 0} = args;","if (typeof(ostr) != STR)","return ostr;","endif","len = length(ostr);","\" - - - find the first instance of each substitution - -\";","indices = {};","substs = {};","for s in (subs)","if (i = this:index_delimited(ostr, s[1], case))","fi = $list_utils:find_insert(indices, i = i - len) - 1;","while (fi && ((indices[fi] == i) && (length(substs[fi][1]) < length(s[1]))))","\"...give preference to longer redexes...\";","fi = fi - 1;","endwhile","indices = listappend(indices, i, fi);","substs = listappend(substs, s, fi);","endif","endfor","\"- - - - - perform substitutions - \";","nstr = \"\";","while (substs)","ind = len + indices[1];","sub = substs[1];","indices = listdelete(indices, 1);","substs = listdelete(substs, 1);","if (ind > 0)","nstr = (nstr + ostr[1..ind - 1]) + sub[2];","ostr = ostr[ind + length(sub[1])..len];","len = length(ostr);","endif","if (next = this:index_delimited(ostr, sub[1], case))","fi = $list_utils:find_insert(indices, next = next - len) - 1;","while (fi && ((indices[fi] == next) && (length(substs[fi][1]) < length(sub[1]))))","\"...give preference to longer redexes...\";","fi = fi - 1;","endwhile","indices = listappend(indices, next, fi);","substs = listappend(substs, sub, fi);","endif","endwhile","return nstr + ostr;"]},{"name":"_cap_property","owner":2,"perms":173,"preposition":-1,"code":["\"cap_property(what,prop[,ucase]) returns what.(prop) but capitalized if either ucase is true or the prop name specified is capitalized.\";","\"If prop is blank, returns what:title().\";","\"If prop is bogus or otherwise irretrievable, returns the error.\";","\"If capitalization is indicated, we return what.(prop+\\\"c\\\") if that exists, else we capitalize what.(prop) in the usual fashion.  There is a special exception for is_player(what)&&prop==\\\"name\\\" where we just return what.name if no .namec is provided --- ie., a player's .name is never capitalized in the usual fashion.\";","\"If args[1] is a list, calls itself on each element of the list and returns $string_utils:english_list(those results).\";","{what, prop, ?ucase = 0} = args;","set_task_perms(caller_perms());","if (typeof(what) == LIST)","result = {};","for who in (what)","result = {@result, this:_cap_property(who, prop, ucase)};","endfor","return $string_utils:english_list(result);","endif","ucase = (prop && (strcmp(prop, \"a\") < 0)) || ucase;","if (!prop)","return valid(what) ? ucase ? what:titlec() | what:title() | ((ucase ? \"N\" | \"n\") + \"othing\");","elseif ((!ucase) || (typeof(s = `what.(prop + \"c\") ! ANY') == ERR))","if (prop == \"name\")","s = valid(what) ? what.name | \"nothing\";","ucase = ucase && (!is_player(what));","else","s = `$object_utils:has_property(what, prop) ? what.(prop) | $player.(prop) ! ANY';","endif","if (ucase && (s && ((typeof(s) == STR) && (((z = index(this.alphabet, s[1], 1)) < 27) && (z > 0)))))","s[1] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"[z];","endif","endif","return (typeof(s) == ERR) ? s | tostr(s);"]},{"name":"pronoun_sub","owner":2,"perms":173,"preposition":-1,"code":["\"Pronoun (and other things) substitution. See 'help pronouns' for details.\";","\"syntax:  $string_utils:pronoun_sub(text[,who[,thing[,location[,dobj[,iobj]]]]])\";","\"%s,%o,%p,%q,%r    => <who>'s pronouns.  <who> defaults to player.\";","\"%n,%d,%i,%t,%l,%% => <who>, dobj, iobj, <thing>, location and %\";","\"<thing> defaults to caller; <location> defaults to who.location\";","\"%S,%O,%P,%Q,%R, %N,%D,%I,%T,%L have corresponding capitalized substitutions.\";","\" %[#n], %[#d], ...  =>  <who>, dobj, etc.'s object number\";","\"%(foo) => <who>.foo and %(Foo) => <who>.foo capitalized. %[dfoo] => dobj.foo, etc..\";","\"%<foo> -> whatever <who> does when normal people foo. This is determined by calling :verb_sub() on the <who>.\";","\"%<d:foo> -> whatever <dobj> does when normal people foo.\";","{string, ?who = player, ?thing = caller, ?where = $nothing, ?dobject = dobj, ?iobject = iobj} = args;","where = valid(where) ? where | (valid(who) ? who.location | where);","set_task_perms($no_one);","if (typeof(string) == LIST)","plines = {};","for line in (string)","plines = {@plines, this:(verb)(line, who, thing, where)};","endfor","return plines;","endif","old = tostr(string);","new = \"\";","objspec = \"nditl\";","objects = {who, dobject, iobject, thing, where};","prnspec = \"sopqrSOPQR\";","prprops = {\"ps\", \"po\", \"pp\", \"pq\", \"pr\", \"Ps\", \"Po\", \"Pp\", \"Pq\", \"Pr\"};","oldlen = length(old);","while ((prcnt = index(old, \"%\")) && (prcnt < oldlen))","s = old[k = prcnt + 1];","if ((s == \"<\") && (gt = index(old[k + 2..$], \">\")))","\"handling %<verb> \";","gt = (gt + k) + 1;","vb = old[k + 1..gt - 1];","vbs = who;","if ((length(vb) > 2) && (vb[2] == \":\"))","\" %<d:verb>\";","vbs = objects[index(objspec, vb[1]) || 1];","vb = vb[3..$];","endif","vb = $object_utils:has_verb(vbs, \"verb_sub\") ? vbs:verb_sub(vb) | this:(verb)(vb, vbs);","new = (new + old[1..prcnt - 1]) + vb;","k = gt;","else","cp_args = {};","if (brace = index(\"([\", s))","if (!(w = index(old[k + 1..oldlen], \")]\"[brace])))","return new + old;","else","p = old[prcnt + 2..(k = k + w) - 1];","if (brace == 1)","\"%(property)\";","cp_args = {who, p};","elseif (p[1] == \"#\")","\"%[#n] => object number\";","s = (o = index(objspec, p[2])) ? tostr(objects[o]) | ((\"[\" + p) + \"]\");","elseif (!(o = index(objspec, p[1])))","s = (\"[\" + p) + \"]\";","else","\" %[dproperty] \";","cp_args = {objects[o], p[2..w - 1], strcmp(p[1], \"a\") < 0};","endif","endif","elseif (o = index(objspec, s))","cp_args = {objects[o], \"\", strcmp(s, \"a\") < 0};","elseif (w = index(prnspec, s, 1))","cp_args = {who, prprops[w]};","elseif (s == \"#\")","s = tostr(who);","elseif (s != \"%\")","s = \"%\" + s;","endif","new = (new + old[1..prcnt - 1]) + ((!cp_args) ? s | ((typeof(sub = $string_utils:_cap_property(@cp_args)) != ERR) ? sub | ((\"%(\" + tostr(sub)) + \")\")));","endif","old = old[k + 1..oldlen];","oldlen = oldlen - k;","endwhile","return new + old;"]},{"name":"pronoun_sub_secure","owner":36,"perms":173,"preposition":-1,"code":["\"$string_utils:pronoun_sub_secure(string[,who[,thing[,location]]], default)\";","\"Do pronoun_sub on string with the arguments given (see help\";","\"string_utils:pronoun_sub for more information).  Return pronoun_subbed\";","\"<default> if the subbed string does not contain <who>.name (<who>\";","\"defaults to player).\";","who = (length(args) > 2) ? args[2] | player;","default = args[$];","result = this:pronoun_sub(@args[1..$ - 1]);","return this:index_delimited(result, who.name) ? result | this:pronoun_sub(@{default, @args[2..$ - 1]});"]},{"name":"pronoun_quote","owner":36,"perms":173,"preposition":-1,"code":["\" pronoun_quote(string) => quoted_string\";","\" pronoun_quote(list of strings) => list of quoted_strings\";","\" pronoun_quote(list of {key,string} pairs) => list of {key,quoted_string} pairs\";","\"\";","\"Here `quoted' means quoted in the sense of $string_utils:pronoun_sub, i.e., given a string X, the corresponding `quoted' string Y is such that pronoun_sub(Y) => X.  For example, pronoun_quote(\\\"--%Spam%--\\\") => \\\"--%%Spam%%--\\\".  This is for including literal text into a string that will eventually be pronoun_sub'ed, i.e., including it in such a way that the pronoun_sub will not expand anything in the included text.\";","\"\";","\"The 3rd form above (with {key,string} pairs) is for use with $string_utils:substitute().  If you have your own set of substitutions to be done in parallel with the pronoun substitutions, do\";","\"\";","\"  msg=$string_utils:substitute(msg,$string_utils:pronoun_quote(your_substs));\";","\"  msg=$string_utils:pronoun_sub(msg);\";","if (typeof(what = args[1]) == STR)","return strsub(what, \"%\", \"%%\");","else","ret = {};","for w in (what)","if (typeof(w) == LIST)","ret = listappend(ret, listset(w, strsub(w[2], \"%\", \"%%\"), 2));","else","ret = listappend(ret, strsub(w, \"%\", \"%%\"));","endif","endfor","return ret;","endif"]},{"name":"alt_pronoun_sub","owner":2,"perms":13,"preposition":-1,"code":["\"Pronoun (and other things) substitution. See 'help pronouns' for details.\";","\"syntax:  $string_utils:pronoun_sub(text[,who[,thing[,location]]])\";","\"%s,%o,%p,%q,%r    => <who>'s pronouns.  <who> defaults to player.\";","\"%n,%d,%i,%t,%l,%% => <who>, dobj, iobj, this, <who>.location and %\";","\"%S,%O,%P,%Q,%R, %N,%D,%I,%T,%L have corresponding capitalized substitutions.\";","\" %[#n], %[#d], ...  =>  <who>, dobj, etc.'s object number\";","\"%(foo) => <who>.foo and %(Foo) => <who>.foo capitalized. %[dfoo] => dobj.foo, etc..\";","\"%<foo> -> whatever <who> does when normal people foo. This is determined by calling :verb_sub() on the <who>.\";","\"%<d:foo> -> whatever <dobj> does when normal people foo.\";","set_task_perms($no_one);","{string, ?who = player, ?thing = caller, ?where = $nothing} = args;","where = valid(who) ? who.location | where;","if (typeof(string) == LIST)","plines = {};","for line in (string)","plines = {@plines, this:(verb)(line, who, thing, where)};","endfor","return plines;","endif","old = tostr(string);","new = \"\";","objspec = \"nditl\";","objects = {who, dobj, iobj, thing, where};","prnspec = \"sopqrSOPQR\";","prprops = {\"ps\", \"po\", \"pp\", \"pq\", \"pr\", \"Ps\", \"Po\", \"Pp\", \"Pq\", \"Pr\"};","oldlen = length(old);","while ((prcnt = index(old, \"%\")) && (prcnt < oldlen))","s = old[k = prcnt + 1];","if ((s == \"<\") && (gt = index(old[k + 2..$], \">\")))","\"handling %<verb> \";","gt = (gt + k) + 1;","vb = old[k + 1..gt - 1];","vbs = who;","if ((length(vb) > 2) && (vb[2] == \":\"))","\" %<d:verb>\";","vbs = objects[index(objspec, vb[1]) || 1];","vb = vb[3..$];","endif","vb = $object_utils:has_verb(vbs, \"verb_sub\") ? vbs:verb_sub(vb) | this:(verb)(vb, vbs);","new = (new + old[1..prcnt - 1]) + vb;","k = gt;","else","cp_args = {};","if (brace = index(\"([\", s))","if (!(w = index(old[k + 1..oldlen], \")]\"[brace])))","return new + old;","else","p = old[prcnt + 2..(k = k + w) - 1];","if (brace == 1)","\"%(property)\";","cp_args = {who, p};","elseif (p[1] == \"#\")","\"%[#n] => object number\";","s = (o = index(objspec, p[2])) ? tostr(objects[o]) | ((\"[\" + p) + \"]\");","elseif (!(o = index(objspec, p[1])))","s = (\"[\" + p) + \"]\";","else","\" %[dproperty] \";","cp_args = {objects[o], p[2..w - 1], strcmp(p[1], \"a\") < 0};","endif","endif","elseif (o = index(objspec, s))","cp_args = {objects[o], \"\", strcmp(s, \"a\") < 0};","elseif (w = index(prnspec, s, 1))","cp_args = {who, prprops[w]};","elseif (s == \"#\")","s = tostr(who);","elseif (s != \"%\")","s = \"%\" + s;","endif","new = (new + old[1..prcnt - 1]) + ((!cp_args) ? s | ((typeof(sub = $string_utils:_cap_property(@cp_args)) != ERR) ? sub | ((\"%(\" + tostr(sub)) + \")\")));","endif","old = old[k + 1..oldlen];","oldlen = oldlen - k;","endwhile","return new + old;"]},{"name":"explode","owner":36,"perms":173,"preposition":-1,"code":["\"$string_utils:explode(subject [, break])\";","\"Return a list of those substrings of subject separated by runs of break[1].\";","\"break defaults to space.\";","{subject, ?breakit = {\" \"}} = args;","breakit = breakit[1];","subject = subject + breakit;","parts = {};","while (subject)","if ((i = index(subject, breakit)) > 1)","parts = {@parts, subject[1..i - 1]};","endif","subject = subject[i + 1..$];","endwhile","return parts;"]},{"name":"words","owner":36,"perms":173,"preposition":-1,"code":["\"This breaks up the argument string into words, the resulting list being obtained exactly the way the command line parser obtains `args' from `argstr'.\";","rest = args[1];","\"...trim leading blanks...\";","if (0)","rest[1..match(rest, \"^ *\")[2]] = \"\";","endif","rest = $string_utils:triml(rest);","if (!rest)","return {};","endif","quote = 0;","toklist = {};","token = \"\";","pattern = \" +%|\\\\.?%|\\\"\";","while (m = match(rest, pattern))","\"... find the next occurence of a special character, either\";","\"... a block of spaces, a quote or a backslash escape sequence...\";","char = rest[m[1]];","token = token + rest[1..m[1] - 1];","if (char == \" \")","toklist = {@toklist, token};","token = \"\";","elseif (char == \"\\\"\")","\"... beginning or end of quoted string...\";","\"... within a quoted string spaces aren't special...\";","pattern = (quote = !quote) ? \"\\\\.?%|\\\"\" | \" +%|\\\\.?%|\\\"\";","elseif (m[1] < m[2])","\"... char has to be a backslash...\";","\"... include next char literally if there is one\";","token = token + rest[m[2]];","endif","rest[1..m[2]] = \"\";","endwhile","return (rest || (char != \" \")) ? {@toklist, token + rest} | toklist;"]},{"name":"word_start","owner":36,"perms":173,"preposition":-1,"code":["\"This breaks up the argument string into words, returning a list of indices into argstr corresponding to the starting points of each of the arguments.\";","rest = args[1];","\"... find first nonspace...\";","wstart = match(rest, \"[^ ]%|$\")[1];","wbefore = wstart - 1;","rest[1..wbefore] = \"\";","if (!rest)","return {};","endif","quote = 0;","wslist = {};","pattern = \" +%|\\\\.?%|\\\"\";","while (m = match(rest, pattern))","\"... find the next occurence of a special character, either\";","\"... a block of spaces, a quote or a backslash escape sequence...\";","char = rest[m[1]];","if (char == \" \")","wslist = {@wslist, {wstart, (wbefore + m[1]) - 1}};","wstart = (wbefore + m[2]) + 1;","elseif (char == \"\\\"\")","\"... beginning or end of quoted string...\";","\"... within a quoted string spaces aren't special...\";","pattern = (quote = !quote) ? \"\\\\.?%|\\\"\" | \" +%|\\\\.?%|\\\"\";","endif","rest[1..m[2]] = \"\";","wbefore = wbefore + m[2];","endwhile","return (rest || (char != \" \")) ? {@wslist, {wstart, wbefore + length(rest)}} | wslist;"]},{"name":"to_value","owner":36,"perms":173,"preposition":-1,"code":["\":to_value(string) tries to parse string as a value (i.e., object, number, string, error, or list thereof).\";","\"Returns {1,value} or {0,error_message} according as the attempt was successful or not.\";","result = this:_tolist(string = args[1] + \"}\");","if (result[1] && (result[1] != $string_utils:space(result[1])))","return {0, tostr(\"after char \", length(string) - result[1], \":  \", result[2])};","elseif (typeof(result[1]) == INT)","return {0, \"missing } or \\\"\"};","elseif (length(result[2]) > 1)","return {0, \"comma unexpected.\"};","elseif (result[2])","return {1, result[2][1]};","else","return {0, \"missing expression\"};","endif"]},{"name":"prefix_to_value","owner":36,"perms":173,"preposition":-1,"code":["\":prefix_to_value(string) tries to parse string as a value (i.e., object, number, string, error, or list thereof).\";","\"Returns {rest-of-string,value} or {0,error_message} according as the attempt was successful or not.\";","alen = length(args[1]);","slen = length(string = this:triml(args[1]));","if (!string)","return {0, \"empty string\"};","elseif (w = index(\"{\\\"\", string[1]))","result = this:({\"_tolist\", \"_unquote\"}[w])(string[2..slen]);","if (typeof(result[1]) != INT)","return result;","elseif (result[1] == 0)","return {0, \"missing } or \\\"\"};","else","return {0, result[2], (alen - result[1]) + 1};","endif","else","thing = string[1..tlen = index(string + \" \", \" \") - 1];","if (typeof(s = this:_toscalar(thing)) != STR)","return {string[tlen + 1..slen], s};","else","return {0, s, (alen - slen) + 1};","endif","endif"]},{"name":"_tolist","owner":36,"perms":173,"preposition":-1,"code":["\"_tolist(string) --- auxiliary for :to_value()\";","rest = this:triml(args[1]);","vlist = {};","if (!rest)","return {0, {}};","elseif (rest[1] == \"}\")","return {rest[2..$], {}};","endif","while (1)","rlen = length(rest);","if (w = index(\"{\\\"\", rest[1]))","result = this:({\"_tolist\", \"_unquote\"}[w])(rest[2..rlen]);","if (typeof(result[1]) == INT)","return result;","endif","vlist = {@vlist, result[2]};","rest = result[1];","else","thing = rest[1..tlen = min(index(rest + \",\", \",\"), index(rest + \"}\", \"}\")) - 1];","if (typeof(s = this:_toscalar(thing)) == STR)","return {rlen, s};","endif","vlist = {@vlist, s};","rest = rest[tlen + 1..rlen];","endif","if (!rest)","return {0, vlist};","elseif (rest[1] == \"}\")","return {rest[2..$], vlist};","elseif (rest[1] == \",\")","rest = this:triml(rest[2..$]);","else","return {length(rest), \", or } expected\"};","endif","endwhile"]},{"name":"_unquote","owner":36,"perms":173,"preposition":-1,"code":["\"_unquote(string)   (auxiliary for :to_value())\";","\"reads string as if it were preceded by a quote, reading up to the closing quote if any, then returns the corresponding unquoted string.\";","\" => {0, string unquoted}  if there is no closing quote\";","\" => {original string beyond closing quote, string unquoted}  otherwise\";","rest = args[1];","result = \"\";","while (m = match(rest, \"\\\\.?%|\\\"\"))","\"Find the next special character\";","if (rest[pos = m[1]] == \"\\\"\")","return {rest[pos + 1..$], result + rest[1..pos - 1]};","endif","result = (result + rest[1..pos - 1]) + rest[pos + 1..m[2]];","rest = rest[m[2] + 1..$];","endwhile","return {0, result + rest};"]},{"name":"_toscalar","owner":36,"perms":173,"preposition":-1,"code":["\":_toscalar(string)  --- auxiliary for :tovalue\";","\" => value if string represents a number, object or error\";","\" => string error message otherwise\";","thing = args[1];","if (!thing)","return \"missing value\";","elseif (match(thing, \"^#?[-+]?[0-9]+ *$\"))","return (thing[1] == \"#\") ? toobj(thing) | toint(thing);","elseif (match(thing, \"^[-+]?%([0-9]+%.[0-9]*%|[0-9]*%.[0-9]+%)%(e[-+]?[0-9]+%)? *$\"))","\"matches 2. .2 3.2 3.2e3 .2e-3 3.e3\";","return `tofloat(thing) ! E_INVARG => tostr(\"Bad floating point value: \", thing)';","elseif (match(thing, \"^[-+]?[0-9]+e[-+]?[0-9]+ *$\"))","\"matches 345e4. No decimal, but has an e so still a float\";","return `tofloat(thing) ! E_INVARG => tostr(\"Bad floating point value: \", thing)';","elseif (thing[1] == \"E\")","return (e = $code_utils:toerr(thing)) ? tostr(\"unknown error code `\", thing, \"'\") | e;","elseif (thing[1] == \"#\")","return tostr(\"bogus objectid `\", thing, \"'\");","else","return tostr(\"`\", thing[1], \"' unexpected\");","endif"]},{"name":"parse_command","owner":2,"perms":173,"preposition":-1,"code":["\":parse_command(cmd_line[,player])\";","\" => {verb, {dobj, dobjstr}, {prep, prepstr}, {iobj, iobjstr}, {args, argstr},\";","\"     {dobjset, prepset, iobjset}}\";","\"This mimics the action of the builtin parser, returning what the values of the builtin variables `verb', `dobj', `dobjstr', `prepstr', `iobj', `iobjstr', `args', and `argstr' would be if `player' had typed `cmd_line'.  \";","\"`prep' is the shortened version of the preposition found.\";","\"\";","\"`dobjset' and `iobjset' are subsets of {\\\"any\\\",\\\"none\\\"} and are used to determine possible matching verbs, i.e., the matching verb must either be on `dobj' and have verb_args[1]==\\\"this\\\" or else it has verb_args[1] in `dobjset'; likewise for `iobjset' and verb_args[3]; similarly we must have verb_args[2] in `prepset'.\";","{c, ?who = player} = args;","y = $string_utils:words(c);","if (y == {})","return {};","endif","vrb = y[1];","y = y[2..$];","as = (y == {}) ? \"\" | c[length(vrb) + 2..$];","n = 1;","while ((!(gp = $code_utils:get_prep(@y[n..$]))[1]) && (n < length(y)))","n = n + 1;","endwhile","\"....\";","really = player;","player = who;","loc = who.location;","if (ps = gp[1])","ds = $string_utils:from_list(y[1..n - 1], \" \");","is = $string_utils:from_list(listdelete(gp, 1), \" \");","io = valid(loc) ? loc:match_object(is) | $string_utils:match_object(is, loc);","else","ds = $string_utils:from_list(y, \" \");","is = \"\";","io = $nothing;","endif","do = valid(loc) ? loc:match_object(ds) | $string_utils:match_object(ds, loc);","player = really;","\"....\";","dset = {\"any\", @(ds == \"\") ? {\"none\"} | {}};","\"\\\"this\\\" must be handled manually.\";","pset = {\"any\", @ps ? {$code_utils:full_prep(ps)} | {\"none\"}};","iset = {\"any\", @(is == \"\") ? {\"none\"} | {}};","return {vrb, {do, ds}, {$code_utils:short_prep(ps), ps}, {io, is}, {y, as}, {dset, pset, iset}};"]},{"name":"from_value","owner":2,"perms":173,"preposition":-1,"code":["\"$string_utils:from_value(value [, quote_strings = 0 [, list_depth = 1]])\";","\"Print the given value into a string.\";","{value, ?quote_strings = 0, ?list_depth = 1} = args;","if (typeof(value) == LIST)","if (value)","if (list_depth)","result = \"{\" + this:from_value(value[1], quote_strings, list_depth - 1);","for v in (listdelete(value, 1))","result = tostr(result, \", \", this:from_value(v, quote_strings, list_depth - 1));","endfor","return result + \"}\";","else","return \"{...}\";","endif","else","return \"{}\";","endif","elseif (quote_strings)","if (typeof(value) == STR)","result = \"\\\"\";","while (q = index(value, \"\\\"\") || index(value, \"\\\\\"))","if (value[q] == \"\\\"\")","q = min(q, index(value + \"\\\\\", \"\\\\\"));","endif","result = ((result + value[1..q - 1]) + \"\\\\\") + value[q];","value = value[q + 1..$];","endwhile","return (result + value) + \"\\\"\";","elseif (typeof(value) == ERR)","return $code_utils:error_name(value);","else","return tostr(value);","endif","else","return tostr(value);","endif"]},{"name":"print print_suspended","owner":36,"perms":173,"preposition":-1,"code":["\"$string_utils:print(value)\";","\"Print the given value into a string. == from_value(value,1,-1)\";","return toliteral(args[1]);","value = args[1];","if (typeof(value) == LIST)","if (value)","result = \"{\" + this:print(value[1]);","for val in (listdelete(value, 1))","result = tostr(result, \", \", this:print(val));","endfor","return result + \"}\";","else","return \"{}\";","endif","elseif (typeof(value) == STR)","return tostr(\"\\\"\", strsub(strsub(value, \"\\\\\", \"\\\\\\\\\"), \"\\\"\", \"\\\\\\\"\"), \"\\\"\");","elseif (typeof(value) == ERR)","return $code_utils:error_name(value);","else","return tostr(value);","endif"]},{"name":"reverse","owner":36,"perms":173,"preposition":-1,"code":["\":reverse(string) => \\\"gnirts\\\"\";","\"An example: :reverse(\\\"This is a test.\\\") => \\\".tset a si sihT\\\"\";","string = args[1];","if ((len = length(string)) > 50)","return this:reverse(string[($ / 2) + 1..$]) + this:reverse(string[1..$ / 2]);","endif","index = len;","result = \"\";","while (index > 0)","result = result + string[index];","index = index - 1;","endwhile","return result;"]},{"name":"char_list","owner":36,"perms":173,"preposition":-1,"code":["\":char_list(string) => string as a list of characters.\";","\"   e.g., :char_list(\\\"abad\\\") => {\\\"a\\\",\\\"b\\\",\\\"a\\\",\\\"d\\\"}\";","if (30 < (len = length(string = args[1])))","return {@this:char_list(string[1..$ / 2]), @this:char_list(string[($ / 2) + 1..$])};","else","l = {};","for c in [1..len]","l = {@l, string[c]};","endfor","return l;","endif"]},{"name":"regexp_quote","owner":36,"perms":173,"preposition":-1,"code":["\":regexp_quote(string)\";","\" => string with all of the regular expression special characters quoted with %\";","string = args[1];","quoted = \"\";","while (m = rmatch(string, \"[][$^.*+?%].*\"))","quoted = (\"%\" + string[m[1]..m[2]]) + quoted;","string = string[1..m[1] - 1];","endwhile","return string + quoted;"]},{"name":"connection_hostname_bsd","owner":36,"perms":173,"preposition":-1,"code":["\"Takes the output from connection_name() and returns just the host string portion of it.  Assumes you are using bsd_network style connection names.\";","s = args[1];","return (m = `match(args[1], \"^.* %(from%|to%) %([^, ]+%)\") ! ANY') ? substitute(\"%2\", m) | \"\";"]},{"name":"connection_hostname","owner":36,"perms":173,"preposition":-1,"code":["\"This is the function that should actually be called to get the host name from a connection name.  The archwizard should change _bsd so as to be calling the verb appropriate for his/her network interface.\";","return this:connection_hostname_bsd(@args);"]},{"name":"from_value_suspended","owner":2,"perms":173,"preposition":-1,"code":["\"$string_utils:from_value(value [, quote_strings = 0 [, list_depth = 1]])\";","\"Print the given value into a string.\";","\"This verb suspends as necessary for large values.\";","set_task_perms(caller_perms());","{value, ?quote_strings = 0, ?list_depth = 1} = args;","if (typeof(value) == LIST)","if (value)","if (list_depth)","result = \"{\" + this:from_value(value[1], quote_strings, list_depth - 1);","for v in (listdelete(value, 1))","$command_utils:suspend_if_needed(0);","result = tostr(result, \", \", this:from_value(v, quote_strings, list_depth - 1));","endfor","return result + \"}\";","else","return \"{...}\";","endif","else","return \"{}\";","endif","elseif (quote_strings)","if (typeof(value) == STR)","result = \"\\\"\";","while (q = index(value, \"\\\"\") || index(value, \"\\\\\"))","$command_utils:suspend_if_needed(0);","if (value[q] == \"\\\"\")","q = min(q, index(value + \"\\\\\", \"\\\\\"));","endif","result = ((result + value[1..q - 1]) + \"\\\\\") + value[q];","value = value[q + 1..$];","endwhile","return (result + value) + \"\\\"\";","elseif (typeof(value) == ERR)","return $code_utils:error_name(value);","else","return tostr(value);","endif","else","return tostr(value);","endif"]},{"name":"end_expression","owner":36,"perms":173,"preposition":-1,"code":["\":end_expression(string[,stop_at])\";","\"  assumes string starts with an expression; returns the index of the last char in expression or 0 if string appears not to be an expression.  Expression ends at any character from stop_at which occurs at top level.\";","{string, ?stop_at = \" \"} = args;","gone = 0;","paren_stack = \"\";","inquote = 0;","search = top_level_search = (\"[][{}()\\\"\" + strsub(stop_at, \"]\", \"\")) + \"]\";","paren_search = \"[][{}()\\\"]\";","while (m = match(string, search))","char = string[m[1]];","string[1..m[2]] = \"\";","gone = gone + m[2];","if (char == \"\\\"\")","\"...skip over quoted string...\";","char = \"\\\\\";","while (char == \"\\\\\")","if (!(m = match(string, \"%(\\\\.?%|\\\"%)\")))","return 0;","endif","char = string[m[1]];","string[1..m[2]] = \"\";","gone = gone + m[2];","endwhile","elseif (index(\"([{\", char))","\"... push parenthesis...\";","paren_stack[1..0] = char;","search = paren_search;","elseif (i = index(\")]}\", char))","if (paren_stack && (\"([{\"[i] == paren_stack[1]))","\"... pop parenthesis...\";","paren_stack[1..1] = \"\";","search = paren_stack ? paren_search | top_level_search;","else","\"...parenthesis mismatch...\";","return 0;","endif","else","\"... stop character ...\";","return gone - 1;","endif","endwhile","return (!paren_stack) && (gone + length(string));"]},{"name":"first_word","owner":36,"perms":173,"preposition":-1,"code":["\":first_word(string) => {first word, rest of string} or {}\";","rest = args[1];","\"...trim leading blanks...\";","rest[1..match(rest, \"^ *\")[2]] = \"\";","if (!rest)","return {};","endif","quote = 0;","token = \"\";","pattern = \" +%|\\\\.?%|\\\"\";","while (m = match(rest, pattern))","\"... find the next occurence of a special character, either\";","\"... a block of spaces, a quote or a backslash escape sequence...\";","char = rest[m[1]];","token = token + rest[1..m[1] - 1];","if (char == \" \")","rest[1..m[2]] = \"\";","return {token, rest};","elseif (char == \"\\\"\")","\"... beginning or end of quoted string...\";","\"... within a quoted string spaces aren't special...\";","pattern = (quote = !quote) ? \"\\\\.?%|\\\"\" | \" +%|\\\\.?%|\\\"\";","elseif (m[1] < m[2])","\"... char has to be a backslash...\";","\"... include next char literally if there is one\";","token = token + rest[m[2]];","endif","rest[1..m[2]] = \"\";","endwhile","return {token + rest, \"\"};"]},{"name":"common","owner":36,"perms":173,"preposition":-1,"code":["\":common(first,second) => length of longest common prefix\";","{first, second} = args;","r = min(length(first), length(second));","l = 1;","while (r >= l)","h = (r + l) / 2;","if (first[l..h] == second[l..h])","l = h + 1;","else","r = h - 1;","endif","endwhile","return r;"]},{"name":"title_list*c list_title*c","owner":36,"perms":173,"preposition":-1,"code":["\"wr_utils:title_list/title_listc(<obj-list>[, @<args>)\";","\"Creates an english list out of the titles of the objects in <obj-list>.  Optional <args> are passed on to $string_utils:english_list.\";","\"title_listc uses :titlec() for the first item.\";","titles = $list_utils:map_verb(args[1], \"title\");","if (verb[length(verb)] == \"c\")","if (titles)","titles[1] = args[1][1]:titlec();","elseif (length(args) > 1)","args[2] = $string_utils:capitalize(args[2]);","else","args = listappend(args, \"Nothing\");","endif","endif","return $string_utils:english_list(titles, @args[2..$]);"]},{"name":"name_and_number nn name_and_number_list nn_list","owner":36,"perms":173,"preposition":-1,"code":["\"name_and_number(object [,sepr] [,english_list_args]) => \\\"ObjectName (#object)\\\"\";","\"Return name and number for OBJECT.  Second argument is optional separator (for those who want no space, use \\\"\\\").  If OBJECT is a list of objects, this maps the above function over the list and then passes it to $string_utils:english_list.\";","\"The third through nth arguments to nn_list corresponds to the second through nth arguments to English_list, and are passed along untouched.\";","{objs, ?sepr = \" \", @eng_args} = args;","if (typeof(objs) != LIST)","objs = {objs};","endif","name_list = {};","for what in (objs)","name = valid(what) ? what.name | {\"<invalid>\", \"$nothing\", \"$ambiguous_match\", \"$failed_match\"}[1 + (what in {#-1, #-2, #-3})];","name = tostr(name, sepr, \"(\", what, \")\");","name_list = {@name_list, name};","endfor","return this:english_list(name_list, @eng_args);"]},{"name":"columnize_suspended columnise_suspended","owner":36,"perms":173,"preposition":-1,"code":["\"columnize_suspended (interval, items, n [, width]) - Turn a one-column list of items into an n-column list, suspending for `interval' seconds as necessary. 'width' is the last character position that may be occupied; it defaults to a standard screen width. Example: To tell the player a list of numbers in three columns, do 'player:tell_lines ($string_utils:columnize_suspended(0, {1, 2, 3, 4, 5, 6, 7}, 3));'.\";","{interval, items, n, ?width = 79} = args;","height = ((length(items) + n) - 1) / n;","items = {@items, @$list_utils:make((height * n) - length(items), \"\")};","colwidths = {};","for col in [1..n - 1]","colwidths = listappend(colwidths, 1 - (((width + 1) * col) / n));","endfor","result = {};","for row in [1..height]","line = tostr(items[row]);","for col in [1..n - 1]","$command_utils:suspend_if_needed(interval);","line = tostr(this:left(line, colwidths[col]), \" \", items[row + (col * height)]);","endfor","result = listappend(result, line[1..min($, width)]);","endfor","return result;"]},{"name":"a_or_an","owner":36,"perms":173,"preposition":-1,"code":["\":a_or_an(<noun>) => \\\"a\\\" or \\\"an\\\"\";","\"To accomodate personal variation (e.g., \\\"an historical book\\\"), a player can override this by having a personal a_or_an verb.  If that verb returns 0 instead of a string, the standard algorithm is used.\";","noun = args[1];","if ($object_utils:has_verb(player, \"a_or_an\") && ((custom_result = player:a_or_an(noun)) != 0))","return custom_result;","endif","if (noun in this.use_article_a)","return \"a\";","endif","if (noun in this.use_article_an)","return \"an\";","endif","a_or_an = \"a\";","if (noun != \"\")","if (index(\"aeiou\", noun[1]))","a_or_an = \"an\";","\"unicycle, unimplemented, union, united, unimpressed, unique\";","if ((((noun[1] == \"u\") && (length(noun) > 2)) && (noun[2] == \"n\")) && ((index(\"aeiou\", noun[3]) == 0) || (((noun[3] == \"i\") && (length(noun) > 3)) && (index(\"aeioubcghqwyz\", noun[4]) || ((length(noun) > 4) && index(\"eiy\", noun[5]))))))","a_or_an = \"a\";","endif","endif","endif","return a_or_an;","\"Ported by Mickey with minor tweaks from a Moo far far away.\";","\"Last modified Sun Aug  1 22:53:07 1993 EDT by BabyBriar (#2).\";"]},{"name":"index_all","owner":36,"perms":173,"preposition":-1,"code":["\"index_all(string,target) -- returns list of positions of target in string.\";","\"Usage: $string_utils:index_all(<string,pattern>)\";","\"       $string_utils:index_all(\\\"aaabacadae\\\",\\\"a\\\")\";","{line, pattern} = args;","if ((typeof(line) != STR) || (typeof(pattern) != STR))","return E_TYPE;","else","where = {};","place = -1;","next = 0;","while ((place = index(line[next + 1..$], pattern)) != 0)","where = {@where, place + next};","next = ((place + next) + length(pattern)) - 1;","endwhile","return where;","endif"]},{"name":"match_stringlist match_string_list","owner":36,"perms":165,"preposition":-1,"code":["\"Copied from Puff (#1449):match_stringlist Tue Oct 19 08:18:13 1993 PDT\";","\"$string_utils:match_stringlist(string, {list of strings})\";","\"The list of strings should be just that, a list of strings.  The first string is matched against the list of strings.\";","\"If it exactly matches exactly one of them, the index of the match is returned. If it exactly matches more than one of them, $ambiguous_match is returned.\";","\"If there are no exact matches, then partial matches are considered, ones in which the given string is a prefix of one of the strings.\";","\"Again, if exactly one match is found, the index of that string is returned, and if more than one match is found, $ambiguous match is returned.\";","\"Finally, if there are no exact or partial matches, then $failed_match is returned.\";","{subject, stringlist} = args;","if ((subject == \"\") || (length(stringlist) < 1))","return $nothing;","endif","matches = {};","\"First check for exact matches.\";","for i in [1..length(stringlist)]","if (subject == stringlist[i])","matches = {@matches, i};","endif","endfor","\"Now return a match, or $ambiguous, or check for partial matches.\";","if (length(matches) == 1)","return matches[1];","elseif (length(matches) > 1)","return $ambiguous_match;","elseif (length(matches) == 0)","\"Checking for partial matches is almost identical to checking for exact matches, but we use index(list[i], target) instead of list[i] == target to see if they match.\";","for i in [1..length(stringlist)]","if (index(stringlist[i], subject) == 1)","matches = {@matches, i};","endif","endfor","if (length(matches) == 1)","return matches[1];","elseif (length(matches) > 1)","return $ambiguous_match;","elseif (length(matches) == 0)","return $failed_match;","endif","endif"]},{"name":"from_ASCII","owner":36,"perms":173,"preposition":-1,"code":["\"This converts a ASCII character code in the range [32..126] into the ASCII character with that code, represented as a one-character string.\";","\"\";","\"Example:   $string_utils:from_ASCII(65) => \\\"A\\\"\";","code = args[1];","return this.ascii[code - 31];"]},{"name":"to_ASCII","owner":36,"perms":173,"preposition":-1,"code":["\"Convert a one-character string into the ASCII character code for that character.\";","\"\";","\"Example:  $string_utils:to_ASCII(\\\"A\\\") => 65\";","return (index(this.ascii, args[1], 1) || raise(E_INVARG)) + 31;"]},{"name":"abbreviated_value","owner":36,"perms":173,"preposition":-1,"code":["\"Copied from Mickey (#52413):abbreviated_value Fri Sep  9 08:52:41 1994 PDT\";","\":abbreviated_value(value,max_reslen,max_lstlev,max_lstlen,max_strlen,max_toklen)\";","\"\";","\"Gets the printed representation of value, subject to these parameters:\";","\" max_reslen = Maximum desired result string length.\";","\" max_lstlev = Maximum list level to show.\";","\" max_lstlen = Maximum list length to show.\";","\" max_lstlen = Maximum string length to show.\";","\" max_lstlen = Maximum token length (e.g., numbers and errors) to show.\";","\"\";","\"A best attempt is made to get the exact target size, but in some cases the result is not exact.\";","{value, ?max_reslen = $maxint, ?max_lstlev = $maxint, ?max_lstlen = $maxint, ?max_strlen = $maxint, ?max_toklen = $maxint} = args;","return this:_abbreviated_value(value, max_reslen, max_lstlev, max_lstlen, max_strlen, max_toklen);","\"Originally written by Mickey.\";"]},{"name":"_abbreviated_value","owner":36,"perms":173,"preposition":-1,"code":["\"Copied from Mickey (#52413):_abbreviated_value Fri Sep  9 08:52:44 1994 PDT\";","\"Internal to :abbreviated_value.  Do not call this directly.\";","{value, max_reslen, max_lstlev, max_lstlen, max_strlen, max_toklen} = args;","if ((type = typeof(value)) == LIST)","if (!value)","return \"{}\";","elseif (max_lstlev == 0)","return \"{...}\";","else","n = length(value);","result = \"{\";","r = max_reslen - 2;","i = 1;","eltstr = \"\";","while (((i <= n) && (i <= max_lstlen)) && (r > (x = (i == 1) ? 0 | 2)))","eltlen = length(eltstr = this:(verb)(value[i], r, max_lstlev - 1, max_lstlen, max_strlen, max_toklen));","lastpos = 1;","if (r >= (eltlen + x))","comma = (i == 1) ? \"\" | \", \";","result = tostr(result, comma);","if (r > 4)","lastpos = length(result);","endif","result = tostr(result, eltstr);","r = (r - eltlen) - x;","elseif (i == 1)","return \"{...}\";","elseif (r > 4)","return tostr(result, \", ...}\");","else","return tostr(result[1..lastpos], \"...}\");","endif","i = i + 1;","endwhile","if (i <= n)","if (i == 1)","return \"{...}\";","elseif (r > 4)","return tostr(result, \", ...}\");","else","return tostr(result[1..lastpos], \"...}\");","endif","else","return tostr(result, \"}\");","endif","endif","elseif (type == STR)","result = \"\\\"\";","while ((q = index(value, \"\\\"\")) ? q = min(q, index(value, \"\\\\\")) | (q = index(value, \"\\\\\")))","result = ((result + value[1..q - 1]) + \"\\\\\") + value[q];","value = value[q + 1..$];","endwhile","result = result + value;","if ((length(result) + 1) > (z = max(min(max_reslen, max(max_strlen, max_strlen + 2)), 6)))","z = z - 5;","k = 0;","while ((k < z) && (result[z - k] == \"\\\\\"))","k = k + 1;","endwhile","return tostr(result[1..z - (k % 2)], \"\\\"+...\");","else","return tostr(result, \"\\\"\");","endif","else","v = (type == ERR) ? $code_utils:error_name(value) | tostr(value);","len = max(4, min(max_reslen, max_toklen));","return (length(v) > len) ? v[1..len - 3] + \"...\" | v;","endif","\"Originally written by Mickey.\";"]},{"name":"match_suspended","owner":36,"perms":173,"preposition":-1,"code":["\"$string_utils:match_suspended(string [, obj-list, prop-name]*)\";","\"Each obj-list should be a list of objects or a single object, which is treated as if it were a list of that object.  Each prop-name should be string naming a property on every object in the corresponding obj-list.  The value of that property in each case should be either a string or a list of strings.\";","\"The argument string is matched against all of the strings in the property values.\";","\"If it exactly matches exactly one of them, the object containing that property is returned.  If it exactly matches more than one of them, $ambiguous_match is returned.\";","\"If there are no exact matches, then partial matches are considered, ones in which the given string is a prefix of some property string.  Again, if exactly one match is found, the object with that property is returned, and if there is more than one match, $ambiguous_match is returned.\";","\"Finally, if there are no exact or partial matches, then $failed_match is returned.\";","\"This verb will suspend as needed, and should be used if obj-list is very large.\";","subject = args[1];","if (subject == \"\")","return $nothing;","endif","no_exact_match = no_partial_match = 1;","for i in [1..length(args) / 2]","prop_name = args[(2 * i) + 1];","for object in ((typeof(olist = args[2 * i]) == LIST) ? olist | {olist})","if (valid(object))","if (typeof(str_list = `object.(prop_name) ! E_PERM, E_PROPNF => {}') != LIST)","str_list = {str_list};","endif","if (subject in str_list)","if (no_exact_match)","no_exact_match = object;","elseif (no_exact_match != object)","return $ambiguous_match;","endif","else","for string in (str_list)","if (index(string, subject) != 1)","elseif (no_partial_match)","no_partial_match = object;","elseif (no_partial_match != object)","no_partial_match = $ambiguous_match;","endif","endfor","endif","endif","$command_utils:suspend_if_needed(5);","endfor","endfor","return no_exact_match && (no_partial_match && $failed_match);"]},{"name":"incr_alpha","owner":36,"perms":173,"preposition":-1,"code":["\"args[1] is a string.  'increments' the string by one. E.g., aaa => aab, aaz => aba.  empty string => a, zzz => aaaa.\";","\"args[2] is optional alphabet to use instead of $string_utils.alphabet.\";","{s, ?alphabet = this.alphabet} = args;","index = length(s);","if (!s)","return alphabet[1];","elseif (s[$] == alphabet[$])","return this:incr_alpha(s[1..index - 1], alphabet) + alphabet[1];","else","t = index(alphabet, s[index]);","return s[1..index - 1] + alphabet[t + 1];","endif"]},{"name":"is_float","owner":36,"perms":173,"preposition":-1,"code":["\"Usage:  is_float(string)\";","\"Is string composed of one or more digits possibly preceded by a minus sign either followed by a decimal or by an exponent?\";","\"Return true or false\";","return match(args[1], \"^ *[-+]?%(%([0-9]+%.[0-9]*%|[0-9]*%.[0-9]+%)%(e[-+]?[0-9]+%)?%)%|%([0-9]+e[-+]?[0-9]+%) *$\");"]},{"name":"inside_quotes","owner":36,"perms":165,"preposition":-1,"code":["\"Copied from Moo_tilities (#332):inside_quotes by Mooshie (#106469) Tue Dec 23 10:26:49 1997 PST\";","\"Usage: inside_quotes(STR)\";","\"Is the  end of the given string `inside' a doublequote?\";","\"Called from $code_utils:substitute.\";","{string} = args;","quoted = 0;","while (i = index(string, \"\\\"\"))","if ((!quoted) || (string[i - 1] != \"\\\\\"))","quoted = !quoted;","endif","string = string[i + 1..$];","endwhile","return quoted;"]},{"name":"strip_all_but_seq","owner":36,"perms":173,"preposition":-1,"code":["\":strip_all_but_seq(string, keep) => chars in string not in exact sequence of keep removed.\";","\":strip_all_but() works similarly, only it does not concern itself with the sequence, just the specified chars.\";","string = args[1];","wanted = args[2];","output = \"\";","while (m = match(string, wanted))","output = output + string[m[1]..m[2]];","string = string[m[2] + 1..length(string)];","endwhile","return output;"]},{"name":"make_exit","owner":2,"perms":173,"preposition":-1,"code":["\"make_exit(spec, source, dest[, use-$recycler-pool [, kind]])\";","\"\";","\"Uses $recycler by default; supplying fourth arg as 0 suppresses this.\";","\"Optional 5th arg gives a parent for the object to be created\";","\"(i.e., distinct from $exit)\";","\"Returns the object number as a list if successful, 0 if not.\";","set_task_perms(caller_perms());","{spec, source, dest, ?use_recycler, ?exit_kind = $exit} = args;","exit = player:_create(exit_kind);","if (typeof(exit) == ERR)","player:notify(tostr(\"Cannot create new exit as a child of \", $string_utils:nn(exit_kind), \": \", exit, \".  See `help @build-options' for information on how to specify the kind of exit this command tries to create.\"));","return;","endif","for f in ($string_utils:char_list(player:build_option(\"create_flags\") || \"\"))","exit.(f) = 1;","endfor","$building_utils:set_names(exit, spec);","exit.source = source;","exit.dest = dest;","source_ok = source:add_exit(exit);","dest_ok = dest:add_entrance(exit);","move(exit, $nothing);","via = $string_utils:from_value(setadd(exit.aliases, exit.name), 1);","if (source_ok)","player:tell(\"Exit from \", source.name, \" (\", source, \") to \", dest.name, \" (\", dest, \") via \", via, \" created with id \", exit, \".\");","if (!dest_ok)","player:tell(\"However, I couldn't add \", exit, \" as a legal entrance to \", dest.name, \".  You may have to get its owner, \", dest.owner.name, \" to add it for you.\");","endif","return {exit};","elseif (dest_ok)","player:tell(\"Exit to \", dest.name, \" (\", dest, \") via \", via, \" created with id \", exit, \".  However, I couldn't add \", exit, \" as a legal exit from \", source.name, \".  Get its owner, \", source.owner.name, \" to add it for you.\");","return {exit};","else","player:_recycle(exit);","player:tell(\"I couldn't add a new exit as EITHER a legal exit from \", source.name, \" OR as a legal entrance to \", dest.name, \".  Get their owners, \", source.owner.name, \" and \", dest.owner.name, \", respectively, to add it for you.\");","return 0;","endif"]},{"name":"set_names","owner":2,"perms":173,"preposition":-1,"code":["\"$building_utils:set_names(object, spec)\";","set_task_perms(caller_perms());","object = args[1];","names = this:parse_names(args[2]);","name = names[1] || object.name;","return object:set_name(name) && object:set_aliases(names[2]);"]},{"name":"recreate","owner":2,"perms":173,"preposition":-1,"code":["\":recreate(object,newparent) -- effectively recycle and recreate the specified object as a child of parent.  Returns true if successful.\";","{object, parent} = args;","who = caller_perms();","if (!(valid(object) && valid(parent)))","return E_INVARG;","elseif (who.wizard)","\"no problemo\";","elseif ((who != object.owner) || ((who != parent.owner) && (!parent.f)))","return E_PERM;","endif","\"Chparent any children to their grandparent instead of orphaning them horribly.  Have to do the chparent with wizperms, in case the children are owned by others, so do this before set_task_perms.\";","\"Because this is done before set_task_perms() -- thus with wizard perms -- we save ticks and use chparent() instead of #0:chparent().  This will save many more ticks, if this is an object with many children.\";","grandpa = parent(object);","for c in (children(object))","chparent(c, grandpa);","endfor","for item in (object.contents)","if (!is_player(item))","move(item, #-1);","else","move(item, $player_start);","endif","endfor","set_task_perms(who);","if ($object_utils:has_callable_verb(object, \"recycle\"))","object:recycle();","endif","chparent(object, #-1);","for p in (properties(object))","delete_property(object, p);","endfor","for v in (verbs(object))","delete_verb(object, 1);","endfor","chparent(object, parent);","object.name = \"\";","object.r = 0;","object.f = 0;","object.w = 0;","if ($object_utils:has_callable_verb(parent, \"initialize\"))","object:initialize();","endif","return 1;"]},{"name":"transfer_ownership(useless)","owner":2,"perms":169,"preposition":-1,"code":["\"transfer_ownership(object, oldowner, newowner)\";","\"Transfer ownership of object from oldowner to newowner.\";","if (!((caller == this) || caller_perms().wizard))","return E_PERM;","endif","what = args[1];","if (valid(from = args[2]) && (typeof(from.owned_objects) == LIST))","from.owned_objects = setremove(from.owned_objects, what);","endif","if (valid(to = args[3]) && (typeof(from.owned_objects) == LIST))","to.owned_objects = setadd(to.owned_objects, what);","$wiz_utils:set_owner(what, to);","endif"]},{"name":"parse_names","owner":2,"perms":173,"preposition":-1,"code":["\"$building_utils:parse_names(spec)\";","\"Return {name, {alias, alias, ...}} from name,alias,alias or name:alias,alias\";","spec = args[1];","if (!(colon = index(spec, \":\")))","aliases = $string_utils:explode(spec, \",\");","name = aliases[1];","else","aliases = $string_utils:explode(spec[colon + 1..$], \",\");","name = spec[1..colon - 1];","endif","return {name, $list_utils:map_arg($string_utils, \"trim\", aliases)};"]},{"name":"audit_object_category","owner":2,"perms":173,"preposition":-1,"code":["if (is_player(what = args[1]))","return \"P\";","endif","while (valid(what))","if (i = what in this.classes)","return this.class_string[i];","endif","what = parent(what);","endwhile","return \" \";"]},{"name":"object_audit_string","owner":2,"perms":173,"preposition":-1,"code":["\":object_audit_string(object [,prospectus-style])\";","{o, ?prospectus = 0} = args;","olen = length(tostr(max_object()));","if (!$recycler:valid(o))","return tostr(prospectus ? \"          \" | \"\", $quota_utils.byte_based ? \"    \" | \"\", $string_utils:right(o, olen), \" Invalid Object!\");","endif","if (prospectus)","kids = 0;","for k in (children(o))","$command_utils:suspend_if_needed(0);","if (k.owner != o.owner)","kids = 2;","break k;","elseif (kids == 0)","kids = 1;","endif","endfor","\"The verbs() call below might fail, but that's OK\";","\"Well, actually it won't cuz we seem to be a wizard.  Since you can get the number of verbs information from @verbs anyway, it seems kind of pointless to hide it here.\";","v = verbs(o);","if (v)","vstr = tostr(\"[\", $string_utils:right(length(v), 3), \"] \");","else","vstr = \"      \";","endif","if (o.r && o.f)","r = \"f\";","elseif (o.r)","r = \"r\";","elseif (o.f)","r = \"F\";","else","r = \" \";","endif","vstr = tostr(\" kK\"[kids + 1], r, $building_utils:audit_object_category(o), vstr);","else","vstr = \"\";","endif","if ($quota_utils.byte_based)","vstr = tostr(this:size_string(`o.object_size[1] ! ANY => 0'), \" \", vstr);","name_field_len = 26;","else","name_field_len = 30;","endif","if (valid(o.location))","loc = ((((o.location.owner == o.owner) ? \" \" | \"*\") + \"[\") + o.location.name) + \"]\";","elseif ($object_utils:has_property(o, \"dest\") && $object_utils:has_property(o, \"source\"))","if (typeof(o.source) != OBJ)","source = \" <non-object> \";","elseif (!valid(o.source))","source = \"<invalid>\";","else","source = o.source.name;","if (o.source.owner != o.owner)","source = \"*\" + source;","endif","endif","if (typeof(o.dest) != OBJ)","destin = \" <non-object> \";","elseif (!valid(o.dest))","destin = \"<invalid>\";","else","destin = o.dest.name;","if (o.dest.owner != o.owner)","destin = \"*\" + destin;","endif","endif","srclen = min(length(source), 19);","destlen = min(length(destin), 19);","loc = ((\" \" + source[1..srclen]) + \"->\") + destin[1..destlen];","elseif ($object_utils:isa(o, $room))","loc = \"\";","try","for x in (o.entrances)","if (((((typeof(x) == OBJ) && valid(x)) && (x.owner != o.owner)) && $object_utils:has_property(x, \"dest\")) && (x.dest == o))","loc = ((loc + (loc ? \", \" | \"\")) + \"<-*\") + x.name;","endif","endfor","except (ANY)","if ($perm_utils:controls(player, o))","loc = \" BROKEN PROPERTY: .entrances\";","endif","endtry","else","loc = \" [Nowhere]\";","endif","if (length(loc) > 41)","loc = loc[1..37] + \"..]\";","endif","namelen = min(length(o.name), name_field_len - 1);","return tostr(vstr, $string_utils:right(o, olen), \" \", $string_utils:left(o.name[1..namelen], name_field_len), loc);"]},{"name":"do_audit do_prospectus","owner":2,"perms":173,"preposition":-1,"code":["\":do_audit(who, start, end, match)\";","\"audit who, with objects from start to end that match 'match'\";","\":do_prospectus(...)\";","\"same, but with verb counts\";","{who, start, end, match} = args;","pros = verb == \"do_prospectus\";","\"the set_task_perms is to make the task owned by the player. There are no other security aspects\";","set_task_perms(caller_perms());","if ((((((start == 0) && (end == toint(max_object()))) && (!match)) && (typeof(who.owned_objects) == LIST)) && (length(who.owned_objects) > 100)) && (!$command_utils:yes_or_no(tostr(who.name, \" has \", length(who.owned_objects), \" objects.  This will be a very long list.  Do you wish to proceed?\"))))","v = pros ? \"@prospectus\" | \"@audit\";","return player:tell(v, \" aborted.  Usage:  \", v, \" [player] [from <start>] [to <end>] [for <match>]\");","endif","player:tell(tostr(\"Objects owned by \", who.name, \" (from #\", start, \" to #\", end, match ? \" matching \" + match | \"\", \")\", \":\"));","count = bytes = 0;","if (typeof(who.owned_objects) == LIST)","for o in (who.owned_objects)","$command_utils:suspend_if_needed(0);","if (!player:is_listening())","return;","endif","if ((toint(o) >= start) && (toint(o) <= end))","didit = this:do_audit_item(o, match, pros);","count = count + didit;","if ((didit && $quota_utils.byte_based) && $object_utils:has_property(o, \"object_size\"))","bytes = bytes + o.object_size[1];","endif","endif","endfor","else","for i in [start..end]","$command_utils:suspend_if_needed(0);","o = toobj(i);","if ($recycler:valid(o) && (o.owner == who))","didit = this:do_audit_item(o, match, pros);","count = count + didit;","if ((didit && $quota_utils.byte_based) && $object_utils:has_property(o, \"object_size\"))","bytes = bytes + o.object_size[1];","endif","endif","endfor","endif","player:tell($string_utils:left(tostr(\"-- \", count, \" object\", (count == 1) ? \".\" | \"s.\", $quota_utils.byte_based ? tostr(\"  Total bytes: \", $string_utils:group_number(bytes), \".\") | \"\"), player:linelen() - 1, \"-\"));"]},{"name":"do_audit_item","owner":2,"perms":173,"preposition":-1,"code":["\":do_audit_item(object, match-name-string, prospectus-flag)\";","{o, match, pros} = args;","found = match ? 0 | 1;","names = `{o.name, @o.aliases} ! ANY => {o.name}';","\"Above to get rid of screwed up aliases\";","while (names && (!found))","if (index(names[1], match) == 1)","found = 1;","endif","names = listdelete(names, 1);","endwhile","if (found)","\"From Dred---don't wrap long lines.\";","line = $building_utils:object_audit_string(o, pros);","player:tell(line[1..min($, player:linelen())]);","return 1;","endif","return 0;"]},{"name":"size_string","owner":2,"perms":173,"preposition":-1,"code":["size = args[1];","if (!size)","return \" ???\";","elseif (size < 1000)","return \" <1K\";","elseif (size < 1000000)","return tostr($string_utils:right(size / 1000, 3), \"K\");","else","return tostr($string_utils:right(size / 1000000, 3), \"M\");","endif"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","pass();","this.classes = {$player, $room, $exit, $note, $container, $thing, $feature, $mail_recipient, $generic_help, $generic_db, $generic_utils, $generic_options};","endif"]},{"name":"errors","owner":36,"perms":173,"preposition":-1,"code":["text = args[1];","for i in [1..length($code_utils.error_list)]","text = {@text, tostr(\"    \", $string_utils:left($code_utils.error_names[i], 15), $code_utils.error_list[i])};","endfor","return text;"]},{"name":"prepositions","owner":36,"perms":173,"preposition":-1,"code":["text = args[1];","for p in ($code_utils:prepositions())","text = {@text, tostr($string_utils:space(4), p)};","endfor","return text;"]},{"name":"set_programmer","owner":2,"perms":173,"preposition":-1,"code":["\":set_programmer(victim[,mail from])  => 1 or error.\";","\"Sets victim.programmer, chparents victim to $prog if necessary, and sends mail to $new_prog_log, mail is from optional second arg or caller_perms().\";","whodunnit = caller_perms();","{victim, ?mailfrom = whodunnit} = args;","if (!whodunnit.wizard)","return E_PERM;","elseif (!(valid(victim) && (is_player(victim) && $object_utils:isa(victim, $player))))","return E_INVARG;","elseif (victim.programmer)","return E_NONE;","elseif (this:check_prog_restricted(victim))","return E_INVARG;","elseif (typeof(e = `victim.programmer = 1 ! ANY') == ERR)","return e;","else","$quota_utils:adjust_quota_for_programmer(victim);","if (!$object_utils:isa(victim, $prog))","if (typeof(e = `chparent(victim, $prog) ! ANY') == ERR)","\"...this isn't really supposed to happen but it could...\";","player:notify(tostr(\"chparent(\", victim, \",\", $prog, \") failed:  \", e));","player:notify(\"Check for common properties.\");","endif","else","player:notify(tostr(victim.name, \" was already a child of \", parent(victim).name, \" (\", parent(victim), \")\"));","endif","if (!$mail_agent:send_message(mailfrom, {$new_prog_log, victim}, tostr(\"@programmer \", victim.name, \" (\", victim, \")\"), tostr(\"I just gave \", victim.name, \" a programmer bit.\"))[1])","$mail_agent:send_message(mailfrom, {$new_prog_log}, tostr(\"@programmer \", victim.name, \" (\", victim, \")\"), tostr(\"I just gave \", victim.name, \" a programmer bit.\"));","endif","return 1;","endif"]},{"name":"set_player","owner":2,"perms":173,"preposition":-1,"code":["\":set_player(victim[,nochown]) => 1 or error\";","\"Set victim's player flag, (maybe) chown to itself, add name and aliases to $player_db.\";","\" E_NONE == already a player,\";","\" E_NACC == player_db is frozen,\";","\" E_RECMOVE == name is unavailable\";","{victim, ?nochown = 0} = args;","if (!caller_perms().wizard)","return E_PERM;","elseif (!(valid(victim) && $object_utils:isa(victim, $player)))","return E_INVARG;","elseif (is_player(victim))","return E_NONE;","elseif ($player_db.frozen)","return E_NACC;","elseif (!$player_db:available(name = victim.name))","return E_RECMOVE;","else","set_player_flag(victim, 1);","if (0 && $object_utils:isa(victim, $prog))","victim.programmer = 1;","else","victim.programmer = $player.programmer;","endif","if (!nochown)","$wiz_utils:set_owner(victim, victim);","endif","$player_db:insert(name, victim);","for a in (setremove(aliases = victim.aliases, name))","if (index(a, \" \"))","\"..ignore ..\";","elseif ($player_db:available(a) in {this, 1})","$player_db:insert(a, victim);","else","aliases = setremove(aliases, a);","endif","endfor","victim.aliases = setadd(aliases, name);","return 1;","endif"]},{"name":"set_owner","owner":2,"perms":173,"preposition":-1,"code":["\":set_owner(object,newowner[,suspendok])  does object.owner=newowner, taking care of c properties as well.  This should be used anyplace one is contemplating doing object.owner=newowner, since the latter leaves ownership of c properties unchanged.  (--Rog thinks this is a server bug).\";","{object, newowner, ?suspendok = 0} = args;","if (!valid(object))","return E_INVIND;","elseif (!caller_perms().wizard)","return E_PERM;","elseif (!(valid(newowner) && is_player(newowner)))","return E_INVARG;","endif","oldowner = object.owner;","object.owner = newowner;","for pname in ($object_utils:all_properties(object))","if (suspendok && ((ticks_left() < 5000) || (seconds_left() < 2)))","suspend(0);","endif","perms = property_info(object, pname)[2];","if (index(perms, \"c\"))","set_property_info(object, pname, {newowner, perms});","endif","endfor","if ($object_utils:isa(oldowner, $player))","if (is_player(oldowner) && (object != oldowner))","$quota_utils:reimburse_quota(oldowner, object);","endif","if (typeof(oldowner.owned_objects) == LIST)","oldowner.owned_objects = setremove(oldowner.owned_objects, object);","endif","endif","if ($object_utils:isa(newowner, $player))","if (object != newowner)","$quota_utils:charge_quota(newowner, object);","endif","if (typeof(newowner.owned_objects) == LIST)","newowner.owned_objects = setadd(newowner.owned_objects, object);","endif","endif","return 1;"]},{"name":"set_property_owner","owner":2,"perms":173,"preposition":-1,"code":["\":set_property_owner(object,prop,newowner[,suspendok])  changes the ownership of object.prop to newowner.  If the property is !c, changes the ownership on all of the descendents as well.  Otherwise, we just chown the property on the object itself and give a warning if newowner!=object.owner (--Rog thinks this is a server bug that one is able to do this at all...).\";","{object, pname, newowner, ?suspendok = 0} = args;","if (!caller_perms().wizard)","return E_PERM;","elseif (!(info = `property_info(object, pname) ! ANY'))","\"... handles E_PROPNF and invalid object errors...\";","return info;","elseif (!is_player(newowner))","return E_INVARG;","elseif (index(info[2], \"c\"))","if (suspendok / 2)","\"...(recursive call)...\";","\"...child property is +c while parent is -c??...RUN AWAY!!\";","return E_NONE;","else","set_property_info(object, pname, listset(info, newowner, 1));","return (newowner == object.owner) || E_NONE;","endif","else","set_property_info(object, pname, listset(info, newowner, 1));","if ((suspendok % 2) && ((ticks_left() < 10000) || (seconds_left() < 2)))","suspend(0);","endif","suspendok = 2 + suspendok;","for c in (children(object))","this:set_property_owner(c, pname, newowner, suspendok);","endfor","return 1;","endif"]},{"name":"unset_player","owner":2,"perms":173,"preposition":-1,"code":["\":unset_player(victim[,newowner])  => 1 or error\";","\"Reset victim's player flag, chown victim to newowner (if given), remove all of victim's names and aliases from $player_db.\";","{victim, ?newowner = 0} = args;","if (!caller_perms().wizard)","return E_PERM;","elseif (!valid(victim))","return E_INVARG;","elseif (!is_player(victim))","return E_NONE;","endif","if (typeof(newowner) == OBJ)","$wiz_utils:set_owner(victim, newowner);","endif","victim.programmer = 0;","victim.wizard = 0;","set_player_flag(victim, 0);","if ($object_utils:has_property($local, \"second_char_registry\"))","$local.second_char_registry:delete_player(victim);","endif","if ($player_db.frozen)","player:tell(\"Warning:  player_db is in the middle of a :load().\");","endif","$player_db:delete2(victim.name, victim);","for a in (victim.aliases)","$player_db:delete2(a, victim);","\"I don't *think* this is bad---we've already toaded the guy.  And folks with lots of aliases screw us. --Nosredna\";","$command_utils:suspend_if_needed(0);","endfor","return 1;"]},{"name":"set_property_flags","owner":2,"perms":173,"preposition":-1,"code":["\":set_property_flags(object,prop,flags[,suspendok])  changes the permissions on object.prop to flags.  Unlike a mere set_property_info, this changes the flags on all descendant objects as well.  We also change the ownership on the descendent properties where necessary.\";","{object, pname, flags, ?suspendok = 0} = args;","perms = caller_perms();","if (!(info = `property_info(object, pname) ! ANY'))","\"... handles E_PROPNF and invalid object errors...\";","return info;","elseif ($set_utils:difference($string_utils:char_list(flags), {\"r\", \"w\", \"c\"}))","\"...not r, w, or c?...\";","return E_INVARG;","elseif ((pinfo = `property_info(parent(object), pname) ! ANY') && (flags != pinfo[2]))","\"... property doesn't actually live here...\";","\"... only allowed to correct so that this property matches parent...\";","return E_INVARG;","elseif (!(perms.wizard || (info[1] == perms)))","\"... you have to own the property...\";","return E_PERM;","elseif (!(((!(c = index(flags, \"c\"))) == (!index(info[2], \"c\"))) || $perm_utils:controls(perms, object)))","\"... if you're changing the c flag, you have to own the object...\";","return E_PERM;","else","if (c)","set_property_info(object, pname, {object.owner, kflags = flags});","else","set_property_info(object, pname, kflags = listset(info, flags, 2));","endif","for kid in (children(object))","this:_set_property_flags(kid, pname, kflags, suspendok);","endfor","return 1;","endif"]},{"name":"_set_property_flags","owner":2,"perms":173,"preposition":-1,"code":["\"_set_property_flags(object, pname, {owner, flags} or something+\\\"c\\\", suspendok)\";","\"auxiliary to :set_property_flags... don't call this directly.\";","if (caller != this)","return E_PERM;","endif","if (args[4] && $command_utils:running_out_of_time(0))","suspend(0);","endif","object = args[1];","if (typeof(args[3]) != LIST)","set_property_info(object, args[2], {object.owner, args[3]});","else","set_property_info(@args[1..3]);","endif","for kid in (children(object))","this:_set_property_flags(@listset(args, kid, 1));","endfor"]},{"name":"random_password","owner":2,"perms":173,"preposition":-1,"code":["\"Generate a random password of length args[1].  Alternates vowels and consonants, for maximum pronounceability.  Uses its own list of consonants which exclude F and C and K to prevent generating obscene sounding passwords.\";","\"Capital I and lowercase L are excluded on the basis of looking like each other.\";","vowels = \"aeiouyAEUY\";","consonants = \"bdghjmnpqrstvwxzBDGHJLMNPQRSTVWXZ\";","len = toint(args[1]);","if (len)","alt = random(2) - 1;","s = \"\";","for i in [1..len]","newchar = alt ? vowels[random($)] | consonants[random($)];","s = s + newchar;","alt = !alt;","endfor","return s;","else","return E_INVARG;","endif"]},{"name":"queued_tasks","owner":2,"perms":173,"preposition":-1,"code":["\":queued_tasks(player) => list of queued tasks for that player.\";","\"shouldn't the server builtin should work this way?  oh well\";","set_task_perms(caller_perms());","if (typeof(e = `set_task_perms(who = args[1]) ! ANY') == ERR)","return e;","elseif (who.wizard)","tasks = {};","for t in (queued_tasks())","if (t[5] == who)","tasks = {@tasks, t};","endif","endfor","return tasks;","else","return queued_tasks();","endif"]},{"name":"isnewt","owner":2,"perms":173,"preposition":-1,"code":["\"Return 1 if args[1] is a newted player.\";","if (!caller_perms().wizard)","return E_PERM;","else","return args[1] in $login.newted;","endif"]},{"name":"initialize_owned","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return E_PERM;","else","set_task_perms(caller_perms());","player:tell(\"Beginning initialize_owned:  \", ctime());","for o in [#0..max_object()]","if (valid(o))","if ($object_utils:isa(owner = o.owner, $player) && (typeof(owner.owned_objects) == LIST))","owner.owned_objects = setadd(owner.owned_objects, o);","endif","endif","$command_utils:suspend_if_needed(0);","endfor","player:tell(\"Done adding, beginning verification pass.\");","this:verify_owned_objects();","player:tell(\"Finished:  \", ctime());","endif"]},{"name":"verify_owned_objects","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return E_PERM;","else","for p in (players())","if (typeof(p.owned_objects) == LIST)","for o in (p.owned_objects)","if (((typeof(o) != OBJ) || (!valid(o))) || (o.owner != p))","p.owned_objects = setremove(p.owned_objects, o);","player:tell(\"Removed \", $string_utils:nn(o), \" from \", $string_utils:nn(p), \"'s .owned_objects list.\");","if (((typeof(o) == OBJ) && valid(o)) && (typeof(o.owner.owned_objects) == LIST))","o.owner.owned_objects = setadd(o.owner.owned_objects, o);","endif","endif","$command_utils:suspend_if_needed(0, p);","endfor","endif","endfor","endif"]},{"name":"connected_wizards connected_wizards_unadvertised","owner":36,"perms":173,"preposition":-1,"code":["\":connected_wizards() => list of currently connected wizards and players mentioned in .public_identity properties as being wizard counterparts.\";","wizzes = $object_utils:leaves($wiz);","wlist = {};","everyone = verb == \"connected_wizards_unadvertised\";","for w in (wizzes)","if (w.wizard && (w.advertised || everyone))","if (`connected_seconds(w) ! ANY => 0')","wlist = setadd(wlist, w);","endif","if (`connected_seconds(w.public_identity) ! ANY => 0')","wlist = setadd(wlist, w.public_identity);","endif","endif","endfor","return wlist;"]},{"name":"all_wizards_advertised all_wizards all_wizards_unadvertised","owner":36,"perms":173,"preposition":-1,"code":["\":all_wizards_advertised() => list of all wizards who have set .advertised true and players mentioned their .public_identity properties as being wizard counterparts\";","wizzes = $object_utils:leaves($wiz);","wlist = {};","everyone = verb == \"all_wizards_unadvertised\";","for w in (wizzes)","if (w.wizard && (w.advertised || everyone))","if (is_player(w))","wlist = setadd(wlist, w);","endif","if (`is_player(w.public_identity) ! ANY')","wlist = setadd(wlist, w.public_identity);","endif","endif","endfor","return wlist;"]},{"name":"rename_all_instances","owner":2,"perms":173,"preposition":-1,"code":["\":rename_all_instances(object,oldname,newname)\";","\"Used to rename all instances of an unwanted verb (like recycle or disfunc)\";","\"if said verb is actually defined on the object itself\";","if (caller_perms().wizard)","found = 0;","{object, oldname, newname} = args;","while (info = `verb_info(object, oldname) ! ANY')","`set_verb_info(object, oldname, listset(info, newname, 3)) ! ANY';","found = 1;","endwhile","return found;","else","return E_PERM;","endif"]},{"name":"missed_help","owner":2,"perms":173,"preposition":-1,"code":["if (this.record_missed_help && (callers()[1][4] == $player))","miss = args[1];","if (!(index = miss in this.missed_help_strings))","this.missed_help_strings = {miss, @this.missed_help_strings};","this.missed_help_counters = {{0, 0}, @this.missed_help_counters};","index = 1;","endif","which = args[2] ? 2 | 1;","this.missed_help_counters[index][which] = this.missed_help_counters[index][which] + 1;","endif"]},{"name":"show_missing_help","owner":2,"perms":173,"preposition":-1,"code":["mhs = this.missed_help_strings;","cnt = this.missed_help_counters;","\"save values first, so subsequent changes during suspends wont affect it\";","thresh = args ? args[1] | 5;","strs = {};","for i in [1..length(mhs)]","$command_utils:suspend_if_needed(0);","if ((cnt[i][1] + cnt[i][2]) > thresh)","strs = {@strs, ((($string_utils:right(tostr(cnt[i][1]), 5) + \" \") + $string_utils:right(tostr(cnt[i][2]), 5)) + \" \") + mhs[i]};","endif","endfor","sorted = $list_utils:sort_suspended(0, strs);","len = length(sorted);","player:tell(\" miss ambig word\");","for x in [1..len]","$command_utils:suspend_if_needed(0);","player:tell(sorted[(len - x) + 1]);","endfor","player:tell(\" - - - - - - - - -\");"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","pass();","`delete_property(this, \"guest_feature_restricted\") ! ANY';","this.boot_exceptions = {};","this.programmer_restricted = {};","this.programmer_restricted_temp = {};","this.record_missed_help = 0;","this.missed_help_counters = this.missed_help_strings = {};","this.suicide_string = \"You don't *really* want to commit suicide, do you?\";","this.wizards = {#2};","this.next_perm_index = 1;","this.system_chars = {$hacker, $no_one, $housekeeper};","this.expiration_progress = $nothing;","endif"]},{"name":"show_netwho_listing","owner":2,"perms":173,"preposition":-1,"code":["\":show_netwho_listing(tell,player_list)\";","\" prints a listing of the indicated players showing connect sites.\";","{who, unsorted} = args;","if (!caller_perms().wizard)","return E_PERM;","endif","if (!unsorted)","return;","endif","su = $string_utils;","alist = {};","footnotes = {};","nwidth = length(\"Player name\");","for u in (unsorted)","$command_utils:suspend_if_needed(0);","if (u.programmer)","pref = \"% \";","footnotes = setadd(footnotes, \"prog\");","else","pref = \"  \";","endif","if (u in connected_players())","lctime = ctime(time() - connected_seconds(u));","where = connection_name(u);","else","lctime = ctime(u.last_connect_time);","where = u.last_connect_place;","endif","name = u.name;","if (length(name) > 15)","name = name[1..13] + \"..\";","endif","u3 = {tostr(pref, u.name, \" (\", u, \")\"), lctime[5..10] + lctime[20..24]};","nwidth = max(length(u3[1]), nwidth);","where = $string_utils:connection_hostname(where);","if ($login:blacklisted(where))","where = \"(*) \" + where;","footnotes = setadd(footnotes, \"black\");","elseif ($login:graylisted(where))","where = \"(+) \" + where;","footnotes = setadd(footnotes, \"gray\");","endif","alist = {@alist, {@u3, where}};","endfor","alist = $list_utils:sort_alist_suspended(0, alist, 3);","$command_utils:suspend_if_needed(0);","headers = {\"Player name\", \"Last Login\", \"From Where\"};","before = {0, nwidth + 3, (nwidth + length(ctime(0))) - 11};","tell1 = \"  \" + headers[1];","tell2 = \"  \" + su:space(headers[1], \"-\");","for j in [2..3]","tell1 = su:left(tell1, before[j]) + headers[j];","tell2 = su:left(tell2, before[j]) + su:space(headers[j], \"-\");","endfor","who:notify(tell1);","who:notify(tell2);","for a in (alist)","$command_utils:suspend_if_needed(0);","tell1 = a[1];","for j in [2..3]","tell1 = su:left(tell1, before[j]) + a[j];","endfor","who:notify(tell1[1..min($, 79)]);","endfor","if (footnotes)","who:notify(\"\");","if (\"prog\" in footnotes)","who:notify(\" %  == programmer.\");","endif","if (\"black\" in footnotes)","who:notify(\"(*) == blacklisted site.\");","endif","if (\"gray\" in footnotes)","who:notify(\"(+) == graylisted site.\");","endif","endif"]},{"name":"show_netwho_from_listing","owner":2,"perms":173,"preposition":-1,"code":["\":show_netwho_from_listing(tell,site)\";","\"@net-who from hoststring prints all players who have connected from that host or host substring.  Substring can include *'s, e.g. @net-who from *.foo.edu.\";","if (!caller_perms().wizard)","return E_PERM;","endif","{tellwho, where} = args;","su = $string_utils;","if (!index(where, \"*\"))","\"Oh good... search for users from a site... the fast way.  No wild cards.\";","nl = 0;","bozos = {};","sites = $site_db:find_all_keys(where);","while (sites)","s = sites;","sites = {};","for domain in (s)","\"Temporary kluge until $site_db is repaired. --Nosredna\";","for b in ($site_db:find_exact(domain) || {})","$command_utils:suspend_if_needed(0, \"..netwho..\");","if (typeof(b) == STR)","sites = setadd(sites, (b + \".\") + domain);","else","bozos = setadd(bozos, b);","nl = max(length(tostr(b, (valid(b) && is_player(b)) ? b.name | \"*** recreated ***\")), nl);","endif","endfor","endfor","endwhile","if (bozos)","tellwho:notify(tostr(su:left(\"  Player\", nl + 7), \"From\"));","tellwho:notify(tostr(su:left(\"  ------\", nl + 7), \"----\"));","for who in (bozos)","st = su:left(tostr((valid(who) && is_player(who)) ? (who.programmer ? \"% \" | \"  \") + who.name | \"\", \" (\", who, \")\"), nl + 7);","comma = 0;","if ($object_utils:isa(who, $player) && is_player(who))","for p in ({$wiz_utils:get_email_address(who) || \"*Unregistered*\", @who.all_connect_places})","if (comma && (length(p) >= (78 - length(st))))","tellwho:notify(tostr(st, \",\"));","st = su:space(nl + 7) + p;","else","st = tostr(st, comma ? \", \" | \"\", p);","endif","comma = 1;","$command_utils:suspend_if_needed(0);","endfor","else","st = st + (valid(who) ? \"*** recreated ***\" | \"*** recycled ***\");","endif","tellwho:notify(st);","endfor","tellwho:notify(\"\");","tellwho:notify(tostr(length(bozos), \" player\", (length(bozos) == 1) ? \"\" | \"s\", \" found.\"));","else","tellwho:notify(tostr(\"No sites matching `\", where, \"'\"));","endif","else","\"User typed 'from'.  Go search for users from this site.  (SLOW!)\";","howmany = 0;","for who in (players())","$command_utils:suspend_if_needed(0);","matches = {};","for name in (who.all_connect_places)","if ((index(where, \"*\") && su:match_string(name, where)) || ((!index(where, \"*\")) && index(name, where)))","matches = {@matches, name};","endif","endfor","if (matches)","howmany = howmany + 1;","tellwho:notify(tostr(who.name, \" (\", who, \"): \", su:english_list(matches)));","endif","endfor","tellwho:notify(tostr(howmany || \"No\", \" matches found.\"));","endif"]},{"name":"check_player_request check_reregistration","owner":2,"perms":173,"preposition":-1,"code":["\":check_player_request(name [,email [,connection]])\";","\" check if the request for player and email address is valid;\";","\" return empty string if it valid, or else a string saying why not.\";","\" The result starts with - if this is a 'send email, don't try again' situation.\";","\":check_reregistration(who, email, connection)\";","\"  Since name is ignored, only check the 'email' parts and use the first arg\";","\"  for the re-registering player.\";","if (!caller_perms().wizard)","return E_PERM;","\"accesses registration information -- wiz only\";","endif","name = args[1];","if (verb == \"check_reregistration\")","\"don't check player name\";","elseif (!name)","return \"A blank name isn't allowed.\";","elseif (name == \"<>\")","return \"Names with angle brackets aren't allowed.\";","elseif (index(name, \" \"))","return \"Names with spaces are not allowed. Use dashes or underscores.\";","elseif (match(name, \"^<.*>$\"))","return tostr(\"Try using \", name[2..$ - 1], \" instead of \", name, \".\");","elseif ($player_db.frozen)","return \"New players cannot be created at the moment, try again later.\";","elseif (!$player_db:available(name))","return (\"The name '\" + name) + \"' is not available.\";","elseif ($login:_match_player(name) != $failed_match)","return (\"The name '\" + name) + \"' doesn't seem to be available.\";","endif","if (length(args) == 1)","\"no email address supplied.\";","return \"\";","endif","address = args[2];","addrargs = (verb == \"check_reregistration\") ? {name} | {};","if ($registration_db:suspicious_address(address, @addrargs))","return \"-There has already been a character with that or a similar email address.\";","endif","if (reason = $network:invalid_email_address(address))","return reason + \".\";","endif","parsed = $network:parse_address(address);","if ($registration_db:suspicious_userid(parsed[1]))","return tostr(\"-Automatic registration from an account named \", parsed[1], \" is not allowed.\");","endif","connection = (length(args) > 2) ? args[3] | parsed[2];","if ((connection[max($ - 2, 1)..$] == \".uk\") && (parsed[2][1..3] == \"uk.\"))","return tostr(\"Addresses must be in internet form. Try \", parsed[1], \"@\", $string_utils:from_list($list_utils:reverse($string_utils:explode(parsed[2], \".\")), \".\"), \".\");","elseif ((verb == \"check_player_request\") && match(connection, \"^[0-9.]+$\"))","\"Allow reregistration from various things we wouldn't allow registration from.  Let them register to their yahoo acct...\";","return \"-The system cannot resolve the name of the system you're connected from.\";","elseif ((verb == \"check_player_request\") && ((a = $network:local_domain(connection)) != (b = $network:local_domain(parsed[2]))))","return tostr(\"-The connection is from '\", a, \"' but the mail address is '\", b, \"'; these don't seem to be the same place.\");","elseif ((verb == \"check_player_request\") && $login:spooflisted(parsed[2]))","return tostr(\"-Automatic registration is not allowed from \", parsed[2], \".\");","endif","return \"\";"]},{"name":"make_player","owner":2,"perms":173,"preposition":-1,"code":["\"create a player named NAME with email address ADDRESS; return {object, password}.  Optional third arg is comment to be put in registration db.\";","\"assumes $wiz_utils:check_player_request() has been called and it passes.\";","if (!caller_perms().wizard)","return E_PERM;","endif","{name, address, @rest} = args;","new = $quota_utils:bi_create($player_class, $nothing);","new.name = name;","new.aliases = {name};","new.password = crypt(password = $wiz_utils:random_password(5));","new.last_password_time = time();","new.last_connect_time = $maxint;","\"Last disconnect time is creation time, until they login.\";","new.last_disconnect_time = time();","$quota_utils:initialize_quota(new);","if (!(error = $wiz_utils:set_player(new)))","return player:tell(\"An error, \", error, \" occurred while trying to make \", new, \" a player. The database is probably inconsistent.\");","endif","$wiz_utils:set_email_address(new, address);","$registration_db:add(new, address, @rest);","move(new, $player_start);","new.programmer = $player_class.programmer;","return {new, password};"]},{"name":"send_new_player_mail","owner":2,"perms":173,"preposition":-1,"code":["\":send_new_player_mail(preface, name, address, character#, password)\";","\"  used by $wiz:@make-player and $guest:@request\";","if (!caller_perms().wizard)","return E_PERM;","endif","{preface, name, address, new, password} = args;","msg = {preface};","msg = {@msg, tostr(\"A character has been created, with name \\\"\", name, \"\\\" and password \\\"\", password, \"\\\".\"), \"Passwords are case sensitive, which means you have to type it exactly as\", \"it appears here, including capital and lowercase letters.\", \"So, to log in, you would type:\", tostr(\"  Connect \", name, \" \", password)};","if ($object_utils:has_property($local, \"new_player_message\"))","msg = {@msg, @$local.new_player_message};","endif","return $network:sendmail(address, ((\"Your \" + $network.moo_name) + \" character, \") + name, \"Reply-to: \" + $login.registration_address, @msg);"]},{"name":"do_make_player","owner":2,"perms":93,"preposition":-2,"code":["\"do_maker_player(name,email,[comment])\";","\"Common code for @make-player\";","\"If no password is given, generates a random password for the player.\";","\"Email-address is stored in $registration_db and on the player object.\";","if (!caller_perms().wizard)","return E_PERM;","endif","{name, email, @comments} = args;","comments = $string_utils:from_list(comments, \" \");","reason = $wiz_utils:check_player_request(name, email);","if (others = $registration_db:find_exact(email))","player:notify(email + \" is the registered address of the following characters:\");","for x in (others)","player:notify(tostr(valid(x[1]) ? x[1].name | \"<recycled>\", (valid(x[1]) && (!is_player(x[1]))) ? \" {nonplayer}\" | \"\", \" (\", x[1], \") \", (length(x) > 1) ? (\"[\" + tostr(@x[2..$])) + \"]\" | \"\"));","endfor","if (!reason)","reason = \"Already registered.\";","endif","endif","if (reason)","player:notify(reason);","if (!$command_utils:yes_or_no(\"Create character anyway? \"))","player:notify(\"Character not created.\");","return;","endif","endif","new = $wiz_utils:make_player(name, email, comments);","player:notify(tostr(name, \" (\", new[1], \") created with password `\", new[2], \"' for \", email, comments ? (\" [\" + comments) + \"]\" | \"\"));","$mail_agent:send_message(player, $new_player_log, tostr(name, \" (\", new[1], \")\"), tostr(email, comments ? \" \" + comments | \"\"));","if ($network.active)","if ($command_utils:yes_or_no((\"Send email to \" + email) + \" with password? \"))","player:notify(tostr(\"Sending the password to \", email, \".\"));","if ((result = $wiz_utils:send_new_player_mail(tostr(\"From \", player.name, \"@\", $network.moo_name, \":\"), name, email, new[1], new[2])) == 0)","player:notify(tostr(\"Mail sent successfully to \", email, \".\"));","else","player:tell(\"Cannot send mail: \", result);","endif","else","player:notify(\"No mail sent.\");","endif","else","player:notify(\"Sorry, the network isn't active.\");","endif"]},{"name":"do_register","owner":2,"perms":173,"preposition":-1,"code":["\"do_register(name, email_address [,comments])\";","\"change player's email address.\";","if (!caller_perms().wizard)","return E_PERM;","endif","{whostr, email, @comments} = args;","comments = $string_utils:from_list(comments);","who = $string_utils:match_player(whostr);","if ($command_utils:player_match_failed(who, whostr))","return;","endif","if (((whostr != who.name) && (!(whostr in who.aliases))) && (whostr != tostr(who)))","player:notify(tostr(\"Must be a full name or an object number:  \", who.name, \"(\", who, \")\"));","return;","endif","if (reason = $network:invalid_email_address(email))","player:notify(reason);","if (!$command_utils:yes_or_no(\"Register anyway?\"))","return player:notify(\"re-registration aborted.\");","endif","endif","if (comments)","$registration_db:add(who, email, comments);","else","$registration_db:add(who, email);","endif","old = $wiz_utils:get_email_address(who);","$wiz_utils:set_email_address(who, email);","player:notify(tostr(who.name, \" (\", who, \") formerly \", old ? old | \"unregistered\", \", registered at \", email, \".\", comments ? (\" [\" + comments) + \"]\" | \"\"));"]},{"name":"do_new_password","owner":2,"perms":173,"preposition":-1,"code":["\"do_new_password(who, [password])\";","if (!caller_perms().wizard)","return E_PERM;","endif","{who, ?password = $wiz_utils:random_password(6)} = args;","if (!password)","password = $wiz_utils:random_password(6);","endif","whostr = $string_utils:nn(who);","player:notify(tostr(\"About to change password for \", whostr, \". Old encrypted password is \\\"\", who.password, \"\\\"\"));","who.password = crypt(password);","who.last_password_time = time();","$mail_agent:send_message(player, $new_password_log, tostr(\"@newpassword \", who.name, \" (\", who, \")\"), {tostr(\"I just gave \", who.name, \" a new password.\")});","player:notify(tostr(whostr, \" new password is `\", password, \"'.\"));","if (!$wiz_utils:get_email_address(who))","player:notify(tostr(whostr, \" doesn't have a registered email_address, cannot mail password; tell them some some other way.\"));","elseif ((who.last_connect_time == $maxint) && $command_utils:yes_or_no(tostr(who.name, \" has never logged in.  Send mail with the password as though this were a new player request?\")))","if ((result = $wiz_utils:send_new_player_mail(tostr(\"From \", player.name, \"@\", $network.moo_name, \":\"), who.name, $wiz_utils:get_email_address(who), who, password)) == 0)","player:tell(\"Mail sent.\");","else","player:tell(\"Trouble sending mail: \", result);","endif","elseif ($command_utils:yes_or_no(tostr(\"Email new password to \", whostr, \"?\")))","player:notify(\"Sending the password via email.\");","$network:adjust_postmaster_for_password(\"enter\");","if ((result = $network:sendmail($wiz_utils:get_email_address(who), (\"Your \" + $network.moo_name) + \" password\", (\"The password for your \" + $network.moo_name) + \" character:\", \" \" + whostr, \"has been changed. The new password is:\", \" \" + password, \"\", \"Please note that passwords are case sensitive.\")) == 0)","player:tell(\"Mail sent.\");","else","player:tell(\"Trouble sending mail: \", result);","endif","$network:adjust_postmaster_for_password(\"exit\");","else","player:tell(\"No mail sent.\");","endif"]},{"name":"set_owner_new","owner":2,"perms":173,"preposition":-1,"code":["\":set_owner(object,newowner[,suspendok])  does object.owner=newowner, taking care of c properties as well.  This should be used anyplace one is contemplating doing object.owner=newowner, since the latter leaves ownership of c properties unchanged.  (--Rog thinks this is a server bug).\";","{object, newowner, ?suspendok = 0} = args;","if (!valid(object))","return E_INVIND;","elseif (!caller_perms().wizard)","return E_PERM;","elseif (!(valid(newowner) && is_player(newowner)))","return E_INVARG;","endif","oldowner = object.owner;","object.owner = newowner;","for pname in ($object_utils:all_properties(object))","if (suspendok && ((ticks_left() < 5000) || (seconds_left() < 2)))","suspend(0);","endif","perms = property_info(object, pname)[2];","if (index(perms, \"c\"))","set_property_info(object, pname, {newowner, perms});","endif","endfor","if ($object_utils:isa(oldowner, $player))","if (is_player(oldowner) && (object != oldowner))","$quota_utils:reimburse_quota(oldowner, object);","endif","if (typeof(oldowner.owned_objects) == LIST)","oldowner.owned_objects = setremove(oldowner.owned_objects, object);","endif","endif","if ($object_utils:isa(newowner, $player))","if (object != newowner)","$quota_utils:charge_quota(newowner, object);","endif","if (typeof(newowner.owned_objects) == LIST)","newowner.owned_objects = setadd(newowner.owned_objects, object);","endif","endif","return 1;"]},{"name":"boot_idlers","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return E_PERM;","endif","\"------- constants ---- \";","\"20 minutes idle for regular players\";","mintime = 60 * 20;","\"10 minutes for guests\";","minguest = 60 * 10;","\"wait 3 minutes before actually booting\";","bootdelay = 3;","\"start booting when there are 20 less than max players\";","threshold = 20;","\" ----------------------\";","if ($code_utils:task_valid(this.boot_task) && (task_id() != this.boot_task))","\"starting a new one: kill the old one\";","kill_task(this.boot_task);","this.boot_task = 0;","endif","fork taskn ((bootdelay * 60) * 3)","maxplayers = $login:max_connections() - threshold;","if (length(pl = connected_players()) > maxplayers)","pll = {};","plt = {};","for x in (pl)","suspend(0);","min = $object_utils:isa(x, $guest) ? minguest | mintime;","if ((((idle = `idle_seconds(x) ! ANY => 0') > min) && (!x.wizard)) && (!(x in this.boot_exceptions)))","pll = {x, @pll};","plt = {idle, @plt};","endif","endfor","if (pll)","\"Sort by idle time, and choose person who has been idle longest.\";","pll = $list_utils:sort(pll, plt);","booted = pll[$];","guest = $object_utils:isa(booted, $guest);","min = guest ? minguest | mintime;","if (`idle_seconds(booted) ! ANY => 0' > min)","notify(booted, tostr(\"*** You've been idle more than \", min / 60, \" minutes, and there are more than \", maxplayers, \" players connected. If you're still idle and LambdaMOO is still busy in \", bootdelay, \" minute\", (bootdelay == 1) ? \"\" | \"s\", \", you will be booted. ***\"));","fork (60 * bootdelay)","idle = `idle_seconds(booted) ! ANY => 0';","if ((idle > min) && (length(connected_players()) > ($login:max_connections() - threshold)))","notify(booted, \"*** You've been idle too long and LambdaMOO is still too busy ***\");","server_log(tostr(\"IDLE: \", booted.name, \" (\", booted, \") idle \", idle / 60));","boot_player(booted);","endif","endfork","endif","endif","endif","this:(verb)(@args);","endfork","this.boot_task = taskn;","\"This is set up so that it forks the task first, and this.boot_task is the task_id of whatever is running the idle booter\";"]},{"name":"grant_object","owner":2,"perms":173,"preposition":-1,"code":["\":grant_object(what, towhom);\";","\"Ownership of the object changes as in @chown and :set_owner (i.e., .owner and all c properties change).  In addition all verbs and !c properties owned by the original owner change ownership as well.  Finally, for !c properties, instances on descendant objects change ownership (as in :set_property_owner).\";","if (!caller_perms().wizard)","return E_PERM;","endif","{object, newowner} = args;","if (!is_player(newowner))","return E_INVARG;","endif","same = object.owner == newowner;","for vnum in [1..length(verbs(object))]","info = verb_info(object, vnum);","if (!((info[1] != object.owner) && (valid(info[1]) && is_player(info[1]))))","same = same && (info[1] == newowner);","set_verb_info(object, vnum, listset(info, newowner, 1));","endif","endfor","for prop in (properties(object))","$command_utils:suspend_if_needed(0);","info = property_info(object, prop);","if (!(index(info[2], \"c\") || (((info[1] != object.owner) && valid(info[1])) && is_player(info[1]))))","same = same && (info[1] == newowner);","$wiz_utils:set_property_owner(object, prop, newowner, 1);","endif","endfor","suspend(0);","$wiz_utils:set_owner(object, newowner, 1);","return same ? \"nothing changed\" | \"grant changed\";"]},{"name":"connection_hash","owner":2,"perms":173,"preposition":-1,"code":["\"connection_hash(forwhom, host [,seed])\";","\"Compute an encrypted hash of the host for 'forwhom', using 'crypt'.\";","{forwhom, host, @seed} = args;","hash = toint(forwhom);","for i in [1..length(host)]","hash = (hash * 14) + index($string_utils.ascii, host[i]);","endfor","return crypt(tostr(hash), @seed);"]},{"name":"newt_player","owner":2,"perms":173,"preposition":-1,"code":["\":newt_player(who [ , commentary] [, temporary])\";","{who, ?comment = \"\", ?temporary = 0} = args;","if (!caller_perms().wizard)","$error:raise(E_PERM);","elseif (length(args) < 1)","$error:raise(E_ARGS);","elseif ((typeof(who = args[1]) != OBJ) || (!is_player(who)))","$error:raise(E_INVARG);","else","if (!comment)","player:notify(\"So why has this player been newted?\");","comment = $command_utils:read();","endif","if (temporary)","comment = temporary + comment;","endif","$login.newted = setadd($login.newted, who);","if (msg = player:newt_victim_msg())","notify(who, msg);","endif","notify(who, $login:newt_registration_string());","boot_player(who);","player:notify(tostr(who.name, \" (\", who, \") has been turned into a newt.\"));","$mail_agent:send_message(player, $newt_log, tostr(\"@newt \", who.name, \" (\", who, \")\"), {$string_utils:from_list(who.all_connect_places, \" \"), @comment ? {comment} | {}});","if ($object_utils:isa(who.location, $room) && (msg = player:newt_msg()))","who.location:announce_all_but({who}, msg);","endif","player:notify(tostr(\"Mail sent to \", $mail_agent:name($newt_log), \".\"));","endif"]},{"name":"unset_programmer","owner":2,"perms":173,"preposition":-1,"code":["\":unset_programmer(victim[,reason[,start time,duration]]) => 1 or error.\";","\"Resets victim.programmer, adds victim to .programmer_restricted.\";","\"Put into temporary list if 3rd and 4th arguments are given. Which restricts the victim for uptime duration since start time. Must give a reason, though it can be blank, in this case.\";","{victim, ?reason = \"\", ?start = 0, ?duration = 0} = args;","if (!caller_perms().wizard)","return E_PERM;","elseif (!valid(victim))","return E_INVARG;","elseif ((!victim.programmer) && this:check_prog_restricted(victim))","return E_NONE;","else","victim.programmer = 0;","if (is_player(victim) && $object_utils:isa(victim, $player))","this.programmer_restricted = setadd(this.programmer_restricted, victim);","if (start)","this.programmer_restricted_temp = setadd(this.programmer_restricted_temp, {victim, start, duration});","endif","endif","$mail_agent:send_message(caller_perms(), {$newt_log}, tostr(\"@deprogrammer \", victim.name, \" (\", victim, \")\"), reason ? (typeof(reason) == STR) ? {reason} | reason | {});","return 1;","endif"]},{"name":"is_wizard","owner":36,"perms":173,"preposition":-1,"code":["\":is_wizard(who) => whether `who' is a wizard or is the .public_identity of some wizard.\";","\"This verb is used for permission checks on commands that should only be accessible to wizards or their ordinary-player counterparts.  It will return true for unadvertised wizards.\";","who = args[1];","if (who.wizard)","return 1;","else","for w in ($object_utils:leaves($wiz))","if ((w.wizard && is_player(w)) && (who == `w.public_identity ! ANY'))","return 1;","endif","endfor","endif","return 0;"]},{"name":"expire_mail","owner":2,"perms":13,"preposition":-1,"code":["if (!caller_perms().wizard)","return E_PERM;","endif","this:expire_mail_lists();","this:expire_mail_players();"]},{"name":"expire_mail_weekly","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return E_PERM;","endif","fork (((7 * 24) * 60) * 60)","this:(verb)();","endfork","this:expire_mail();"]},{"name":"check_prog_restricted","owner":2,"perms":173,"preposition":-1,"code":["\"Checks to see if args[1] is restricted from programmer either permanently or temporarily. Removes from temporary list if time is up\";","if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))","return E_PERM;","endif","if ((who = args[1]) in this.programmer_restricted)","\"okay, who is restricted. Now check to see if it is temporary\";","if (entry = $list_utils:assoc(who, this.programmer_restricted_temp))","if ($login:uptime_since(entry[2]) > entry[3])","\"It's temporary and the time is up, remove and return false\";","this.programmer_restricted_temp = setremove(this.programmer_restricted_temp, entry);","this.programmer_restricted = setremove(this.programmer_restricted, who);","return 0;","else","\"time is not up\";","return 1;","endif","else","return 1;","endif","else","return 0;","endif"]},{"name":"expire_mail_players","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return E_PERM;","endif","s = 0;","for p in (players())","this.expiration_progress = p;","if ((p.owner == p) && is_player(p))","s = s + (p:expire_old_messages() || 0);","endif","if (ticks_left() < 10000)","set_task_perms($wiz_utils:random_wizard());","suspend(0);","endif","endfor","$mail_agent:send_message(player, player, verb, tostr(s, \" messages have been expired from players.\"));","return s;"]},{"name":"expire_mail_lists","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return E_PERM;","endif","sum = 0;","for x in ($object_utils:leaves_suspended($mail_recipient))","this.expiration_progress = x;","temp = x:expire_old_messages();","if (typeof(temp) == INT)","sum = sum + temp;","endif","\"just suspend for every fucker, I'm tired of losing.\";","set_task_perms($wiz_utils:random_wizard());","suspend(0);","endfor","$mail_agent:send_message(player, player, verb, tostr(sum, \" messages have been expired from mailing lists.\"));","return sum;"]},{"name":"flush_editors","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return E_PERM;","else","fork (86400 * 7)","this:(verb)();","endfork","player:tell(\"Flushing ancient editor sessions.\");","for x in ({$verb_editor, $note_editor, $mail_editor})","x:do_flush(time() - (30 * 86400), 0);","$command_utils:suspend_if_needed(0);","endfor","endif"]},{"name":"random_wizard","owner":2,"perms":173,"preposition":-1,"code":["\"Put all your wizards in $wiz_utils.wizards.  Then various long-running tasks will cycle among the permissions, spreading out the scheduler-induced personal lag.\";","w = this.wizards;","i = this.next_perm_index;","if (i == length(w))","i = 1;","else","i = i + 1;","endif","this.next_perm_index = i;","return w[i];"]},{"name":"set_email_address","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","{who, email} = args;","if (typeof(who.email_address) == LIST)","who.email_address[1] = email;","else","who.email_address = email;","endif"]},{"name":"get_email_address","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","{who} = args;","if (typeof(who.email_address) == LIST)","return who.email_address[1];","else","return who.email_address;","endif"]},{"name":"find* _only* _every*","owner":36,"perms":173,"preposition":-1,"code":["return ((caller == this) || caller_perms().wizard) ? pass(@args) | E_PERM;"]},{"name":"add","owner":36,"perms":173,"preposition":-1,"code":["\":add(player,site)\";","if (!caller_perms().wizard)","return E_PERM;","endif","{who, domain} = args;","if (this:domain_literal(domain))","\"... just enter it...\";","l = this:find_exact(domain);","if (l == $failed_match)","this:insert(domain, {who});","elseif (!(who in l))","this:insert(domain, setadd(l, who));","endif","else","\"...an actual domain name; add player to list for that domain...\";","\"...then add domain itself to list for the next larger domain; repeat...\";","\"...  Example:  domain == foo.bar.edu:  \";","\"...            enter #who  on foo.bar.edu list\";","\"...            enter `foo' on bar.edu list\";","\"...            enter `bar' on edu list\";","if (!(dot = index(domain, \".\")))","dot = length(domain) + 1;","domain = tostr(domain, \".\", this.domain);","endif","prev = who;","while ($failed_match == (l = this:find_exact(domain)))","this:insert(domain, {prev});","if (dot)","prev = domain[1..dot - 1];","domain = domain[dot + 1..$];","else","return;","endif","dot = index(domain, \".\");","endwhile","if (!(prev in l))","this:insert(domain, {@l, prev});","endif","return;","endif"]},{"name":"load","owner":2,"perms":173,"preposition":-1,"code":["\":load([start]) -- reloads site_db with the connection places of all players.\";","\"This routine calls suspend() if it runs out of time.\";","\"WIZARDLY\";","\"...needs to be able to read .all_connect_places\";","if (!$perm_utils:controls(caller_perms(), this))","return E_PERM;","endif","plist = players();","if (!args)","this:clearall();","elseif (i = args[1] in plist)","plist[1..i - 1] = {};","else","return E_INVARG;","endif","for p in (plist)","if (valid(p) && (is_player(p) && (!$object_utils:isa(p, $guest))))","\"... player may be recycled or toaded during the suspend(),...\";","\"... guests login from everywhere...\";","for c in (p.all_connect_places)","this:add(p, c);","if ($command_utils:running_out_of_time())","player:tell(\"...\", p);","suspend(0);","endif","endfor","endif","endfor"]},{"name":"domain_literal","owner":36,"perms":173,"preposition":-1,"code":["\":domain_literal(string)\";","\" => true iff string is a domain literal (i.e., numeric IP address).\";","if (10 <= (len = length(hnum = strsub(args[1], \".\", \"\"))))","return toint(hnum[1..9]) && toint(hnum[6..len]);","else","return toint(hnum);","endif","\"SLEAZY CODE ALERT\";","\"... what I wanted to do was return toint(strsub(args[1],\\\".\\\",\\\"\\\"))\";","\"... but on a 32-bit machine, this has a 1 in 4294967296 chance of failing\";","\"... (e.g., on \\\"42.94.967.296\\\", though I'll grant this particular example\";","\"...  entails some very strange subnetting on net 42, to say the least).\";","\"... So we do something that is guaranteed to work so long as internet\";","\"... addresses stay under 32 bits --- a while yet...\";","\"\";","\"... As soon as we're sure match() is working, this will become a one-liner:\";","return match(args[1], \"[0-9]+%.[0-9]+%.[0-9]+%.[0-9]+\");"]},{"name":"init_for_core","owner":36,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","pass();","this:clearall();","this.domain = \"localdomain\";","endif"]},{"name":"prune_alpha","owner":2,"perms":173,"preposition":-1,"code":["\"Carefully loop through the db and delete items associated with !valid and !is_player objects.  If that results in no objects remaining for a site, delete that site.\";","\"Attempt to keep memory usage down by only asking for a small number of items at a time.  Should probably have some arguments to control this.\";","\"Another thing it should do is be clever about string typed items.  (What did I mean by this?)\";","\"New feature: If the site name contains `dialup', then, if none of the users who have connected from there still have it in their .all_connect_places, then consider it trashable.  Maybe this will get some space savings.\";","\"To run: call $site_db:prune_reset() then $site_db:prune_alpha().\";","\"or $site_db:prune_alpha(1) for verbose output\";","verbose = args && args[1];","if (!caller_perms().wizard)","raise(E_PERM);","endif","this.prune_task = task_id();","probe = this.prune_progress;","while ((probe <= this.prune_stop) && (length(probe) == length(this.prune_stop)))","for sitename in (z = this:find_all_keys(probe))","items = this:find_exact(sitename);","orig = items;","dialup = index(sitename, \"dialup\");","\"Don't keep around dialups.\";","for y in (items)","if ((typeof(y) == OBJ) && (((!valid(y)) || (!is_player(y))) || (dialup && (!(sitename in y.all_connect_places)))))","verbose && player:tell(\"removing \", $string_utils:nn(y), \" from \", sitename);","items = setremove(items, y);","endif","$command_utils:suspend_if_needed(0);","endfor","useless = 1;","\"If no player has this site in eir .all_connect_places, nuke it anyway.\";","for y in (items)","if ((typeof(y) != OBJ) || (sitename in y.all_connect_places))","useless = 0;","break;","\"unfortunately this can get kinna O(n^2).\";","endif","$command_utils:suspend_if_needed(0);","endfor","if (useless)","verbose && player:tell(sitename, \" declared useless and nuked\");","items = {};","endif","if (!items)","this:delete(sitename);","this.total_pruned_sites = this.total_pruned_sites + 1;","elseif (items == orig)","else","this:insert(sitename, items);","this.total_pruned_people = (this.total_pruned_people + length(orig)) - length(items);","endif","$command_utils:suspend_if_needed(0);","if (probe >= this.prune_stop)","return player:tell(\"Prune stopped at \", toliteral(this.prune_progress));","endif","endfor","probe = $string_utils:incr_alpha(probe, this.alphabet);","this.prune_progress = probe;","if ($command_utils:running_out_of_time())","set_task_perms($wiz_utils:random_wizard());","suspend(0);","endif","endwhile","player:tell(\"Prune stopped at \", toliteral(this.prune_progress));"]},{"name":"report_prune_progress","owner":2,"perms":173,"preposition":-1,"code":["player:tell(\"Prune is up to \", toliteral(this.prune_progress), \".\");","mine = 0;","if (typeof(this.prune_progress) == STR)","alphalen = length(this.alphabet);","total = (alphalen * alphalen) * alphalen;","for x in [1..3]","mine = ((mine * alphalen) + index(this.alphabet, this.prune_progress[x])) - 1;","endfor","else","total = 256 * 256;","mine = (this.prune_progress[1] * 256) + this.prune_progress[2];","endif","percent = (100.0 * tofloat(mine)) / tofloat(total);","player:tell(\"We have processed \", mine, \" entries out of \", total, \", or \", toint(percent), \".\", toint(10.0 * percent) % 10, \"%.\");","player:tell(\"There were \", this.total_pruned_people, \" individual list entries removed, and \", this.total_pruned_sites, \" whole sites removed.\");","if ($code_utils:task_valid(this.prune_task))","player:tell(\"Prune task is \", this.prune_task, \".  Stacktrace:\");","for x in (task_stack(this.prune_task, 1))","if (valid(x[4]))","player:tell(x[4], \":\", x[2], \" [\", x[1], \"]  \", x[3].name, \"  (\", x[6], \")\");","endif","endfor","else","player:tell(\"The recorded task_id is no longer valid.\");","endif"]},{"name":"prune_fixup","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","raise(E_PERM);","endif","if (!args)","for x in ({\"com\", \"edu\", \"us\", \"au\", \"net\", \"za\", \"uk\", \"at\", \"ca\", \"org\", \"il\", \"mil\", \"no\", \"gov\", \"se\", \"fi\", \"it\", \"be\", \"jp\", \"de\", \"pt\", \"sg\", \"ie\", \"br\", \"nl\", \"gr\", \"ch\", \"pl\", \"nz\", \"<none>\", \"<bad>\", \"ee\", \"dk\", \"fr\", \"si\", \"cz\", \"th\", \"tw\", \"hk\", \"su\", \"es\", \"kr\", \"hr\", \"is\", \"mx\", \"my\", \"ro\", \"kw\", \"cl\", \"ph\", \"cr\", \"tr\", \"in\", \"eg\", \"ec\", \"lv\", \"ve\", \"sk\", \"ar\", \"co\", \"pe\", \"hu\", \"jm\", \"ni\", \"ru\", \"id\", \"bm\", \"mt\", \"cn\", \"bg\", \"pk\", \"uy\", \"yu\", \"ae\", \"zw\", \"gi\", \"sm\", \"nu\"})","this:prune_fixup(x);","endfor","return;","endif","root = args[1];","items = this:find_exact(root);","orig = items;","if (items == #-3)","return 1;","endif","$site_db.prune_progress = root;","$site_db.prune_task = task_id();","for item in (items)","if (typeof(item) == STR)","if (this:prune_fixup((item + \".\") + root))","items = setremove(items, item);","endif","endif","if ($command_utils:running_out_of_time())","set_task_perms($wiz_utils:random_wizard());","suspend(0);","endif","endfor","if (!items)","this:delete(root);","this.total_pruned_sites = this.total_pruned_sites + 1;","return 1;","elseif (orig == items)","else","this:insert(root, items);","endif"]},{"name":"prune_numeric","owner":2,"perms":173,"preposition":-1,"code":["\"Carefully loop through the db and delete items associated with !valid and !is_player objects.  If that results in no objects remaining for a site, delete that site.\";","\"Attempt to keep memory usage down by only asking for a small number of items at a time.  Should probably have some arguments to control this.\";","\"Another thing it should do is be clever about string typed items.\";","\"Rewriting this to do numerics now.\";","if (!caller_perms().wizard)","raise(E_PERM);","endif","this.prune_task = task_id();","probe = this.prune_progress;","while (probe[1] <= this.prune_stop)","probestring = tostr(probe[1], \".\", probe[2], \".\");","for sitename in (z = this:find_all_keys(probestring))","items = this:find_exact(sitename);","orig = items;","for y in (items)","if ((typeof(y) == OBJ) && ((!valid(y)) || (!is_player(y))))","items = setremove(items, y);","endif","$command_utils:suspend_if_needed(0);","endfor","if (!items)","this:delete(sitename);","this.total_pruned_sites = this.total_pruned_sites + 1;","elseif (items == orig)","else","this:insert(sitename, items);","this.total_pruned_people = (this.total_pruned_people + length(orig)) - length(items);","endif","$command_utils:suspend_if_needed(0);","endfor","if (probe[2] == 255)","probe[1] = probe[1] + 1;","probe[2] = 0;","else","probe[2] = probe[2] + 1;","endif","this.prune_progress = probe;","if ($command_utils:running_out_of_time())","set_task_perms($wiz_utils:random_wizard());","suspend(0);","endif","endwhile","player:tell(\"Prune stopped at \", toliteral(this.prune_progress));"]},{"name":"schedule_prune","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return E_PERM;","endif","day = 24 * 3600;","hour_of_day_GMT = 10;","target = (((hour_of_day_GMT * 60) * 60) + day) - (time() % day);","if (target > 86400)","target = target - 86400;","endif","fork (target)","\"Stop at 2am before checkpoint.\";","if ($code_utils:task_valid(this.prune_task))","$site_db.prune_stop = \"aaa\";","\"Restart after 3am.  Er, 4am.\";","suspend(7500);","this:schedule_prune();","$site_db.prune_stop = \"zzz\";","\"Just in case it didn't actually stop...\";","if (!$code_utils:task_valid(this.prune_task))","$site_db:prune_alpha();","endif","endif","endfork"]},{"name":"prune_reset","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","raise(E_PERM);","endif","this:report_prune_progress();","player:tell(\"Resetting...\");","this.total_pruned_sites = 0;","this.total_pruned_people = 0;","this.prune_progress = \"aaa\";","this.prune_stop = \"zzz\";","`kill_task(this.prune_task) ! ANY';"]},{"name":"xsin","owner":36,"perms":173,"preposition":-1,"code":["\"xsin(INT x) -- calculates the taylor approximation for the sine function\";","if (typeof(x = args[1]) != INT)","return E_TYPE;","endif","if ((x * x) > this.taylor)","return ((this:xsin(x / 2) * this:xcos((x + 1) / 2)) + (this:xsin((x + 1) / 2) * this:xcos(x / 2))) / 10000;","else","return (x * (17453000 - ((x * x) * 886))) / 100000;","endif"]},{"name":"xcos","owner":36,"perms":173,"preposition":-1,"code":["\"xcos(INT x) -- calculates the taylor approximation for the cosine function\";","if (typeof(x = args[1]) != INT)","return E_TYPE;","endif","if ((x * x) > this.taylor)","return ((this:xcos(x / 2) * this:xcos((x + 1) / 2)) - (this:xsin(x / 2) * this:xsin((x + 1) / 2))) / 10000;","else","return (1000000000 - ((x * x) * (152309 + ((4 * x) * x)))) / 100000;","endif"]},{"name":"factorial","owner":36,"perms":173,"preposition":-1,"code":["\"factorial(INT n) -- returns n factorial for 0 <= n (<= 12).\";","if ((number = args[1]) < 0)","return E_INVARG;","elseif (typeof(number) != INT)","return E_TYPE;","endif","fact = 1;","for i in [2..number]","fact = fact * i;","endfor","return fact;"]},{"name":"pow","owner":36,"perms":173,"preposition":-1,"code":["\"pow(INT|FLOAT x,(INT)|(INT|FLOAT) n) -- returns x raised to the nth power. n must be >= 0. If x is an integer, n must be an integer. If x is a floating point number, n can be either.\";","{x, n} = args;","if (n < 0)","return E_INVARG;","elseif ((typeof(x) == INT) && (typeof(n) == FLOAT))","return E_TYPE;","endif","return x ^ n;","\"old code below\";","n = args[1];","if (power % 2)","ret = n;","else","ret = 1;","endif","while (power = power / 2)","n = n * n;","if (power % 2)","ret = ret * n;","endif","endwhile","return ret;"]},{"name":"fibonacci","owner":36,"perms":173,"preposition":-1,"code":["\"fibonacci(INT n) -- calculates the fibonacci numbers to the nth term\";","\"and returns them in a list. n must be >= 0.\";","if (typeof(n = args[1]) != INT)","return E_TYPE;","elseif (n < 0)","return E_INVARG;","elseif (n == 0)","return {0};","else","x = {0, 1};","for i in [2..n]","x = {@x, x[$ - 1] + x[$]};","endfor","return x;","endif"]},{"name":"geometric","owner":36,"perms":173,"preposition":-1,"code":["\"geometric(INT|FLOAT x [,INT n]) -- calculates the value of the geometric series at x to the nth term. i.e., approximates 1/(1-x) when |x| < 1. This, of course, is impossible in MOO, but someone may find it useful in some way.\";","\"n defaults to 5. n must be >= 0.\";","{n, ?order = 5} = args;","if ((!(typeof(n) in {INT, FLOAT})) || (typeof(order) != INT))","return E_TYPE;","elseif (order <= 0)","return E_INVARG;","endif","x = 1;","for i in [1..order]","x = x + (n ^ i);","endfor","return x;"]},{"name":"divmod","owner":36,"perms":173,"preposition":-1,"code":["\"divmod(INT n, INT d) => {q,r} such that n = dq + r\";","\"  handles negative numbers correctly   0<=r<d if d>0, -d<r<=0 if d<0.\";","{n, d} = args;","if ((typeof(n) != INT) && (typeof(d) != INT))","return E_TYPE;","endif","r = ((n % d) + d) % d;","q = (n - r) / d;","return {q, r};"]},{"name":"combinations","owner":36,"perms":173,"preposition":-1,"code":["\"combinations(INT n, INT r) -- returns the number of ways one can choose r\";","\"objects from n distinct choices.\";","\"C(n,r) = n!/[r!(n-r)!]\";","\"  overflow may occur if n>29...\";","{n, r} = args;","if ((typeof(n) != INT) && (typeof(r) != INT))","return E_TYPE;","endif","if (0 > (r = min(r, n - r)))","return 0;","else","c = 1;","n = n + 1;","for i in [1..r]","c = (c * (n - i)) / i;","endfor","return c;","endif"]},{"name":"permutations","owner":36,"perms":173,"preposition":-1,"code":["\"permutations(INT n, INT r) -- returns the number of ways possible for one to\";","\"order r distinct objects given n locations.\";","\"P(n,r) = n!/(n-r)!\";","{n, r} = args;","if ((typeof(n) != INT) && (typeof(r) != INT))","return E_TYPE;","endif","if ((r < 1) || ((diff = n - r) < 0))","return 0;","else","p = n;","for i in [diff + 1..n - 1]","p = p * i;","endfor","return p;","endif"]},{"name":"simpson","owner":36,"perms":173,"preposition":-1,"code":["\"simpson({a,b},{f(a),f((a+b)/2),f(b)} [,INT ret-float])\";","\" -- given two endpoints, a and b, and the functions value at a, (a+b)/2, and b, this will calculate a numerical approximation of the integral using simpson's rule.\";","\"Entries can either be all INT or all FLOAT. Don't mix!\";","\"If the optional 3rd argument is provided and true, the answer is returned as a floating point regardless of what the input was. Otherwise, if the input was all INT, the answer is returned as {integer,fraction}\";","{point, fcn, ?retfloat = 0} = args;","if ((!retfloat) && (typeof(point[1]) == INT))","numer = (point[2] - point[1]) * ((fcn[1] + (4 * fcn[2])) + fcn[3]);","return this:parts(numer, 6);","else","numer = tofloat(point[2] - point[1]) * ((tofloat(fcn[1]) + (4.0 * tofloat(fcn[2]))) + tofloat(fcn[3]));","return numer / 6.0;","endif"]},{"name":"parts","owner":36,"perms":173,"preposition":-1,"code":["\"parts(INT n, INT q [,INT i]) -- returns a decomposition of n by q into integer and floating point parts with i = the number of digits after the decimal.\";","\"i defaults to 5.\";","\"warning: it is quite easy to hit maxint which results in unpredictable\";","\"         results\";","{n, q, ?i = 5} = args;","if (((typeof(n) != INT) && (typeof(q) != INT)) && (typeof(i) != INT))","return E_TYPE;","endif","parts = {n / q, n % q};","return {parts[1], (parts[2] * (10 ^ i)) / q};"]},{"name":"sqrt","owner":36,"perms":173,"preposition":-1,"code":["\"sqrt(INT|FLOAT n) => largest integer <= square root of n. Returns the same type as the input. (Backwards compatibility)\";","n = args[1];","return (typeof(n) == INT) ? toint(sqrt(tofloat(n))) | sqrt(n);","\"Old code. Newton's method\";","if (n < 0)","return E_RANGE;","elseif (n)","x1 = n;","while (x1 > (x2 = (x1 + (n / x1)) / 2))","x1 = x2;","endwhile","return x1;","else","return 0;","endif"]},{"name":"div","owner":36,"perms":173,"preposition":-1,"code":["\"div(INT n, INT d) => q such that n = dq + r and  (0<=r<d if d>0, -d<r<=0 if d<0).\";","return this:divmod(@args)[1];"]},{"name":"mod","owner":36,"perms":173,"preposition":-1,"code":["\"A correct mod function.\";","\"mod(INT n, INT d) => r such that n = dq + r and (0<=r<d if d>0 or -d<r<=0 if d<0).\";","{n, d} = args;","if ((typeof(n) != INT) && (typeof(d) != INT))","return E_TYPE;","endif","return ((n % d) + d) % d;"]},{"name":"exp","owner":36,"perms":173,"preposition":-1,"code":["\"exp(INT|FLOAT x[,INT n]) -- calculates an nth order taylor approximation for e^x.\";","\"n defaults to 5. Any n given must be >= 0. you need to divide the result\";","\"the answer will be returned as {integer part,fractional part} if the input x was an integer. If it is floating point, so will the answer (and this uses the builtin function.)\";","{x, ?n = 5} = args;","if (typeof(x) == FLOAT)","return exp(x);","elseif ((typeof(x) != INT) && (typeof(n) != INT))","return E_TYPE;","endif","ex = nfact = 1;","for i in [0..n - 1]","j = n - i;","ex = (ex * x) + (nfact = nfact * j);","endfor","return this:parts(ex, nfact);"]},{"name":"aexp","owner":36,"perms":173,"preposition":-1,"code":["\"returns 10000 exp (x/10000)\";","\"The accuracy seems to be ~0.1% for 0<x<4\";","x = args[1];","if (x < 0)","z = this:(verb)(-x);","return (100000000 + (z / 2)) / z;","elseif (x > 1000)","z = this:(verb)(x / 2);","if (z > 1073741823)","return $maxint;","\"maxint for overflows\";","elseif (z > 460000)","z = ((z + 5000) / 10000) * z;","elseif (z > 30000)","z = ((((z + 50) / 100) * z) + 50) / 100;","else","z = ((z * z) + 5000) / 10000;","endif","if (x % 2)","return z + ((z + 5000) / 10000);","else","return z;","endif","else","return ((10000 + x) + (((x * x) + 10000) / 20000)) + ((((x * x) * x) + 300000000) / 600000000);","endif"]},{"name":"random","owner":36,"perms":173,"preposition":-1,"code":["\"random(INT n): returns a random integer in the following manner:\";","\"random(n > 0) will return a integer in the range 0 to n\";","\"random(n < 0) will return a integer in the range n to 0\";","if (typeof(prob = args[1]) != INT)","return E_TYPE;","endif","mod = (prob < 0) ? -1 | 1;","return (mod * random(abs(prob + mod))) - mod;"]},{"name":"random_range","owner":36,"perms":173,"preposition":-1,"code":["\"random_range(INT range [,INT mean]): returns a random integer within the given range from the mean. if the mean isn't given, it defaults to 0\";","\"e.g., random_range(10) => -10..10\";","\"      random_range(10,4) => -6..14\";","{range, ?mean = 0} = args;","if ((typeof(range) != INT) && (typeof(mean) != INT))","return E_TYPE;","endif","return mean + (((random(2) == 1) ? -1 | 1) * this:random(range));"]},{"name":"is_prime","owner":36,"perms":173,"preposition":-1,"code":["\"is_prime(INT number) returns 1 if the number is prime or 0 if it isn't.\";","\"of course, only positive numbers are candidates for primality.\";","if (typeof(number = args[1]) != INT)","return E_TYPE;","endif","if (number == 2)","return 1;","elseif ((number < 2) || ((number % 2) == 0))","return 0;","else","choice = 3;","while (((denom = choice * choice) <= number) && (denom > 0))","if ((seconds_left() < 2) || (ticks_left() < 25))","suspend(0);","endif","if ((number % choice) == 0)","return 0;","endif","choice = choice + 2;","endwhile","endif","return 1;"]},{"name":"AND XOR","owner":36,"perms":173,"preposition":-1,"code":["\"Only useful for integer input.\";","{x, y} = args;","if ((typeof(x) != INT) && (typeof(y) != INT))","return E_TYPE;","endif","table = this.(verb);","if (xsgn = x < 0)","x = x + $minint;","endif","if (ysgn = y < 0)","y = y + $minint;","endif","power = 1;","z = 0;","while (x || y)","z = z + (power * table[1 + (x % 16)][1 + (y % 16)]);","x = x / 16;","y = y / 16;","power = power * 16;","endwhile","if (table[1 + xsgn][1 + ysgn])","return z + $minint;","else","return z;","endif"]},{"name":"OR","owner":36,"perms":173,"preposition":-1,"code":["return this:NOT(this:AND(this:NOT(args[1]), this:NOT(args[2])));"]},{"name":"NOT","owner":36,"perms":173,"preposition":-1,"code":["return -(1 + args[1]);","\"\";","\"... here's what it used to be ...\";","bl1 = this:BLFromInt(args[1]);","blOut = {};","for i in [1..32]","blOut = {@blOut, !bl1[i]};","endfor","return this:IntFromBL(blOut);"]},{"name":"BLFromInt","owner":36,"perms":173,"preposition":-1,"code":["\"BlFromInt(INT x) => converts the number provided into a 32 bit binary number, which is returned via a 32 element LIST of 1's and 0's. Note that this verb was originally written to be used with the $math_utils verbs: AND, NOT, OR, XOR, but has since been taken out of them.\";","if (typeof(x = args[1]) != INT)","return E_TYPE;","endif","l = {};","firstbit = x < 0;","if (firstbit)","x = x + $minint;","endif","for i in [1..31]","l = {x % 2, @l};","x = x / 2;","endfor","return {firstbit, @l};"]},{"name":"IntFromBL","owner":36,"perms":173,"preposition":-1,"code":["\"IntFromBl(LIST of 1's and 0's) => converts the 32 bit binary representation given by the list of 1's and 0's and converts it to a normal decimal number. Note that this verb was originally written to be used with the $math_utils verbs: AND, NOT, OR, XOR, but has since been taken out of them.\";","bl = args[1];","x = 0;","for l in (bl)","x = x * 2;","x = x + l;","endfor","return x;"]},{"name":"gcd greatest_common_divisor","owner":36,"perms":173,"preposition":-1,"code":["\"gcd(INT num1,INT num2): find the greatest common divisor of the two numbers\";","\"using the division algorithm. the absolute values of num1 and num2 are\";","\"used without loss of generality.\";","num1 = abs(args[1]);","num2 = abs(args[2]);","max = max(num1, num2);","min = min(num1, num2);","if (r1 = max % min)","while (r2 = min % r1)","min = r1;","r1 = r2;","endwhile","return r1;","else","return min;","endif"]},{"name":"lcm least_common_multiple","owner":36,"perms":173,"preposition":-1,"code":["\"lcm(INT num1,INT num2): find the least common multiple of the two numbers.\";","\"we shall use the positive lcm value without loss of generality.\";","\"since we have gcd already, we'll just use lcm*gcd = num1*num2\";","num1 = abs(args[1]);","num2 = abs(args[2]);","return (num1 * num2) / this:gcd(num1, num2);"]},{"name":"are_rel_prime are_relatively_prime","owner":36,"perms":173,"preposition":-1,"code":["\"are_rel_prime(INT num1,INT num2): returns 1 if num1 and num2 are relatively\";","\"prime.\";","\"since we have gcd, this is pretty easy.\";","if (this:gcd(args[1], args[2]) == 1)","return 1;","else","return 0;","endif"]},{"name":"base_conversion","owner":36,"perms":173,"preposition":-1,"code":["\"Call with first arg either a number or a string, being the number\";","\"desired for conversion. capital letters denote values from 10-35;\";","\"lowercase letters from 36 to 61. Maximal base is 62.\";","\"You will be unable to use the extra 26 lowercases as separate unless\";","\"you pass a nonzero fourth argument. Passing zero or none uses the\";","\"default value, which is to have AAAA=aaaa.\";","\"The second and third arguments should be the base of the number and\";","\"the base you want it in, respectively.\";","\"Any of the arguments can be strings or nums, but high-base numbers\";","\"will need to be strings. This returns a string.\";","\"Any problems, talk to Ozymandias.\";","sensitive = 0;","if (length(args) < 3)","return E_INVARG;","elseif (length(args) == 4)","sensitive = toint(args[4]);","endif","result = 0;","thenum = tostr(args[1]);","origbase = toint(args[2]);","newbase = toint(args[3]);","if ((((origbase < 2) || (newbase < 2)) || (origbase > 62)) || (newbase > 62))","return E_INVARG;","endif","for which in [1..length(thenum)]","value = index(this.base_alphabet, thenum[which], sensitive);","if ((!value) || (value > origbase))","return E_INVARG;","endif","result = ((result * origbase) + value) - 1;","endfor","thestring = \"\";","if (result < 0)","return E_INVARG;","endif","while (result)","if ((which = (result % newbase) + 1) <= length(this.base_alphabet))","thestring = this.base_alphabet[which] + thestring;","else","return E_INVARG;","endif","result = result / newbase;","endwhile","return thestring;"]},{"name":"norm","owner":36,"perms":173,"preposition":-1,"code":["\":norm(a,b,c,d...) => sqrt(a^2+b^2+c^2+...)\";","m = max(max(@args), -min(@args));","logm = length(tostr(m));","if (logm <= 4)","s = 0;","for a in (args)","s = s + (a * a);","endfor","return toint(sqrt(tofloat(s)));","else","factor = toint(\"1\" + \"0000000\"[1..logm - 4]);","s = 0;","for a in (args)","a = a / factor;","s = s + (a * a);","endfor","return toint(sqrt(tofloat(s))) * factor;","endif"]},{"name":"sin","owner":36,"perms":173,"preposition":-1,"code":["\"Copied from Trig_Utils (#25800):sin by Obvious (#54879) Fri Nov 17 06:07:39 1995 PST\";","theta = args[1];","if (typeof(theta) == FLOAT)","return sin(theta);","elseif (typeof(theta) == INT)","degtheta = theta % 360;","mintheta = 0;","elseif (typeof(theta) == LIST)","degtheta = theta[1] % 360;","mintheta = theta[2] % 60;","else","return E_INVARG;","endif","if (mintheta < 0)","mintheta = mintheta + 60;","degtheta = degtheta - 1;","endif","while (degtheta < 1)","degtheta = degtheta + 360;","endwhile","if (mintheta == 0)","return this.sines[degtheta];","endif","lim1 = this.sines[degtheta];","lim2 = this.sines[degtheta + 1];","delta = lim2 - lim1;","result = (((delta * mintheta) + 30) / 60) + lim1;","return result;"]},{"name":"cos","owner":36,"perms":173,"preposition":-1,"code":["\"Copied from Trig_Utils (#25800):cos by Obvious (#54879) Fri Nov 17 06:07:50 1995 PST\";","theta = args[1];","if (typeof(theta) == FLOAT)","return cos(theta);","elseif (typeof(theta) == INT)","degtheta = 90 - theta;","mintheta = 0;","elseif (typeof(theta) == LIST)","degtheta = 89 - theta[1];","mintheta = 60 - theta[2];","else","return;","endif","return this:sin({degtheta, mintheta});"]},{"name":"tan","owner":36,"perms":173,"preposition":-1,"code":["\"Copied from Trig_Utils (#25800):tan by Obvious (#54879) Fri Nov 17 06:07:53 1995 PST\";","{theta} = args;","if (typeof(theta) == FLOAT)","return tan(theta);","endif","sine = this:sin(theta);","cosine = this:cos(theta);","return ((sine * 10000) + ((cosine + 1) / 2)) / cosine;"]},{"name":"arcsin asin","owner":36,"perms":173,"preposition":-1,"code":["\"Copied from Trig_Utils (#25800):arcsin by Obvious (#54879) Fri Nov 17 06:08:01 1995 PST\";","{given} = args;","if (typeof(given) == FLOAT)","return asin(given);","endif","given = abs(given);","if (given > 10000)","return E_RANGE;","endif","i = 1;","while (given > this.sines[i])","i = i + 1;","endwhile","if (given == this.sines[i])","if (args[1] < 0)","return {-i, 0};","else","return {i, 0};","endif","endif","degrees = i - 1;","if (i == 1)","lower = 0;","else","lower = this.sines[i - 1];","endif","upper = this.sines[i];","delta1 = given - lower;","delta2 = upper - lower;","minutes = ((delta1 * 60) + ((delta2 + 1) / 2)) / delta2;","if (args[1] < 0)","degrees = -degrees;","minutes = -minutes;","endif","return {degrees, minutes};"]},{"name":"arccos acos","owner":36,"perms":173,"preposition":-1,"code":["\"Copied from Trig_Utils (#25800):arccos by Obvious (#54879) Fri Nov 17 06:08:08 1995 PST\";","given = args[1];","if (typeof(given) == FLOAT)","return acos(given);","endif","arcsin = this:arcsin(given);","degrees = 89 - arcsin[1];","minutes = 60 - arcsin[2];","if (minutes > 60)","minutes = minutes - 60;","degrees = degrees + 1;","endif","return {degrees, minutes};"]},{"name":"arctan atan","owner":36,"perms":173,"preposition":-1,"code":["\"Copied from Trig_Utils (#25800):arctan by Obvious (#54879) Fri Nov 17 06:08:18 1995 PST\";","given = args[1];","if (typeof(given) == FLOAT)","return atan(given);","endif","reciprocal = ((given * given) / 10000) + 10000;","reciprocal = sqrt(reciprocal * 10000);","cosine = 100000000 / reciprocal;","return this:arccos(cosine);"]},{"name":"deg2rads deg2rad","owner":36,"perms":173,"preposition":-1,"code":["\":deg2rad(FLOAT Degrees) => FLOAT Radians\";","return tofloat(args[1]) * 0.0174532925199433;"]},{"name":"rads2deg rad2deg","owner":36,"perms":173,"preposition":-1,"code":["\":rads2deg(FLOAT Radians) => FLOAT Degrees\";","return tofloat(args[1]) * 57.2957795130824;"]},{"name":"precision","owner":36,"perms":173,"preposition":-1,"code":["\":precision(FLOAT Number, INT Digits of Precision) => FLOAT Number\";","\"Cuts the given number to the given digits of precision.  Uses rounding.\";","{digits, pre} = args;","mult = 10.0 ^ pre;","return this:rint(digits * mult) / mult;"]},{"name":"round","owner":36,"perms":173,"preposition":-1,"code":["\"Usage: round(INT number, INT round)\";","\"Rounds 'number' off to the nearest multiple of 'round'.\";","\"Rounds UP numbers exactly half way in between two round possibilities.\";","{what, round} = args;","low = (what / round) * round;","return (what < (low + (round / 2))) ? low | (low + round);"]},{"name":"mean average","owner":36,"perms":173,"preposition":-1,"code":["\"Usage: mean(INT, INT, ... )\";","\"       mean({INT, INT, ...})\";","\"Returns the average of all integers provided.\";","return this:sum(rlist = (typeof(args[1]) == LIST) ? args[1] | args) / length(rlist);"]},{"name":"sum_float","owner":36,"perms":173,"preposition":-1,"code":["\":sum_float(FLOAT num, num, num ...) => Total of all arguments added together.\";","\":sum_float({num, num, num, ...}) will also work.\";","{?total = 0.0, @rest} = args;","if (typeof(total) == LIST)","{?total = 0.0, @rest} = total;","endif","for number in (rest)","total = total + number;","endfor","return total;"]},{"name":"sum_int sum","owner":36,"perms":173,"preposition":-1,"code":["\":sum_int(INT num, num, num ...) => Total of all arguments added together.\";","\":sum_int({num, num, num, ...}) will also work.\";","\"(...also named :sum for backward compatibility).\";","\"Use :sum_float to sum a list of floats.\";","{?total = 0, @rest} = args;","if (typeof(total) == LIST)","{?total = 0, @rest} = total;","endif","for number in (rest)","total = total + number;","endfor","return total;","\"... N.B.  For the sake of backward compatibility this routine will also return the float sum of a non-empty lists of floats, but using it this way should not be encouraged.\";"]},{"name":"rint","owner":36,"perms":173,"preposition":-1,"code":["\":rint(FLOAT Number) => FLOAT Number\";","\"Returns the given floating-point number rounded to the nearest integer, as a floating-point number.  In case of ties, rounds away from 0.\";","{f} = args;","return trunc((f > 0.0) ? f + 0.5 | (f - 0.5));"]},{"name":"union","owner":36,"perms":173,"preposition":-1,"code":["\"Returns the set union of all of the lists provided as arguments.\";","if (!args)","return {};","endif","{set, @rest} = args;","for l in (rest)","for x in (l)","set = setadd(set, x);","endfor","endfor","return set;"]},{"name":"intersection","owner":36,"perms":173,"preposition":-1,"code":["\"Returns the set intersection of all the lists provided as arguments.\";","if (!args)","return {};","endif","max = 0;","{result, @rest} = args;","for set in (rest)","if (length(result) < length(set))","set1 = result;","set2 = set;","else","set1 = set;","set2 = result;","endif","for x in (set1)","if (!(x in set2))","set1 = setremove(set1, x);","endif","endfor","result = set1;","endfor","return result;"]},{"name":"diff*erence","owner":36,"perms":173,"preposition":-1,"code":["\"Usage:  diff(set 1, set 2, ..., set n)\";","\"Returns all elements of set 1 that are not in sets 2..n\";","{set, @rest} = args;","for l in (rest)","for x in (l)","set = setremove(set, x);","endfor","endfor","return set;"]},{"name":"contains","owner":36,"perms":173,"preposition":-1,"code":["\"True if the first list given is a superset of all subsequent lists.\";","\"False otherwise.  {} is a superset of {} and nothing else; anything is\";","\"a superset of {}.  If only one list is given, return true.\";","{?super = {}, @rest} = args;","for l in (rest)","for x in (l)","if (!(x in super))","return 0;","endif","endfor","endfor","return 1;"]},{"name":"exclusive_or xor","owner":36,"perms":173,"preposition":-1,"code":["\"Usage:  exclusive_or(set, set, ...)\";","\"Return the set of all elements that are in exactly one of the input sets\";","\"For two sets, this is the equivalent of (A u B) - (A n B).\";","if (!args)","return {};","endif","{set, @rest} = args;","so_far = set;","for l in (rest)","for x in (l)","if (x in so_far)","set = setremove(set, x);","else","set = setadd(set, x);","endif","endfor","so_far = {@so_far, @l};","endfor","return set;"]},{"name":"difference_suspended diff_suspended","owner":36,"perms":173,"preposition":-1,"code":["\"Usage:  diff_suspended(set 1, set 2, ..., set n)\";","\"Returns all elements of set 1 that are not in sets 2..n\";","\"Suspends as needed if the lists are large.\";","{set, @rest} = args;","for l in (rest)","for x in (l)","set = setremove(set, x);","$command_utils:suspend_if_needed(0);","endfor","endfor","return set;"]},{"name":"equal","owner":36,"perms":173,"preposition":-1,"code":["\"True if the two lists given contain the same elements.\";","\"False otherwise.\";","{set1, set2} = args;","while (set1)","{elt, @set1} = set1;","if (elt in set2)","set2 = setremove(set2, elt);","while (elt in set2)","set2 = setremove(set2, elt);","endwhile","while (elt in set1)","set1 = setremove(set1, elt);","endwhile","else","return 0;","endif","endwhile","if (set2)","return 0;","else","return 1;","endif"]},{"name":"intersection_preserve_case","owner":36,"perms":173,"preposition":-1,"code":["\"Copied from Fox (#54902):intersection Mon Dec 27 17:02:57 1993 PST\";","\"a version of $set_utils:intersection that maintains the property that everything in the return value is in the first argument, even considering case\";","if (!args)","return {};","endif","{result, @rest} = args;","for s in (rest)","for x in (result)","if (!(x in s))","result = setremove(result, x);","endif","endfor","endfor","return result;"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","raise(E_PERM);","endif","pass();","$prog.help = this;"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","pass();","this:rm_message_seq({1, 1 + this:length_all_msgs()});","this:expunge_rmm();","this.mail_forward = {};","this.mail_notify = {player};","player.current_message = {@player.current_message, {this, 0, 0}};","for p in ({\"moderator_forward\", \"writers\", \"readers\", \"expire_period\", \"last_used_time\"})","clear_property(this, p);","endfor","this.moderated = 1;","else","return E_PERM;","endif"]},{"name":"receive_message","owner":2,"perms":173,"preposition":-1,"code":["if (!this:is_writable_by(caller_perms()))","return E_PERM;","else","if (msgs = this.messages)","new = msgs[$][1] + 1;","else","new = 1;","endif","if (rmsgs = this.messages_going)","lbrm = rmsgs[$][2];","new = max(new, lbrm[$][1] + 1);","endif","m = args[1];","if (index(m[4], \"@programmer \") == 1)","m = {m[1], toobj(args[2]), o = toobj(m[4][rindex(m[4], \"(\") + 1..rindex(m[4], \")\") - 1]), o.name};","endif","this.messages = {@msgs, {new, m}};","this.last_msg_date = m[1];","this.last_used_time = time();","return new;","endif"]},{"name":"display_seq_headers display_seq_full","owner":2,"perms":173,"preposition":-1,"code":["\":display_seq_headers(msg_seq[,cur])\";","\":display_seq_full(msg_seq[,cur]) => {cur}\";","if (!this:ok(caller, caller_perms()))","return E_PERM;","endif","{msg_seq, ?cur = 0, ?read_date = $maxint} = args;","last = ldate = 0;","player:tell(\"       WHEN           \", $string_utils:left(this.keyword, -30), \"BY\");","for x in (msgs = this:messages_in_seq(args[1]))","msgnum = $string_utils:right(last = x[1], 4, (cur == x[1]) ? \">\" | \" \");","ldate = x[2][1];","if (typeof(x[2][2]) != OBJ)","hdr = this:msg_summary_line(@x[2]);","else","if (ldate < (time() - 31536000))","c = player:ctime(ldate);","date = c[5..11] + c[21..25];","else","date = player:ctime(ldate)[5..16];","endif","hdr = tostr(ctime(ldate)[5..16], \"   \", $string_utils:left(tostr(x[2][4], \" (\", x[2][3], \")\"), 30), valid(w = x[2][2]) ? w.name | \"??\", \" (\", x[2][2], \")\");","endif","player:tell(msgnum, (ldate > read_date) ? \":+ \" | \":  \", hdr);","$command_utils:suspend_if_needed(0);","endfor","if (verb == \"display_seq_full\")","return {last, ldate};","else","player:tell(\"----+\");","endif"]},{"name":"from_msg_seq","owner":2,"perms":173,"preposition":-1,"code":["\":from_msg_seq(object or list[,mask])\";","\" => msg_seq of messages from any of these senders\";","if (!this:ok(caller, caller_perms()))","return E_PERM;","endif","{plist, ?mask = {1}} = args;","if (typeof(plist) != LIST)","plist = {plist};","endif","i = 1;","fseq = {};","for msg in (this.messages)","if ((!mask) || (i < mask[1]))","elseif ((length(mask) < 2) || (i < mask[2]))","if (msg[2][2] in plist)","fseq = $seq_utils:add(fseq, i, i);","endif","else","mask = mask[3..$];","endif","i = i + 1;","$command_utils:suspend_if_needed(0);","endfor","return fseq || (\"%f %<has> no messages from \" + $string_utils:english_list($list_utils:map_arg(2, $string_utils, \"pronoun_sub\", \"%n (%#)\", plist), \"no one\", \" or \"));"]},{"name":"to_msg_seq","owner":2,"perms":173,"preposition":-1,"code":["\":to_msg_seq(object or list[,mask]) => msg_seq of messages to those people\";","if (!this:ok(caller, caller_perms()))","return E_PERM;","endif","{plist, ?mask = {1}} = args;","if (typeof(plist) != LIST)","plist = {plist};","endif","i = 1;","fseq = {};","for msg in (this.messages)","if ((!mask) || (i < mask[1]))","elseif ((length(mask) < 2) || (i < mask[2]))","if (msg[2][3] in plist)","fseq = $seq_utils:add(fseq, i, i);","endif","else","mask = mask[3..$];","endif","i = i + 1;","$command_utils:suspend_if_needed(0);","endfor","return fseq || (\"%f %<has> no messages about @programmer'ing \" + $string_utils:english_list(plist, \"no one\", \" or \"));"]},{"name":"%to_msg_seq subject_msg_seq","owner":2,"perms":173,"preposition":-1,"code":["\":%to_msg_seq/subject_msg_seq(string or list of strings[,mask])\";","\" => msg_seq of messages containing one of strings in the to line\";","if (!this:ok(caller, caller_perms()))","return E_PERM;","endif","{nlist, ?mask = {1}} = args;","if (typeof(nlist) != LIST)","nlist = {nlist};","endif","i = 1;","fseq = {};","for msg in (this.messages)","if ((!mask) || (i < mask[1]))","elseif ((length(mask) < 2) || (i < mask[2]))","if (msg[2][4] in nlist)","fseq = $seq_utils:add(fseq, i, i);","endif","else","mask = mask[3..$];","endif","i = i + 1;","$command_utils:suspend_if_needed(0);","endfor","return fseq || (\"%f %<has> no messages about @programmer'ing \" + $string_utils:english_list(nlist, \"no one\", \" or \"));"]},{"name":"%from_msg_seq","owner":2,"perms":173,"preposition":-1,"code":["return this.name + \" doesn't understand %%from:\";"]},{"name":"find_topics","owner":2,"perms":173,"preposition":-1,"code":["\"WIZARDLY\";","if (args)","\"...check for an exact match first...\";","search = args[1];","if (`$object_utils:has_property(parent(this), search) ! ANY')","if ($object_utils:has_property(this, \" \" + search))","return {search};","endif","elseif ($object_utils:has_property(this, search))","return {search};","endif","\"...search for partial matches, allowing for\";","\"...confusion between topics that do and don't start with @, and\";","\".. confusion between - and _ characters.\";","props = properties(this);","topics = {};","if (search[1] == \"@\")","search = search[2..$];","endif","search = strsub(search, \"-\", \"_\");","if (!search)","\"...don't try searching for partial matches if the string is empty or @\";","\"...we'd get *everything*...\";","return {};","endif","for prop in (props)","if (((i = index(strsub(prop, \"-\", \"_\"), search)) == 1) || ((i == 2) && index(\" @\", prop[1])))","topics = {@topics, (prop[1] == \" \") ? prop[2..$] | prop};","endif","endfor","return topics;","else","\"...return list of all topics...\";","props = setremove(properties(this), \"\");","for p in (`$object_utils:all_properties(parent(this)) ! ANY => {}')","if (i = (\" \" + p) in props)","props = {p, @listdelete(props, i)};","endif","endfor","return props;","endif"]},{"name":"get_topic","owner":2,"perms":173,"preposition":-1,"code":["\"WIZARDLY\";","{topic, ?dblist = {}} = args;","if (`$object_utils:has_property(parent(this), topic) ! ANY')","text = `this.(\" \" + topic) ! ANY';","else","text = `this.(topic) || this.(\" \" + topic) ! ANY';","endif","if (typeof(text) == LIST)","if (text && (text[1] == ((\"*\" + (vb = strsub(text[1], \"*\", \"\"))) + \"*\")))","text = `this:(vb)(listdelete(text, 1), dblist) ! ANY';","endif","endif","return text;"]},{"name":"sort_topics","owner":36,"perms":173,"preposition":-1,"code":["\":sort_topics(list_of_topics) -- sorts the given list of strings, assuming that they're help-system topic names\";","buckets = \"abcdefghijklmnopqrstuvwxyz\";","keys = names = $list_utils:make(length(buckets) + 1, {});","for name in (setremove(args[1], \"\"))","key = index(\".@\", name[1]) ? name[2..$] + \" \" | name;","k = index(buckets, key[1]) + 1;","bucket = keys[k];","i = $list_utils:find_insert(bucket, key);","keys[k] = listinsert(bucket, key, i);","names[k] = listinsert(names[k], name, i);","$command_utils:suspend_if_needed(0);","endfor","return $list_utils:append(@names);"]},{"name":"columnize","owner":36,"perms":173,"preposition":-1,"code":["\":columnize(@list_of_strings) -- prints the given list in a number of columns wide enough to accomodate longest entry. But no more than 4 columns.\";","longest = $list_utils:longest(args);","for d in ({4, 3, 2, 1})","if ((79 / d) >= length(longest))","return $string_utils:columnize_suspended(0, args, d);","endif","endfor"]},{"name":"forward pass","owner":36,"perms":173,"preposition":-1,"code":["\"{\\\"*forward*\\\", topic, @rest}  => text for topic from this help db.\";","\"{\\\"*pass*\\\",    topic, @rest}  => text for topic from next help db.\";","\"In both cases the text of @rest is appended.  \";","\"@rest may in turn begin with a *<verb>*\";","{text, ?dblist = {}} = args;","if (verb == \"forward\")","first = this:get_topic(text[1], dblist);","elseif ((result = $code_utils:help_db_search(text[1], dblist)) && ((db = result[1]) != $ambiguous_match))","first = db:get_topic(result[2], dblist[(db in dblist) + 1..$]);","else","first = {};","endif","if (2 <= length(text))","if (text[2] == ((\"*\" + (vb = strsub(text[2], \"*\", \"\"))) + \"*\"))","return {@first, @`this:(vb)(text[3..$], dblist) ! ANY => {}'};","else","return {@first, @text[2..$]};","endif","else","return first;","endif"]},{"name":"subst","owner":36,"perms":173,"preposition":-1,"code":["\"{\\\"*subst*\\\", @text} => text with the following substitutions:\";","\"  \\\"...%[expr]....\\\" => \\\"...\\\"+value of expr (assumed to be a string)+\\\"....\\\"\";","\"  \\\"%;expr\\\"         => @(value of expr (assumed to be a list of strings))\";","newlines = {};","for old in (args[1])","new = \"\";","bomb = 0;","while ((prcnt = index(old, \"%\")) && (prcnt < length(old)))","new = new + old[1..prcnt - 1];","code = old[prcnt + 1];","old = old[prcnt + 2..$];","if (code == \"[\")","prog = \"\";","while ((b = index(old + \"]\", \"]\")) > (p = index(old + \"%\", \"%\")))","prog = (prog + old[1..p - 1]) + old[p + 1];","old = old[p + 2..$];","endwhile","prog = prog + old[1..b - 1];","old = old[b + 1..$];","value = $no_one:eval_d(prog);","if (value[1])","new = tostr(new, value[2]);","else","new = tostr(new, toliteral(value[2]));","bomb = 1;","endif","elseif ((code != \";\") || new)","new = (new + \"%\") + code;","else","value = $no_one:eval_d(old);","if (value[1] && (typeof(r = value[2]) == LIST))","newlines = {@newlines, @r[1..$ - 1]};","new = tostr(r[$]);","else","new = tostr(new, toliteral(value[2]));","bomb = 1;","endif","old = \"\";","endif","endwhile","if (bomb)","newlines = {@newlines, new + old, tostr(\"@@@ Helpfile alert:  Previous line is messed up; notify \", this.owner.wizard ? \"\" | tostr(this.owner.name, \" (\", this.owner, \") or \"), \"a wizard. @@@\")};","else","newlines = {@newlines, new + old};","endif","endfor","return newlines;"]},{"name":"index","owner":36,"perms":173,"preposition":-1,"code":["\"{\\\"*index*\\\" [, title]}\";","\"This produces a columnated list of topics in this help db, headed by title.\";","$command_utils:suspend_if_needed(0);","title = args[1] ? args[1][1] | tostr(this.name, \" (\", this, \")\");","su = $string_utils;","return {\"\", title, su:from_list($list_utils:map_arg(su, \"space\", su:explode(title), \"-\"), \" \"), @this:columnize(@this:sort_topics(this:find_topics()))};"]},{"name":"initialize","owner":2,"perms":173,"preposition":-1,"code":["pass(@args);","if ($perm_utils:controls(caller_perms(), this))","this.r = 1;","this.f = 0;","endif"]},{"name":"verbdoc","owner":2,"perms":173,"preposition":-1,"code":["\"{\\\"*verbdoc*\\\", \\\"object\\\", \\\"verbname\\\"}  use documentation for this verb\";","set_task_perms(this.owner);","if (!valid(object = $string_utils:match_object(args[1][1], player.location)))","return E_INVARG;","elseif (!(hv = $object_utils:has_verb(object, vname = args[1][2])))","return E_VERBNF;","else","return $code_utils:verb_documentation(hv[1], vname);","endif"]},{"name":"dump_topic","owner":2,"perms":173,"preposition":-1,"code":["try","text = this.(fulltopic = args[1]);","return {tostr(\";;\", $code_utils:corify_object(this), \".(\", toliteral(fulltopic), \") = $command_utils:read_lines()\"), @$command_utils:dump_lines(text)};","except error (ANY)","return error[1];","endtry"]},{"name":"objectdoc","owner":36,"perms":173,"preposition":-1,"code":["\"{\\\"*objectdoc*\\\", \\\"object\\\"} => text for topic from object:help_msg\";","if (!valid(object = $string_utils:literal_object(args[1][1])))","return E_INVARG;","elseif (!($object_utils:has_verb(object, \"help_msg\") || $object_utils:has_property(object, \"help_msg\")))","return E_VERBNF;","else","return $code_utils:verb_or_property(object, \"help_msg\");","endif"]},{"name":"find_index_topics","owner":36,"perms":173,"preposition":-1,"code":["\":find_index_topic([search])\";","\"Return the list of index topics of this help DB\";","\"(i.e., those which contain an index (list of topics)\";","\"this DB, return it, otherwise return false.\";","\"If search argument is given and true,\";","\"we first remove any cached information concerning index topics.\";","{?search = 0} = args;","if (this.index_cache && (!search))","\"...make sure every topic listed in .index_cache really is an index topic\";","for p in (this.index_cache)","if (!(\"*index*\" in `this.(p) ! ANY => {}'))","search = 1;","endif","endfor","if (!search)","return this.index_cache;","endif","elseif ($generic_help == this)","return {};","endif","itopics = {};","for p in (properties(this))","if ((h = `this.(p) ! ANY') && (\"*index*\" in h))","itopics = {@itopics, p};","endif","endfor","this.index_cache = itopics;","return itopics;"]},{"name":"boot","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return;","endif","player = this;","this:notify(tostr(\"Sorry, but you've been here for \", $string_utils:from_seconds(connected_seconds(this)), \" and someone else wants to be a guest now.  Feel free to come back\", @$login:player_creation_enabled(player) ? {\" or even create your own character if you want...\"} | {\" or type `create' to learn more about how to get a character of your own.\"}));","\"boot_player(this)\";","return;","\"See #0:user_reconnected.\";"]},{"name":"disfunc","owner":2,"perms":173,"preposition":-1,"code":["if ((((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (cp != this)) && (caller != #0))","return E_PERM;","endif","\"Don't let another guest use this one until all this is done. See :defer, Ho_Yan 1/19/94\";","this.free_to_use = 0;","this:log_disconnect();","this:erase_paranoid_data();","try","if (this.location != this.home)","this:room_announce(player.name, \" has disconnected.\");","this:room_announce($string_utils:pronoun_sub($housekeeper.take_away_msg, this, $housekeeper));","move(this, this.home);","this:room_announce($string_utils:pronoun_sub($housekeeper.drop_off_msg, this, $housekeeper));","endif","finally","this:do_reset();","this.free_to_use = 1;","endtry"]},{"name":"defer","owner":2,"perms":173,"preposition":-1,"code":["\"Called by #0:connect_player when this object is about to be used as the next guest character.  Usually returns `this', but if for some reason some other guest character should be used, that player object is returned instead\";","if (!caller_perms().wizard)","\"...caller is not :do_login_command; doesn't matter what we return...\";","return this;","elseif ($login:blacklisted($string_utils:connection_hostname(connection_name(player))))","return #-2;","elseif (!(this in connected_players()))","\"...not logged in, no problemo...\";","return this;","endif","longest = 900;","\"...guests get 15 minutes before they can be dislodged...\";","candidate = #-1;","free = {};","for g in ($object_utils:leaves($guest))","if (!is_player(g))","\"...a toaded guest?...\";","elseif ((!(con = g in connected_players())) && g.free_to_use)","\"...yay; found an unused guest...and their last :disfunc is complete\";","free = {@free, g};","elseif (con && ((t = connected_seconds(g)) > longest))","longest = t;","candidate = g;","endif","endfor","if (free)","candidate = free[random($)];","elseif (valid(candidate))","\"...someone's getting bumped...\";","candidate:boot();","endif","return candidate;"]},{"name":"mail_catch_up","owner":2,"perms":173,"preposition":-1,"code":["return;"]},{"name":"create","owner":36,"perms":89,"preposition":-2,"code":["if ($login:player_creation_enabled(player))","player:tell(\"First @quit, then connect to the MOO again and, rather than doing `connect guest' do `create <name> <password>'\");","else","player:tell($login:registration_string());","endif"]},{"name":"eject","owner":36,"perms":173,"preposition":-1,"code":["return pass(@args);"]},{"name":"log","owner":36,"perms":173,"preposition":-1,"code":["\":log(islogin,time,where) adds an entry to the connection log for this guest.\";","if (caller != this)","return E_PERM;","elseif (length(this.connect_log) < this.max_connect_log)","this.connect_log = {args, @this.connect_log};","else","this.connect_log = {args, @this.connect_log[1..this.max_connect_log - 1]};","endif"]},{"name":"confunc","owner":2,"perms":173,"preposition":-1,"code":["if ((((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (cp != this)) && (caller != #0))","return E_PERM;","else","$guest_log:enter(1, time(), $string_utils:connection_hostname(connection_name(this)));","ret = pass(@args);","this:tell_lines(this:extra_confunc_msg());","return ret;","endif"]},{"name":"log_disconnect","owner":2,"perms":173,"preposition":-1,"code":["if (caller != this)","return E_PERM;","else","cname = `connection_name(this) ! ANY' || this.last_connect_place;","$guest_log:enter(0, time(), $string_utils:connection_hostname(cname));","endif"]},{"name":"@last-c*onnection","owner":2,"perms":29,"preposition":-1,"code":["if (!valid(caller_perms()))","player:tell(\"Sorry, that information is not available.\");","endif"]},{"name":"my_huh","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms() != this)","return E_PERM;","else","return pass(@args);","endif"]},{"name":"@read @peek","owner":36,"perms":89,"preposition":-2,"code":["return pass(@args);"]},{"name":"set_current_folder","owner":36,"perms":173,"preposition":-1,"code":["return pass(@args);","\"only for setting permission\";"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","this.extra_confunc_msg = \"\";","clear_property(this, \"features\");","clear_property(this, \"rooms\");","endif"]},{"name":"set_name set_aliases","owner":2,"perms":173,"preposition":-1,"code":["\"disallow guests from setting aliases on themselves\";","if ($perm_utils:controls(caller_perms(), this))","return pass(@args);","else","return E_PERM;","endif"]},{"name":"extra_confunc_msg","owner":2,"perms":173,"preposition":-1,"code":["return $string_utils:pronoun_sub(this.(verb));"]},{"name":"do_reset","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return E_PERM;","else","flush_input(this, 0);","for x in ({\"paranoid\", \"lines\", \"responsible\", \"linelen\", \"linebuffer\", \"brief\", \"gaglist\", \"rooms\", \"pagelen\", \"current_message\", \"current_folder\", \"messages\", \"messages_going\", \"request\", \"mail_options\", \"edit_options\", \"home\", \"spurned_objects\", \"web_info\"})","if ($object_utils:has_property(parent(this), x))","clear_property(this, x);","endif","endfor","this:set_description(this.default_description);","this:set_gender(this.default_gender);","for x in (this.contents)","this:eject(x);","endfor","for x in (this.features)","if (!(x in $guest.features))","this:remove_feature(x);","endif","endfor","for x in ($guest.features)","if (!(x in this.features))","this:add_feature(x);","endif","endfor","for x in ($object_utils:descendants($generic_editor))","if (loc = this in x.active)","x:kill_session(loc);","endif","endfor","endif"]},{"name":"@request","owner":2,"perms":89,"preposition":-2,"code":["\"Copied from Generic Guest (#5678):@request by Froxx (#49853) Mon Apr  4 10:49:26 1994 PDT\";","\"Usage:  @request <player-name> for <email-address>\";","if (player != this)","return player:tell(E_PERM);","endif","if (this.request)","return player:tell(\"Sorry, you appear to have already requested a character.\");","endif","name = dobjstr;","if ((prepstr != \"for\") || ((!dobjstr) || index(address = iobjstr, \" \")))","return player:notify_lines($code_utils:verb_usage());","endif","if ($login:request_character(player, name, address))","this.request = 1;","endif"]},{"name":"connection_name_hash","owner":2,"perms":173,"preposition":-1,"code":["\"Compute an encrypted hash of the guest's (last) connection, using 'crypt'. Basically, you can't tell where the guest came from, but it is unlikely that two guests will have the same hash\";","\"You can use guest:connection_name_hash(seed) as a string to identify whether two guests are from the same place.\";","hash = toint(caller_perms());","host = $string_utils:connection_hostname(this.last_connect_place);","for i in [1..length(host)]","hash = (hash * 14) + index($string_utils.ascii, host[i]);","endfor","return crypt(tostr(hash), @args);"]},{"name":"description","owner":36,"perms":173,"preposition":-1,"code":["return ((this.description + \" There are \") + tostr(this.entries)) + \" words in the online dictionary.\";"]},{"name":"valid","owner":36,"perms":173,"preposition":-1,"code":["return (this:find_exact(args[1]) != $failed_match) || (args[1] in player.dict);"]},{"name":"get_input","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","source = args[1];","data = {};","ref = $code_utils:parse_propref(source);","if (ref)","\"User entered a prop. Deal with it.\";","{thing, prop} = ref;","thing = $string_utils:match_object(thing, player.location);","if (!valid(thing))","player:tell(\"No such object: \", ref[1]);","data = $failed_match;","elseif ((!prop) || (`thing.(tostr(prop)) ! ANY' == E_PROPNF))","player:tell(\"There is no such property `\", prop, \"' on object \", thing, \".\");","data = $failed_match;","else","data = `thing.(tostr(prop)) ! ANY';","if (typeof(data) == STR)","data = {data};","endif","$command_utils:suspend_if_needed(3);","if (typeof(data) == ERR)","player:tell(\"Error: \", tostr(data));","data = $failed_match;","elseif (typeof(data) != LIST)","player:tell(\"Spellchecker needs a string or list as input.\");","data = $failed_match;","endif","endif","else","ref = $code_utils:parse_verbref(source);","if (ref)","\"User entered a verb. Deal with it.\";","{thing, verb} = ref;","thing = $string_utils:match_object(thing, player.location);","if (!valid(thing))","player:tell(\"No such object: \", ref[1]);","data = $failed_match;","elseif (`verb_info(thing, verb) ! ANY' == E_VERBNF)","player:tell(\"There is no such verb `\", verb, \"' on object \", thing, \".\");","data = $failed_match;","else","data = `verb_code(thing, verb) ! ANY => {}';","for i in [1..length(data)]","if (!index(data[i], \"\\\"\"))","data[i] = \"\";","else","data[i] = data[i][index(data[i], \"\\\"\") + 1..$];","data[i] = data[i][1..rindex(data[i], \"\\\"\") - 1];","foo = \"\";","while (index(data[i], \"\\\"\"))","foo = foo + data[i][1..index(data[i], \"\\\"\") - 1];","foo = foo + \" \";","data[i] = data[i][index(data[i], \"\\\"\") + 1..$];","data[i] = data[i][index(data[i], \"\\\"\") + 1..$];","endwhile","if (foo == \"\")","foo = data[i];","else","foo = foo + data[i];","endif","data[i] = $string_utils:trim(foo);","endif","endfor","endif","else","\"User entered word/phrase on command line.\";","data = {argstr};","endif","endif","for i in [1..length(data)]","$command_utils:suspend_if_needed(1);","if (typeof(data[i]) != STR)","data[i] = \"\";","endif","data[i] = $string_utils:strip_chars(data[i], \"!@#$%^&*()_+1234567890={}[]`<>?:;,./|\\\"~'\");","endfor","return data;"]},{"name":"guess_words","owner":36,"perms":173,"preposition":-1,"code":["nastyword = args[1];","guesses = {};","\"Transpose adjacent characters\";","nastyword = nastyword + \" \";","for i in [1..length(nastyword) - 1]","foo = ((nastyword[1..i - 1] + nastyword[i + 1]) + nastyword[i]) + nastyword[i + 2..$];","foo = $string_utils:trim(foo);","if (this:valid(foo))","guesses = listappend(guesses, foo);","endif","if ((ticks_left() < 500) || (seconds_left() < 2))","suspend(0);","endif","endfor","nastyword = $string_utils:trim(nastyword);","\"Erase each character - check for an extra typoed character\";","for i in [1..length(nastyword)]","foo = nastyword[1..i - 1] + nastyword[i + 1..$];","if (this:valid(foo))","guesses = listappend(guesses, foo);","endif","if ((ticks_left() < 500) || (seconds_left() < 2))","suspend(0);","endif","endfor","\"Alter one character\";","for i in [1..length(nastyword)]","for ii in ({\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"'\", \"-\"})","foo = (nastyword[1..i - 1] + ii) + nastyword[i + 1..$];","if (this:valid(foo))","guesses = listappend(guesses, foo);","endif","endfor","if ((ticks_left() < 500) || (seconds_left() < 2))","suspend(0);","endif","endfor","\"insert one character\";","for i in [1..length(nastyword)]","for ii in ({\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"'\", \"-\"})","foo = (nastyword[1..i - 1] + ii) + nastyword[i..$];","if (this:valid(foo))","guesses = listappend(guesses, foo);","endif","endfor","if ((ticks_left() < 500) || (seconds_left() < 2))","suspend(0);","endif","endfor","\"Get some close matches from the database verbs themselves\";","if ((foo = this:find_all(nastyword)) != ERR)","if ((foo != $failed_match) && (foo != $ambiguous_match))","if (length(foo) < 6)","for i in (foo)","guesses = listappend(guesses, i);","endfor","endif","endif","endif","\"Clean up and go home\";","guesses = $list_utils:remove_duplicates(guesses);","guesses = $list_utils:sort(guesses);","return guesses;"]},{"name":"find_exact","owner":36,"perms":173,"preposition":-1,"code":["if ((ticks_left() < 1000) || (seconds_left() < 3))","suspend(0);","endif","return pass(@args);"]},{"name":"sort","owner":36,"perms":173,"preposition":-1,"code":["\"sort({x1,x3,x2},{1,3,2}) => {x1,x2,x3}\";","lst = args[1];","unsorted_keys = (use_sorted_lst = length(args) >= 2) ? args[2] | lst;","sorted_lst = sorted_keys = {};","for e in (unsorted_keys)","l = $list_utils:find_insert(sorted_keys, e);","sorted_keys = listinsert(sorted_keys, e, l);","if (use_sorted_lst)","sorted_lst = listinsert(sorted_lst, lst[length(sorted_keys)], l);","endif","if ((ticks_left() < 500) || (seconds_left() < 2))","suspend(0);","endif","endfor","return sorted_lst || sorted_keys;"]},{"name":"_every_key","owner":36,"perms":173,"preposition":-1,"code":["info = this.(\" \" + args[1]);","prefix = args[1] + info[1];","r = info[3];","for i in [1..length(branches = info[2])]","for new in (this:_every_key(prefix + branches[i]))","r = setadd(r, new);","if ((ticks_left() < 500) || (seconds_left() < 2))","this:_suspend(0);","endif","endfor","endfor","return r;"]},{"name":"_suspend","owner":36,"perms":173,"preposition":-1,"code":["if (caller == this)","suspend(@args);","endif"]},{"name":"insert delete delete2","owner":36,"perms":173,"preposition":-1,"code":["\"N.B.  use :add_word/:remove_word to actually change the contents of this db\";","\":insert(string) -- see $generic_db:insert\";","\":delete(string) -- see $generic_db:delete\";","\":delete2(string) -- see $generic_db:delete2\";","if (caller == this)","$command_utils:suspend_if_needed(0);","return pass(@args);","else","return E_PERM;","endif"]},{"name":"add_word","owner":36,"perms":173,"preposition":-1,"code":["\":add_word(string) -- adds word to the spell database\";","\"Returns true iff this word wasn't already there.\";","cp = caller_perms();","if ((caller == this) || ((cp in this.trusted) || $perm_utils:controls(cp, this)))","result = this:insert(@args);","result || (this.entries = this.entries + 1);","return !result;","else","return E_PERM;","endif"]},{"name":"remove_word","owner":36,"perms":173,"preposition":-1,"code":["\":remove_word(string) -- removes word from the spell database\";","\"Returns true iff word was actually there to be removed.\";","cp = caller_perms();","if ((caller == this) || ((cp in this.trusted) || $perm_utils:controls(cp, this)))","result = this:delete(@args);","result && (this.entries = this.entries - 1);","return result;","else","return E_PERM;","endif"]},{"name":"submit","owner":36,"perms":173,"preposition":-1,"code":["\":submit(word) -- add a word to this.submitted\";","this.submitted = {@this.submitted, args[1]};"]},{"name":"purge_entire_database","owner":36,"perms":173,"preposition":-1,"code":["\"$spell:purge_entire_database - a nasty verb that will zap the whole dictionary.\";","\"usage: eval $spell:purge_entire_database()     \";","if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))","return E_PERM;","endif","if (!player.wizard)","return E_PERM;","endif","player:tell(\"WARNING: This will ERASE all the entries in the online dictionary! IF YOU ARE SURE YOU WISH TO DO THIS, TYPE `PURGE' NOW. Any other input with abort the command.\");","input = $command_utils:read();","if (input != \"purge\")","player:tell(\"ABORTED. Database left as is.\");","else","this:clearall_big(@args);","endif"]},{"name":"random","owner":36,"perms":173,"preposition":-1,"code":["\"returns a random word from the dictionary. maybe useful for games and things\";","\"that need a unique word. accepts no arguments.\";","word = \"\";","while (word == \"\")","x = random(26);","y = random(26);","if (seconds_left() < 2)","suspend(0);","endif","lettera = $string_utils.alphabet[x];","letterb = $string_utils.alphabet[y];","foo = $spell:find_all(lettera + letterb);","if (foo != {})","word = foo[random($)];","endif","endwhile","return word;"]},{"name":"help_msg","owner":36,"perms":13,"preposition":-1,"code":["return this.description;"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return;","endif","$spell.trusted = {};"]},{"name":"clear-submitted","owner":36,"perms":141,"preposition":4,"code":["if (!(player in this.trusted))","player:tell(\"Sorry, you can't do that.\");","return E_PERM;","endif","this.submitted = {};","player:tell(\"$spell.submitted = {};\");"]},{"name":"add remove","owner":36,"perms":173,"preposition":-1,"code":["\"   add(seq,start[,end]) => seq with range added.\";","\"remove(seq,start[,end]) => seq with range removed.\";","\"  both assume start<=end.\";","remove = verb == \"remove\";","seq = args[1];","start = args[2];","s = (start == $minint) ? 1 | $list_utils:find_insert(seq, start - 1);","if (length(args) < 3)","return {@seq[1..s - 1], @((s + remove) % 2) ? {start} | {}};","else","e = $list_utils:find_insert(seq, after = args[3] + 1);","return {@seq[1..s - 1], @((s + remove) % 2) ? {start} | {}, @((e + remove) % 2) ? {after} | {}, @seq[e..$]};","endif"]},{"name":"contains","owner":36,"perms":173,"preposition":-1,"code":["\":contains(seq,elt) => true iff elt is in seq.\";","return ($list_utils:find_insert(@args) + 1) % 2;"]},{"name":"complement","owner":36,"perms":173,"preposition":-1,"code":["\":complement(seq[,lower[,upper]]) => the sequence containing all integers *not* in seq.\";","\"If lower/upper are given, the resulting sequence is restricted to the specified range.\";","\"Bad things happen if seq is not a subset of [lower..upper]\";","{seq, ?lower = $minint, ?upper = $nothing} = args;","if (upper != $nothing)","if (seq[$] >= (upper = upper + 1))","seq[$..$] = {};","else","seq[$ + 1..$] = {upper};","endif","endif","if (seq && (seq[1] <= lower))","return listdelete(seq, 1);","else","return {lower, @seq};","endif"]},{"name":"union","owner":36,"perms":173,"preposition":-1,"code":["\":union(seq1,seq2,...)        => union of all sequences...\";","if ({} in args)","args = $list_utils:setremove_all(args, {});","endif","if (length(args) <= 1)","return args ? args[1] | {};","endif","return this:_union(@args);"]},{"name":"tostr","owner":36,"perms":173,"preposition":-1,"code":["\"tostr(seq [,delimiter]) -- turns a sequence into a string, delimiting ranges with delimiter, defaulting to .. (e.g. 5..7)\";","{seq, ?separator = \"..\"} = args;","if (!seq)","return \"empty\";","endif","e = tostr((seq[1] == $minint) ? \"\" | seq[1]);","len = length(seq);","for i in [2..len]","e = e + ((i % 2) ? tostr(\", \", seq[i]) | ((seq[i] == (seq[i - 1] + 1)) ? \"\" | tostr(separator, seq[i] - 1)));","endfor","return e + ((len % 2) ? separator | \"\");"]},{"name":"for","owner":2,"perms":173,"preposition":-1,"code":["\":for([n,]seq,obj,verb,@args) => for s in (seq) obj:verb(s,@args); endfor\";","set_task_perms(caller_perms());","if (typeof(n = args[1]) == INT)","args = listdelete(args, 1);","else","n = 1;","endif","{seq, object, vname, @args} = args;","if (seq[1] == $minint)","return E_RANGE;","endif","for r in [1..length(seq) / 2]","for i in [seq[(2 * r) - 1]..seq[2 * r] - 1]","if (typeof(object:(vname)(@listinsert(args, i, n))) == ERR)","return;","endif","endfor","endfor","if (length(seq) % 2)","i = seq[$];","while (1)","if (typeof(object:(vname)(@listinsert(args, i, n))) == ERR)","return;","endif","i = i + 1;","endwhile","endif"]},{"name":"extract","owner":36,"perms":173,"preposition":-1,"code":["\"extract(seq,array) => list of elements of array with indices in seq.\";","{seq, array} = args;","if (alen = length(array))","e = $list_utils:find_insert(seq, 1);","s = $list_utils:find_insert(seq, alen);","seq = {@(e % 2) ? {} | {1}, @seq[e..s - 1], @(s % 2) ? {} | {alen + 1}};","ret = {};","for i in [1..length(seq) / 2]","$command_utils:suspend_if_needed(0);","ret = {@ret, @array[seq[(2 * i) - 1]..seq[2 * i] - 1]};","endfor","return ret;","else","return {};","endif"]},{"name":"tolist","owner":36,"perms":173,"preposition":-1,"code":["seq = args[1];","if (!seq)","return {};","else","if (length(seq) % 2)","seq = {@seq, $minint};","endif","l = {};","for i in [1..length(seq) / 2]","for j in [seq[(2 * i) - 1]..seq[2 * i] - 1]","l = {@l, j};","endfor","endfor","return l;","endif"]},{"name":"from_list","owner":36,"perms":173,"preposition":-1,"code":["\":fromlist(list) => corresponding sequence.\";","return this:from_sorted_list($list_utils:sort(args[1]));"]},{"name":"from_sorted_list","owner":36,"perms":173,"preposition":-1,"code":["\":from_sorted_list(sorted_list) => corresponding sequence.\";","if (!(lst = args[1]))","return {};","else","seq = {i = lst[1]};","next = i + 1;","for i in (listdelete(lst, 1))","if (i != next)","seq = {@seq, next, i};","endif","next = i + 1;","endfor","return (next == $minint) ? seq | {@seq, next};","endif"]},{"name":"first","owner":36,"perms":173,"preposition":-1,"code":["return (seq = args[1]) ? seq[1] | E_NONE;"]},{"name":"last","owner":36,"perms":173,"preposition":-1,"code":["return (seq = args[1]) ? (length(seq) % 2) ? $minint - 1 | (seq[$] - 1) | E_NONE;"]},{"name":"size","owner":36,"perms":173,"preposition":-1,"code":["\":size(seq) => number of elements in seq\";","\"  for sequences consisting of more than half of the 4294967298 available integers, this returns a negative number, which can either be interpreted as (cardinality - 4294967298) or -(size of complement sequence)\";","n = 0;","for i in (seq = args[1])","n = i - n;","endfor","return (length(seq) % 2) ? $minint - n | n;"]},{"name":"from_string","owner":36,"perms":173,"preposition":-1,"code":["\":from_string(string) => corresponding sequence or E_INVARG\";","\"  string should be a comma separated list of numbers and\";","\"  number..number ranges\";","su = $string_utils;","if (!(words = su:explode(su:strip_chars(args[1], \" \"), \",\")))","return {};","endif","parts = {};","for word in (words)","to = index(word, \"..\");","if ((!to) && su:is_numeric(word))","part = {toint(word), toint(word) + 1};","elseif (to)","if (to == 1)","start = $minint;","elseif (su:is_numeric(start = word[1..to - 1]))","start = toint(start);","else","return E_INVARG;","endif","end = word[to + 2..length(word)];","if (!end)","part = {start};","elseif (!su:is_numeric(end))","return E_INVARG;","elseif ((end = toint(end)) >= start)","part = {start, end + 1};","else","part = {};","endif","else","return E_INVARG;","endif","parts = {@parts, part};","endfor","return this:union(@parts);"]},{"name":"firstn","owner":36,"perms":173,"preposition":-1,"code":["\":firstn(seq,n) => first n elements of seq as a sequence.\";","if ((n = args[2]) <= 0)","return {};","endif","l = length(seq = args[1]);","s = 1;","while (s <= l)","n = n + seq[s];","if ((s >= l) || (n <= seq[s + 1]))","return {@seq[1..s], n};","endif","n = n - seq[s + 1];","s = s + 2;","endwhile","return seq;"]},{"name":"lastn","owner":36,"perms":173,"preposition":-1,"code":["\":lastn(seq,n) => last n elements of seq as a sequence.\";","n = args[2];","if ((l = length(seq = args[1])) % 2)","return {$minint - n};","else","s = l;","while (s)","n = seq[s] - n;","if (n >= seq[s - 1])","return {n, @seq[s..l]};","endif","n = seq[s - 1] - n;","s = s - 2;","endwhile","return seq;","endif"]},{"name":"range","owner":36,"perms":173,"preposition":-1,"code":["\":range(start,end) => sequence corresponding to [start..end] range\";","return ((start = args[1]) <= (end = args[2])) ? {start, end + 1} | {};"]},{"name":"expand","owner":36,"perms":173,"preposition":-1,"code":["\":expand(seq,eseq[,include=0])\";","\"eseq is assumed to be a finite sequence consisting of intervals \";","\"[f1..a1-1],[f2..a2-1],...  We map each element i of seq to\";","\"  i               if               i < f1\";","\"  i+(a1-f1)       if         f1 <= i < f2-(a1-f1)\";","\"  i+(a1-f1+a2-f2) if f2-(a1-f1) <= i < f3-(a2-f2)-(a1-f1)\";","\"  ...\";","\"returning the resulting sequence if include=0,\";","\"returning the resulting sequence unioned with eseq if include=1;\";","{old, insert, ?include = 0} = args;","exclude = !include;","if (!insert)","return old;","elseif ((length(insert) % 2) || (insert[1] == $minint))","return E_TYPE;","endif","olast = length(old);","ilast = length(insert);","\"... find first o for which old[o] >= insert[1]...\";","ifirst = insert[i = 1];","o = $list_utils:find_insert(old, ifirst - 1);","if (o > olast)","return ((olast % 2) == exclude) ? {@old, @insert} | old;","endif","new = old[1..o - 1];","oe = old[o];","diff = 0;","while (1)","\"INVARIANT: oe == old[o]+diff\";","\"INVARIANT: oe >= ifirst == insert[i]\";","\"... at this point we need to dispose of the interval ifirst..insert[i+1]\";","if (oe == ifirst)","new = {@new, insert[i + ((o % 2) == exclude)]};","if (o >= olast)","return ((olast % 2) == exclude) ? {@new, @insert[i + 2..ilast]} | new;","endif","o = o + 1;","else","if ((o % 2) != exclude)","new = {@new, @insert[i..i + 1]};","endif","endif","\"... advance i...\";","diff = (diff + insert[i + 1]) - ifirst;","if ((i = i + 2) > ilast)","for oe in (old[o..olast])","new = {@new, oe + diff};","endfor","return new;","endif","ifirst = insert[i];","\"... find next o for which old[o]+diff >= ifirst )...\";","while ((oe = old[o] + diff) < ifirst)","new = {@new, oe};","if (o >= olast)","return ((olast % 2) == exclude) ? {@new, @insert[i..ilast]} | new;","endif","o = o + 1;","endwhile","endwhile"]},{"name":"contract","owner":36,"perms":173,"preposition":-1,"code":["\":contract(seq,cseq)\";","\"cseq is assumed to be a finite sequence consisting of intervals \";","\"[f1..a1-1],[f2..a2-1],...  From seq, we remove any elements that \";","\"are in those ranges and map each remaining element i to\";","\"  i               if       i < f1\";","\"  i-(a1-f1)       if a1 <= i < f2\";","\"  i-(a1-f1+a2-f2) if a2 <= i < f3 ...\";","\"returning the resulting sequence.\";","\"\";","\"For any finite sequence cseq, the following always holds:\";","\"  :contract(:expand(seq,cseq,include),cseq)==seq\";","{old, removed} = args;","if (!removed)","return old;","elseif (((rlen = length(removed)) % 2) || (removed[1] == $minint))","return E_TYPE;","endif","rfirst = removed[1];","ofirst = $list_utils:find_insert(old, rfirst - 1);","new = old[1..ofirst - 1];","diff = 0;","rafter = removed[r = 2];","for o in [ofirst..olast = length(old)]","while (old[o] > rafter)","if ((o - ofirst) % 2)","new = {@new, rfirst - diff};","ofirst = o;","endif","diff = (diff + rafter) - rfirst;","if (r >= rlen)","for oe in (old[o..olast])","new = {@new, oe - diff};","endfor","return new;","endif","rfirst = removed[r + 1];","rafter = removed[r = r + 2];","endwhile","if (old[o] < rfirst)","new = {@new, old[o] - diff};","ofirst = o + 1;","endif","endfor","return ((olast - ofirst) % 2) ? new | {@new, rfirst - diff};"]},{"name":"_union","owner":36,"perms":173,"preposition":-1,"code":["\":_union(seq,seq,...)\";","\"assumes all seqs are nonempty and that there are at least 2\";","nargs = length(args);","\"args  -- list of sequences.\";","\"nexts -- nexts[i] is the index in args[i] of the start of the first\";","\"         interval not yet incorporated in the return sequence.\";","\"heap  -- a binary tree of indices into args/nexts represented as a list where\";","\"         heap[1] is the root and the left and right children of heap[i]\";","\"         are heap[2*i] and heap[2*i+1] respectively.  \";","\"         Parent index h is <= both children in the sense of args[h][nexts[h]].\";","\"         heap[i]==0 indicates a nonexistant child; we fill out the array with\";","\"         zeros so that length(heap)>2*length(args).\";","\"...initialize heap...\";","heap = {0, 0, 0, 0, 0};","nexts = {1, 1};","hlen2 = 2;","while (hlen2 < nargs)","nexts = {@nexts, @nexts};","heap = {@heap, @heap};","hlen2 = hlen2 * 2;","endwhile","for n in [-nargs..-1]","s1 = args[i = -n][1];","while ((hleft = heap[2 * i]) && (s1 > (m = min(la = args[hleft][1], (hright = heap[(2 * i) + 1]) ? args[hright][1] | $maxint))))","if (m == la)","heap[i] = hleft;","i = 2 * i;","else","heap[i] = hright;","i = (2 * i) + 1;","endif","endwhile","heap[i] = -n;","endfor","\"...\";","\"...find first interval...\";","h = heap[1];","rseq = {args[h][1]};","if (length(args[h]) < 2)","return rseq;","endif","current_end = args[h][2];","nexts[h] = 3;","\"...\";","while (1)","if (length(args[h]) >= nexts[h])","\"...this sequence has some more intervals in it...\";","else","\"...no more intevals left in this sequence, grab another...\";","h = heap[1] = heap[nargs];","heap[nargs] = 0;","if ((nargs = nargs - 1) > 1)","elseif (args[h][nexts[h]] > current_end)","return {@rseq, current_end, @args[h][nexts[h]..$]};","elseif ((i = $list_utils:find_insert(args[h], current_end)) % 2)","return {@rseq, current_end, @args[h][i..$]};","else","return {@rseq, @args[h][i..$]};","endif","endif","\"...\";","\"...sink the top sequence...\";","i = 1;","first = args[h][nexts[h]];","while ((hleft = heap[2 * i]) && (first > (m = min(la = args[hleft][nexts[hleft]], (hright = heap[(2 * i) + 1]) ? args[hright][nexts[hright]] | $maxint))))","if (m == la)","heap[i] = hleft;","i = 2 * i;","else","heap[i] = hright;","i = (2 * i) + 1;","endif","endwhile","heap[i] = h;","\"...\";","\"...check new top sequence ...\";","if (args[h = heap[1]][nexts[h]] > current_end)","\"...hey, a new interval! ...\";","rseq = {@rseq, current_end, args[h][nexts[h]]};","if (length(args[h]) <= nexts[h])","return rseq;","endif","current_end = args[h][nexts[h] + 1];","nexts[h] = nexts[h] + 2;","else","\"...first interval overlaps with current one ...\";","i = $list_utils:find_insert(args[h], current_end);","if (i % 2)","nexts[h] = i;","elseif (i > length(args[h]))","return rseq;","else","current_end = args[h][i];","nexts[h] = i + 1;","endif","endif","endwhile"]},{"name":"intersection","owner":36,"perms":173,"preposition":-1,"code":["\":intersection(seq1,seq2,...) => intersection of all sequences...\";","if ((U = {$minint}) in args)","args = $list_utils:setremove_all(args, U);","endif","if (length(args) <= 1)","return args ? args[1] | U;","endif","return this:complement(this:_union(@$list_utils:map_arg(this, \"complement\", args)));"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","pass();","delete_verb(this, \"is_readable_by\");","delete_verb(this, \"is_usable_by\");","delete_verb(this, \"mail_notify\");","\"...remove references to ARB...\";","this:rm_message_seq({1, 1 + this:length_all_msgs()});","this:expunge_rmm();","this.mail_forward = {};","this.mail_notify = {player};","player.current_message = {@player.current_message, {this, 0, 0}};","for p in ({\"moderator_forward\", \"moderator_notify\", \"writers\", \"readers\", \"expire_period\", \"last_used_time\"})","this.(p) = $mail_recipient.(p);","endfor","this.moderated = 1;","else","return E_PERM;","endif"]},{"name":"find_recips","owner":2,"perms":173,"preposition":-1,"code":["\"Given a To: line from a mail message, extract the people.  I couldn't find this in the mail system...  It's undoubtedly there, but not clear cut.\";","line = args[1];","recips = {};","while (line && (start = index(line, \"(#\")))","line = line[start..$];","finish = index(line, \")\");","recips = {@recips, toobj(line[2..finish - 1])};","line = line[finish..$];","endwhile","return recips;"]},{"name":"verb_sub","owner":36,"perms":173,"preposition":-1,"code":["\"$you:verb_sub(STR verbspec) -> returns verbspec conjugated for singular use as if `you' were saying it.\";","return $gender_utils:get_conj(args[1], this);","x = args[1];","len = length(x);","if ((len > 3) && (rindex(x, \"n't\") == (len - 3)))","return this:verb_sub(x[1..len - 3]) + \"n't\";","endif","for y in (this.conjugations)","if (x == y[1])","return y[2];","endif","endfor","for y in ({{\"ches\", \"ch\"}, {\"ies\", \"y\"}, {\"sses\", \"ss\"}, {\"shes\", \"sh\"}, {\"s\", \"\"}})","if ((len > length(y[1])) && (rindex(x, y[1]) == ((len - length(y[1])) + 1)))","return x[1..len - length(y[1])] + y[2];","endif","endfor","return x;"]},{"name":"say_action","owner":36,"perms":165,"preposition":-1,"code":["\"$you:say_action(message [,who [,thing, [,where [, excluding-whom]]]])\";","\"announce 'message' with pronoun substitution as if it were just \";","\"  where:announce_all_but(excluding-whom, \";","\"    $string_utils:pronoun_sub(message, who, thing, where));\";","\"except that who (player), dobj, and iobj get modified messages, with the appropriate use of 'you' instead of their name, and except that `excluding-whom' isn't really a valid variable name.\";","\"who       default player\";","\"thing     default object that called this verb\";","\"where     default who.location\";","\"excluding default {}\";","{msg, ?who = player, ?thing = caller, ?where = who.location, ?excluding = {}} = args;","you = this;","if (typeof(msg) == LIST)","tell = \"\";","for x in (msg)","tell = tell + ((typeof(x) == STR) ? x | x[random(length(x))]);","endfor","else","tell = msg;","endif","if (!(who in excluding))","who:tell($string_utils:pronoun_sub(this:fixpos(tell, \"%n\"), you, thing, where));","endif","if ($object_utils:has_callable_verb(where, \"announce_all_but\"))","where:announce_all_but({dobj, who, iobj, @excluding}, $string_utils:pronoun_sub(tell, who, thing, where));","endif","if ((valid(dobj) && (dobj != who)) && (!(dobj in excluding)))","x = dobj;","dobj = you;","x:tell($string_utils:pronoun_sub(this:fixpos(tell, \"%d\"), who, thing, where));","dobj = x;","endif","if (valid(iobj) && (!(iobj in {who, dobj, @excluding})))","x = iobj;","iobj = you;","x:tell($string_utils:pronoun_sub(this:fixpos(tell, \"%i\"), who, thing, where));","iobj = x;","endif"]},{"name":"fixpos","owner":36,"perms":173,"preposition":-1,"code":["\"This is horribly dwimmy.  E.g. %x's gets turned into your, %X's gets turned into Your, and %X'S gets turned into YOUR. --Nosredna\";","upper = $string_utils:uppercase(args[2]);","allupper = upper + \"'S\";","upper = upper + \"'s\";","lower = $string_utils:lowercase(args[2]) + \"'s\";","return strsub(strsub(strsub(args[1], lower, \"your\", 1), upper, \"Your\", 1), allupper, \"YOUR\", 1);"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","pass();","this.mail_forward = {#2};","endif"]},{"name":"find find_key","owner":36,"perms":173,"preposition":-1,"code":["\"find(string[,n]) => datum corresponding to string with the search starting at node \\\" \\\"+string[1..n], n defaults to 0 (root node), $ambiguous_match or $failed_match\";","\"find_key(string[,n]) is like :find but returns the full string key rather than the associated datum.  Note that if several string keys present in the db share a common prefix, :find_key(prefix) will return $ambiguous_match, but if there is a unique datum associated with all of these strings :find(prefix) will return it rather than $ambiguous_match.\";","\"Assumes n<=length(string)\";","{search, ?sofar = 0} = args;","rest = search;","prefix = search[1..sofar];","rest[1..sofar] = \"\";","info = this.(\" \" + prefix);","data = (verb == \"find\") ? this.data | 3;","if (i = search in info[3])","\"...exact match for one of the strings in this node...\";","return info[data][i];","elseif (index(info[1], rest) == 1)","\"...ambiguous iff there's more than one object represented in this node..\";","return this:_only(prefix, data);","elseif (index(rest, info[1]) != 1)","\"...search string doesn't agree with common portion...\";","return $failed_match;","elseif (index(info[2], search[nsofar = (sofar + length(info[1])) + 1]))","\"...search string follows one of continuations leading to other nodes...\";","return this:(verb)(search, nsofar);","else","\"...search string may partially match one of the strings in this node...\";","for i in [1..length(exacts = info[3])]","if (index(exacts[i], search) == 1)","return info[data][i];","endif","endfor","return $failed_match;","endif"]},{"name":"find_exact","owner":36,"perms":173,"preposition":-1,"code":["{search, ?sofar = 0} = args;","rest = search;","prefix = search[1..sofar];","rest[1..sofar] = \"\";","info = this.(\" \" + prefix);","if (i = search in info[3])","return info[this.data][i];","elseif ((length(rest) <= (common = length(info[1]))) || (rest[1..common] != info[1]))","return $failed_match;","elseif (index(info[2], search[(sofar + common) + 1]))","return this:find_exact(search, (sofar + common) + 1);","else","return $failed_match;","endif"]},{"name":"find_all find_all_keys","owner":36,"perms":173,"preposition":-1,"code":["\":find_all(string [,n=0])\";","\"assumes n <= length(string)\";","{search, ?sofar = 0} = args;","rest = search;","prefix = search[1..sofar];","rest[1..sofar] = \"\";","info = this.(\" \" + prefix);","data = (verb == \"find_all\") ? this.data | 3;","if (index(info[1], rest) == 1)","\"...return entire subtree.\";","return this:((data == 3) ? \"_every_key\" | \"_every\")(prefix);","elseif (index(rest, info[1]) != 1)","\"...common portion doesn't agree.\";","return {};","elseif (index(info[2], rest[1 + (common = length(info[1]))]))","\"...matching strings are in a subnode.\";","return this:(verb)(search, (sofar + common) + 1);","else","\"...matching string is in info[3].  length(rest) > common,\";","\"...so there will be at most one matching string.\";","for i in [1..length(info[3])]","if (index(info[3][i], search) == 1)","return {info[data][i]};","endif","endfor","return {};","endif"]},{"name":"_only","owner":36,"perms":173,"preposition":-1,"code":["\":_only(prefix,data) => if all strings in this node have the same datum, return it, otherwise, return $ambiguous_match.\";","if (caller != this)","raise(E_PERM);","endif","{prefix, data} = args;","info = this.(\" \" + prefix);","if (data == 3)","\"... life is much simpler if there's no separate datum.\";","\"... if there's more than one string here, we barf.\";","if (info[2] || (length(info[3]) > 1))","return $ambiguous_match;","elseif (info[3])","return info[3][1];","else","\"..this can only happen with the root node of an empty db.\";","return $failed_match;","endif","elseif (info[2])","what = this:_only(tostr(prefix, info[1], info[2][1]), data);","if (what == $ambiguous_match)","return what;","endif","elseif (info[data])","what = info[data][1];","info[data] = listdelete(info[data], 1);","else","\"..this can only happen with the root node of an empty db.\";","return $failed_match;","endif","for x in (info[data])","if (what != x)","return $ambiguous_match;","endif","endfor","for i in [2..length(info[2])]","if (what != this:_only(tostr(prefix, info[1], info[2][i]), data))","return $ambiguous_match;","endif","endfor","return what;"]},{"name":"_every","owner":36,"perms":173,"preposition":-1,"code":["if (caller != this)","raise(E_PERM);","endif","info = this.(\" \" + args[1]);","prefix = args[1] + info[1];","r = $list_utils:remove_duplicates(info[4]);","for i in [1..length(branches = info[2])]","for new in (this:_every(prefix + branches[i]))","r = setadd(r, new);","endfor","endfor","return r;"]},{"name":"_every_key","owner":36,"perms":173,"preposition":-1,"code":["if (caller != this)","raise(E_PERM);","endif","info = this.(\" \" + args[1]);","prefix = args[1] + info[1];","r = info[3];","for i in [1..length(branches = info[2])]","for new in (this:_every_key(prefix + branches[i]))","r = setadd(r, new);","$command_utils:suspend_if_needed(0);","endfor","$command_utils:suspend_if_needed(0);","endfor","return r;"]},{"name":"insert","owner":36,"perms":173,"preposition":-1,"code":["\":insert([n,]string,datum) -- inserts <string,datum> correspondence into tree starting at node \\\" \\\"+string[1..n], n defaulting to 0 (root node).\";","\"Assumes length(string) >= n\";","\"Returns {old_datum} (or 1) if there was a <string,old_datum> correspondence there before, otherwise returns 0\";","if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))","return E_PERM;","endif","has_datum = this.data > 3;","if (typeof(sofar = args[1]) == INT)","search = args[2];","datum = has_datum ? args[3] | 0;","else","search = sofar;","sofar = 0;","datum = has_datum ? args[2] | 0;","endif","prefix = search[1..sofar];","info = this.(\" \" + prefix);","if (i = search in info[3])","\"... exact match ...\";","if (has_datum)","previous = {info[this.data][i]};","info[this.data][i] = datum;","this:set_node(prefix, @info);","return previous;","else","return 1;","endif","endif","rest = search;","rest[1..sofar] = \"\";","if (index(rest, info[1]) != 1)","\"... find where new string disagrees with common portion...\";","c = $string_utils:common(rest, info[1]) + 1;","\"... make a new node with a shorter common portion....\";","this:make_node(prefix + info[1][1..c], @listset(info, info[1][c + 1..$], 1));","this:set_node(prefix, info[1][1..c - 1], info[1][c], {search}, @has_datum ? {{datum}} | {});","return 0;","elseif (rest == info[1])","\".. new string == common portion, insert...\";","info[3] = {@info[3], search};","if (has_datum)","info[this.data] = {@info[this.data], datum};","endif","this:set_node(prefix, @info);","return 0;","elseif (index(info[2], search[nsofar = (sofar + length(info[1])) + 1]))","\"... new string matches pre-existing continuation. insert in subnode....\";","return this:insert(nsofar, search, datum);","else","\"... new string may blow away one of the exact matches (i.e., matches one of them up to the first character beyond the common portion) in which case we need to create a new subnode....\";","s = search[1..nsofar];","for m in (info[3])","if (index(m, s) == 1)","i = m in info[3];","\"... we know m != search ...\";","\"... string m has been blown away.  create new node ...\";","cbegin = cafter = length(s) + 1;","cend = $string_utils:common(search, m);","this:make_node(s, m[cbegin..cend], \"\", {search, m}, @has_datum ? {{datum, info[this.data][i]}} | {});","this:set_node(prefix, info[1], info[2] + s[nsofar], listdelete(info[3], i), @has_datum ? {listdelete(info[this.data], i)} | {});","return 0;","endif","endfor","\"... new string hasn't blown away any of the exact matches, insert it as a new exact match...\";","info[3] = {search, @info[3]};","if (has_datum)","info[this.data] = {datum, @info[this.data]};","endif","this:set_node(prefix, @info);","return 0;","endif"]},{"name":"delete","owner":36,"perms":173,"preposition":-1,"code":["\":delete(string[,n]) deletes any <string,something> pair from the tree starting at node \\\" \\\"+string[1..n], n defaulting to 0 (root node)\";","\"Returns {something} if such a pair existed, otherwise returns 0\";","\"If that node is not the root node and ends up containing only one string and no subnodes, we kill it and return {something,string2,something2} where <string2,something2> is the remaining pair.\";","if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))","return E_PERM;","endif","{search, ?sofar = 0} = args;","rest = search;","prefix = search[1..sofar];","rest[1..sofar] = \"\";","info = this.(\" \" + prefix);","if (i = search in info[3])","previous = {info[this.data][i]};","info[3] = listdelete(info[3], i);","if (this.data > 3)","info[this.data] = listdelete(info[this.data], i);","endif","elseif ((rest == info[1]) || ((index(rest, info[1]) != 1) || (!index(info[2], search[d = (sofar + length(info[1])) + 1]))))","\"... hmm string isn't in here...\";","return 0;","elseif ((previous = this:delete(search, d)) && (length(previous) > 1))","i = index(info[2], search[d]);","info[2][i..i] = \"\";","info[3] = {previous[2], @info[3]};","if (this.data > 3)","info[this.data] = {previous[3], @info[this.data]};","endif","previous = previous[1..1];","else","return previous;","endif","if ((!prefix) || ((length(info[3]) + length(info[2])) != 1))","this:set_node(prefix, @info);","return previous;","elseif (info[3])","this:kill_node(prefix);","return {@previous, info[3][1], info[this.data][1]};","else","sub = this.(\" \" + (p = tostr(prefix, info[1], info[2])));","this:kill_node(p);","this:set_node(prefix, @listset(sub, tostr(info[1], info[2], sub[1]), 1));","return previous;","endif"]},{"name":"delete2","owner":36,"perms":173,"preposition":-1,"code":["\":delete2(string,datum[,n]) deletes the pair <string,datum> from the tree starting at node \\\" \\\"+string[1..n], n defaulting to 0 (root node)\";","\"Similar to :delete except that if the entry for that string has a different associated datum, it will not be removed.  \";","\":delete2(string,datum) is equivalent to \";","\" \";","\"  if(this:find_exact(string)==datum) \";","\"    this:delete(string); \";","\"  endif\";","if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))","return E_PERM;","endif","{search, datum, ?sofar = 0} = args;","rest = search;","prefix = search[1..sofar];","rest[1..sofar] = \"\";","info = this.(\" \" + prefix);","if (i = search in info[3])","previous = {info[this.data][i]};","if (previous[1] != datum)","return previous;","endif","info[3] = listdelete(info[3], i);","if (this.data > 3)","info[this.data] = listdelete(info[this.data], i);","endif","elseif ((rest == info[1]) || ((index(rest, info[1]) != 1) || (!index(info[2], search[d = (sofar + length(info[1])) + 1]))))","\"... hmm string isn't in here...\";","return 0;","elseif ((previous = this:delete2(search, datum, d)) && (length(previous) > 1))","i = index(info[2], search[d]);","info[2][i..i] = \"\";","info[3] = {previous[2], @info[3]};","if (this.data > 3)","info[this.data] = {previous[3], @info[this.data]};","endif","previous = previous[1..1];","else","return previous;","endif","if ((!prefix) || ((length(info[3]) + length(info[2])) != 1))","this:set_node(prefix, @info);","return previous;","elseif (info[3])","this:kill_node(prefix);","return {@previous, info[3][1], info[this.data][1]};","else","sub = this.(\" \" + (p = tostr(prefix, info[1], info[2])));","this:kill_node(p);","this:set_node(prefix, @listset(sub, tostr(info[1], info[2], sub[1]), 1));","return previous;","endif"]},{"name":"set_node","owner":36,"perms":173,"preposition":-1,"code":["return (caller != this) ? E_PERM | (this.(\" \" + args[1]) = listdelete(args, 1));"]},{"name":"make_node","owner":2,"perms":173,"preposition":-1,"code":["\"WIZARDLY\";","return (caller != this) ? E_PERM | add_property(this, \" \" + args[1], listdelete(args, 1), {$generic_db.owner, this.node_perms});"]},{"name":"kill_node","owner":2,"perms":173,"preposition":-1,"code":["\"WIZARDLY\";","return (caller != this) ? E_PERM | delete_property(this, \" \" + args[1]);"]},{"name":"clearall","owner":2,"perms":173,"preposition":-1,"code":["\"WIZARDLY\";","if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))","return E_PERM;","endif","if (args && ((d = args[1]) in {3, 4}))","this.data = d;","endif","root = {\"\", \"\", {}, @(this.data > 3) ? {{}} | {}};","\"...since the for loop contains a suspend, we want to keep people\";","\"...from getting at properties which are now garbage but which we\";","\"...haven't had a chance to wipe yet.  Somebody might yet succeed\";","\"...in adding something; thus we have the outer while loop.\";","this:set_node(\"\", 37);","while (this.(\" \") != root)","this:set_node(\"\", @root);","for p in (properties(this))","if ((p[1] == \" \") && (p != \" \"))","delete_property(this, p);","endif","\"...Bleah; db is inconsistent now....\";","\"...At worst someone will add something that references an\";","\"...existing property.  He will deserve to die...\";","$command_utils:suspend_if_needed(0);","endfor","endwhile"]},{"name":"clearall_big","owner":36,"perms":173,"preposition":-1,"code":["if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))","return E_PERM;","endif","this:_kill_subtrees(\"\", 0);","this:clearall(@args);"]},{"name":"_kill_subtrees","owner":36,"perms":173,"preposition":-1,"code":["\":_kill_subtree(node,count)...wipes out all subtrees\";","\"...returns count + number of nodes removed...\";","if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))","return E_PERM;","endif","info = this.(\" \" + (prefix = args[1]));","count = args[2];","if ((ticks_left() < 500) || (seconds_left() < 2))","player:tell(\"...\", count);","suspend(0);","endif","for i in [1..length(info[2])]","count = this:_kill_subtrees(n = tostr(prefix, info[1], info[2][i]), count) + 1;","this:kill_node(n);","endfor","return count;"]},{"name":"depth","owner":36,"perms":173,"preposition":-1,"code":["info = this.(\" \" + (prefix = (args || {\"\"})[1]));","depth = 0;","string = prefix;","if ((ticks_left() < 500) || (seconds_left() < 2))","player:tell(\"...\", prefix);","suspend(0);","endif","for i in [1..length(info[2])]","if ((r = this:depth(tostr(prefix, info[1], info[2][i])))[1] > depth)","depth = r[1];","string = r[2];","endif","endfor","return {depth + 1, string};"]},{"name":"count_entries","owner":36,"perms":173,"preposition":-1,"code":["info = this.(\" \" + (prefix = args[1]));","count = length(info[3]) + args[2];","if ((ticks_left() < 500) || (seconds_left() < 2))","player:tell(\"...\", count);","suspend(0);","endif","for i in [1..length(info[2])]","count = this:count_entries(tostr(prefix, info[1], info[2][i]), count);","endfor","return count;"]},{"name":"count_chars","owner":36,"perms":173,"preposition":-1,"code":["info = this.(\" \" + (prefix = args[1]));","count = args[2];","for s in (info[3])","count = count + length(s);","endfor","if ((ticks_left() < 500) || (seconds_left() < 2))","player:tell(\"...\", count);","suspend(0);","endif","for i in [1..length(info[2])]","count = this:count_chars(tostr(prefix, info[1], info[2][i]), count);","endfor","return count;"]},{"name":"count","owner":36,"perms":153,"preposition":3,"code":["\"count [entries|chars] in <db>\";","\"  reports on the number of distinct string keys or the number of characters\";","\"  in all string keys in the db\";","if (index(\"entries\", dobjstr) == 1)","player:tell(this:count_entries(\"\", 0), \" strings in \", this.name, \"(\", this, \")\");","elseif (index(\"chars\", dobjstr) == 1)","player:tell(this:count_chars(\"\", 0), \" chars in \", this.name, \"(\", this, \")\");","else","player:tell(\"Usage: \", verb, \" entries|chars in <db>\");","endif"]},{"name":"eval","owner":2,"perms":173,"preposition":-1,"code":["\"eval(code)\";","\"Evaluate code with $no_one's permissions (so you won't damage anything).\";","\"If code does not begin with a semicolon, set this = caller (in the code to be evaluated) and return the value of the first `line' of code.  This means that subsequent lines will not be evaluated at all.\";","\"If code begins with a semicolon, set this = caller and let the code decide for itself when to return a value.  This is how to do multi-line evals.\";","exp = args[1];","if (this:bad_eval(exp))","return E_PERM;","endif","set_task_perms(this);","if (exp[1] != \";\")","return eval(tostr(\"this=\", caller, \"; return \", exp, \";\"));","else","return eval(tostr(\"this=\", caller, \";\", exp, \";\"));","endif"]},{"name":"moveto","owner":36,"perms":173,"preposition":-1,"code":["return 0;"]},{"name":"eval_d","owner":2,"perms":173,"preposition":-1,"code":["\":eval_d(code)\";","\"exactly like :eval except that the d flag is unset\";","\"Evaluate code with $no_one's permissions (so you won't damage anything).\";","\"If code does not begin with a semicolon, set this = caller (in the code to be evaluated) and return the value of the first `line' of code.  This means that subsequent lines will not be evaluated at all.\";","\"If code begins with a semicolon, set this = caller and let the code decide for itself when to return a value.  This is how to do multi-line evals.\";","exp = args[1];","if (this:bad_eval(exp))","return E_PERM;","endif","set_task_perms(this);","if (exp[1] != \";\")","return $code_utils:eval_d(tostr(\"this=\", caller, \"; return \", exp, \";\"));","else","return $code_utils:eval_d(tostr(\"this=\", caller, \";\", exp, \";\"));","endif"]},{"name":"call_verb","owner":2,"perms":173,"preposition":-1,"code":["\"call_verb(object, verb name, args)\";","\"Call verb with $no_one's permissions (so you won't damage anything).\";","\"One could do this with $no_one:eval, but ick.\";","set_task_perms(this);","return args[1]:(args[2])(@args[3]);"]},{"name":"bad_eval","owner":2,"perms":173,"preposition":-1,"code":["\":bad_eval(exp)\";","\"  Returns 1 if the `exp' is inappropriate for use by $no_one.  In particular,  if `exp' contains calls to `eval', `fork', `suspend', or `call_function' it is  bad.  Similarly, if `player' is a nonvalid object (or a child of $garbage) the  expression is considered `bad' because it is likely an attempt to anonymously  spoof.\";","\"  At present, the checks for bad builtins are overzealous.  It should check  for delimited uses of the above calls, in case someone has a variable called  `prevalent'.\";","{exp} = args;","if (((index(exp, \"eval\") || index(exp, \"fork\")) || index(exp, \"suspend\")) || index(exp, \"call_function\"))","\"Well, they had one of the evil words in here.  See if it was in a quoted  string or not -- we want to permit player:tell(\\\"Gentlemen use forks.\\\")\";","for bad in ({\"eval\", \"fork\", \"suspend\", \"call_function\"})","tempindex = 1;","while (l = index(exp[tempindex..$], bad, 0))","if ($code_utils:inside_quotes(exp[1..(tempindex + l) - 1]))","tempindex = tempindex + l;","else","\"it's there, bad unquoted string\";","return 1;","endif","endwhile","endfor","endif","if ((!$recycler:valid(player)) && (player >= #0))","return 1;","endif","return 0;"]},{"name":"set_*","owner":36,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return E_PERM;","else","return pass(@args);","endif"]},{"name":"load","owner":36,"perms":173,"preposition":-1,"code":["\":load() -- reloads the player_db with the names of all existing players.\";","\"This routine calls suspend() if it runs out of time.\";","\".frozen is set to 1 while the load is in progress so that other routines are warned and don't try to do any updates.  Sometimes, an update is unavoidable (e.g., player gets recycled) in which case the offending routine should set .frozen to 2, causing the load to start over at the beginning.\";","if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))","return E_PERM;","endif","\"...N.B. clearall suspends, therefore we put the .frozen mark on FIRST...\";","this.frozen = 1;","this:clearall();","for p in (players())","this:suspend_restart(p);","\"... note that if a player is recycled or toaded during the suspension,...\";","\"... it won't be removed from the for loop iteration; thus this test:     \";","if (valid(p) && is_player(p))","if (typeof(po = this:find_exact(p.name)) == ERR)","player:tell(p.name, \":  \", po);","return;","elseif (po != p)","if (valid(po) && is_player(po))","player:tell(\"name `\", p.name, \"' for \", p, \" subsumes alias for \", po.name, \"(\", po, \").\");","endif","this:insert(p.name, p);","endif","for a in (p.aliases)","this:suspend_restart(p);","if (index(a, \" \") || index(a, \"\t\"))","\"don't bother, space or tab\";","elseif (typeof(ao = this:find_exact(a)) == ERR)","player:tell(a, \":  \", ao);","return;","elseif (!(valid(ao) && is_player(ao)))","this:insert(a, p);","elseif (ao != p)","player:tell(\"alias `\", a, \"' for \", p.name, \"(\", p, \") used by \", ao.name, \"(\", ao, \").\");","endif","endfor","endif","endfor","this.frozen = 0;"]},{"name":"check","owner":36,"perms":45,"preposition":-1,"code":["\":check() -- checks for recycled and toaded players that managed not to get expunged from the db.\";","for p in (properties($player_db))","if ((ticks_left() < 500) || (seconds_left() < 2))","player:tell(\"...\", p);","suspend(0);","endif","if (p[1] == \" \")","nlist = this.(p)[3];","olist = this.(p)[4];","for i in [1..length(nlist)]","if (valid(olist[i]) && (is_player(olist[i]) && (nlist[i] in olist[i].aliases)))","else","player:tell(\".\", p[2..$], \" <- \", nlist[i], \" \", olist[i]);","endif","endfor","endif","endfor","player:tell(\"done.\");"]},{"name":"init_for_core","owner":36,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","pass();","this.reserved = {};","this:load();","endif"]},{"name":"available","owner":36,"perms":173,"preposition":-1,"code":["\":available(name,who) => 1 if a name is available for use, or the object id of whoever is currently using it, or 0 if the name is otherwise forbidden.\";","\"If $player_db is not .frozen and :available returns 1, then $player:set_name will succeed.\";","{name, ?target = valid(caller) ? caller | player} = args;","if ((name in this.stupid_names) || (name in this.reserved))","return 0;","elseif (((((!name) || index(name, \" \")) || index(name, \"\\\\\")) || index(name, \"\\\"\")) || index(name, \"\t\"))","return 0;","elseif (index(\"*#()\", name[1]))","return 0;","elseif (valid(who = this:find_exact(name)) && is_player(who))","return who;","elseif ($object_utils:has_callable_verb($local, \"legal_name\") && (!$local:legal_name(name, target)))","return 0;","else","return 1;","endif"]},{"name":"suspend_restart","owner":2,"perms":173,"preposition":-1,"code":["\"used during :load to do the usual out-of-time check.\";","\"if someone makes a modification during the suspension (indicated by this.frozen being set to 2), we have to restart the entire load.\";","if (caller != this)","return E_PERM;","elseif ($command_utils:running_out_of_time())","player:tell(\"...\", args[1]);","set_task_perms($byte_quota_utils:task_perms());","suspend(0);","if (this.frozen != 1)","player:tell(\"...argh... restarting $player_db:load...\");","fork (0)","this:load();","endfork","kill_task(task_id());","endif","endif"]},{"name":"why_bad_name","owner":2,"perms":173,"preposition":-1,"code":["\":why_bad_name(player, namespec) => Returns a message explaining why a player name change is invalid.  Stolen from APHiD's #15411:name_okay.\";","who = args[1];","name = $building_utils:parse_names(args[2])[1];","si = index(name, \" \");","qi = index(name, \"\\\"\");","bi = index(name, \"\\\\\");","ti = index(name, \"\t\");","if ((si || qi) || bi)","return tostr(\"You may not use a name containing \", $string_utils:english_list({@si ? {\"spaces\"} | {}, @qi ? {\"quotation marks\"} | {}, @bi ? {\"backslashes\"} | {}, @ti ? {\"tabs\"} | {}}, \"ERROR\", \" or \"), \".  Try \\\"\", strsub(strsub(strsub(name, \" \", \"_\"), \"\\\"\", \"'\"), \"\\\\\", \"/\"), \"\\\" instead.\");","elseif (name == \"\")","return tostr(\"You may not use a blank name.\");","elseif (i = index(\"*#()\", name[1]))","return tostr(\"You may not begin a name with the \\\"\", \"*#()\"[i], \"\\\" character.\");","elseif (name in $player_db.stupid_names)","return tostr(\"The name \\\"\", name, \"\\\" would probably cause problems in command parsing or similar usage.\");","elseif (name in $player_db.reserved)","return tostr(\"The name \\\"\", name, \"\\\" is reserved.\");","elseif (length(name) > $login.max_player_name)","return tostr(\"The name \\\"\", name, \"\\\" is too long.  Maximum name length is \", $login.max_player_name, \" characters.\");","elseif ((valid(match = $player_db:find_exact(name)) && is_player(match)) && (who != match))","return tostr(\"The name \\\"\", name, \"\\\" is already being used by \", match.name, \"(\", match, \").\");","elseif ($player_db.frozen)","return tostr(\"$player_db is not accepting new changes at the moment.\");","elseif ($object_utils:has_callable_verb($local, \"legal_name\") && (!$local:legal_name(name, who)))","return \"That name is reserved.\";","endif"]},{"name":"mail_forward","owner":2,"perms":173,"preposition":-1,"code":["if (typeof(mf = this.(verb)) == STR)","return $string_utils:pronoun_sub(mf, @args);","else","return mf;","endif"]},{"name":"receive_message","owner":2,"perms":173,"preposition":-1,"code":["\":receive_message(msg,from)\";","if ((!$perm_utils:controls(caller_perms(), this)) && (caller != this))","return E_PERM;","endif","if (this:mail_option(\"no_dupcc\", args[1][1], args[1][2]))","\"pass to :mail_option the TEXT versions of who the message is from and to\";","recipients = setremove($mail_agent:parse_address_field(args[1][3]), this);","for x in (recipients)","if (this:get_current_message(x))","return 0;","endif","endfor","endif","if (this:mail_option(\"netmail\"))","msg = args[1];","message = {\"Forwarded: \" + msg[4], \"Original-date: \" + ctime(msg[1]), \"Original-From: \" + msg[2], \"Original-To: \" + msg[3], (((\"Reply-To: \" + $string_utils:substitute(args[2].name, {{\"@\", \"%\"}})) + \"@\") + $network.moo_name) + \".moo.mud.org\"};","for x in (msg[5..$])","message = {@message, @$generic_editor:fill_string(x, this:linelen())};","endfor","if (this:send_self_netmail(message, @listdelete(args, 1)) == 0)","return 0;","endif","endif","set_task_perms(this.owner);","new = this:new_message_num();","ncur = (new <= 1) ? 0 | min(this:current_message(this), new);","this:set_current_message(this, ncur);","new = max(new, ncur + 1);","this.messages = {@this.messages, {new, args[1]}};","\"... new-mail notification is now done directly by $mail_agent:raw_send\";","\"... see :notify_mail...\";","return new;"]},{"name":"display_message","owner":2,"perms":173,"preposition":-1,"code":["\":display_message(preamble,msg) --- prints msg to player.\";","vb = ((this._mail_task == task_id()) || (caller == $mail_editor)) ? \"notify_lines_suspended\" | \"tell_lines_suspended\";","preamble = args[1];","player:(vb)({@(typeof(preamble) == LIST) ? preamble | {preamble}, @args[2], \"--------------------------\"});"]},{"name":"parse_message_seq from_msg_seq %from_msg_seq to_msg_seq %to_msg_seq subject_msg_seq body_msg_seq kept_msg_seq unkept_msg_seq display_seq_headers display_seq_full messages_in_seq list_rmm new_message_num length_num_le length_date_le length_date_gt length_all_msgs exists_num_eq msg_seq_to_msg_num_list msg_seq_to_msg_num_string rm_message_seq undo_rmm expunge_rmm renumber keep_message_seq","owner":2,"perms":173,"preposition":-1,"code":["\"parse_message_seq(strings,cur)         => msg_seq\";","\"messages_in_seq(msg_seq);              => text of messages in msg_seq\";","\"display_seq_headers(msg_seq[,current]) :displays summary lines of those msgs\";","\"rmm_message_seq(msg_seq)               => string giving msg numbers removed\";","\"undo_rmm()    => msg_seq of restored messages\";","\"expunge_rmm() => number of messages expunged\";","\"list_rmm()    => number of messages awaiting expunge\";","\"renumber(cur) => {number of messages in folder, new_cur}\";","\"\";","\"See the corresponding routines on $mail_agent.\";","if ((caller == $mail_agent) || $perm_utils:controls(caller_perms(), this))","set_task_perms(this.owner);","return $mail_agent:(verb)(@args);","else","return E_PERM;","endif"]},{"name":"msg_summary_line","owner":36,"perms":173,"preposition":-1,"code":["return $mail_agent:msg_summary_line(@args);"]},{"name":"msg_text","owner":2,"perms":173,"preposition":-1,"code":["\":msg_text(@msg) => list of strings.\";","\"msg is a mail message (in the usual transmission format) being read BY this player.\";","\"The default version of recipient:msg_full_text calls this to obtain the actual list of strings to display.  (this is a badly named verb).\";","\"returns the actual list of strings to display.\";","return $mail_agent:to_text(@args);"]},{"name":"notify_mail","owner":2,"perms":173,"preposition":-1,"code":["\":notify_mail(from,recipients[,msgnums])\";","\" used by $mail_agent:raw_send to notify this player about mail being sent\";","\" from <from> to <recipients>.  <msgnums> if given gives the message number(s) assigned (in the event that the corresponding recipient actually kept the mail)\";","if (!$object_utils:connected(this))","return;","elseif (!((caller in {this, $mail_agent}) || $perm_utils:controls(caller_perms(), this)))","return E_PERM;","else","{from, recipients, ?msgnums = {}} = args;","from_name = $mail_agent:name(from);","\"... msgnums may be shorter than recipients or may have some slots filled\";","\"... with 0's if msg numbers are not available for some recipients.\";","if ((t = this in recipients) && ((length(msgnums) >= t) && msgnums[t]))","\"... you are getting the mail and moreover your :receive_message kept it.\";","namelist = $string_utils:english_list($list_utils:map_arg($mail_agent, \"name\", setremove(recipients, this)), \"\");","this:notify(tostr(\"You have new mail (\", msgnums[t], \") from \", from_name, namelist ? \" which was also sent to \" + namelist | \"\", \".\"));","if (!this:mail_option(\"expert\"))","this:notify(tostr(\"Type `help mail' for info on reading it.\"));","endif","else","\"... vanilla notification; somebody got sent mail and you're finding out.\";","namelist = $string_utils:english_list({@t ? {\"You\"} | {}, @$list_utils:map_arg($mail_agent, \"name\", setremove(recipients, this))}, \"\");","this:tell(tostr(namelist, (length(recipients) == 1) ? \" has\" | \" have\", \" just been sent new mail by \", from_name, \".\"));","endif","endif"]},{"name":"current_message","owner":2,"perms":173,"preposition":-1,"code":["\":current_message([recipient])\";","\" => current message number for the given recipient (defaults to this).\";","\" => 0 if we have no record of that recipient\";","\"      or current message happens to be 0.\";","\"This verb is mostly obsolete; consider using :get_current_message()\";","if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))","raise(E_PERM);","elseif ((!args) || (args[1] == this))","return this.current_message[1];","elseif (a = $list_utils:assoc(args[1], this.current_message))","return a[2];","else","return 0;","endif"]},{"name":"get_current_message","owner":2,"perms":173,"preposition":-1,"code":["\":get_current_message([recipient])\";","\" => {msg_num, last_read_date} for the given recipient.\";","\" => 0 if we have no record of that recipient.\";","if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))","raise(E_PERM);","elseif ((!args) || (args[1] == this))","if (length(this.current_message) < 2)","\"Whoops, this got trashed---fix it up!\";","this.current_message = {0, time(), @this.current_message};","endif","return this.current_message[1..2];","elseif (a = $list_utils:assoc(args[1], this.current_message))","return a[2..3];","else","return 0;","endif"]},{"name":"set_current_message","owner":2,"perms":173,"preposition":-1,"code":["\":set_current_message(recipient[,number[,date]])\";","\"Returns the new {number,last-read-date} pair for recipient.\";","if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))","raise(E_PERM);","endif","{recip, ?number = E_NONE, ?date = 0} = args;","cm = this.current_message;","if (recip == this)","this.current_message[2] = max(date, cm[2]);","if (number != E_NONE)","this.current_message[1] = number;","endif","return this.current_message[1..2];","elseif (i = $list_utils:iassoc(recip, cm))","return (this.current_message[i] = {recip, (number == E_NONE) ? cm[i][2] | number, max(date, cm[i][3])})[2..3];","else","entry = {recip, (number != E_NONE) && number, date};","this.current_message = {@cm, entry};","return entry[2..3];","endif"]},{"name":"make_current_message","owner":2,"perms":173,"preposition":-1,"code":["\":make_current_message(recipient[,index])\";","\"starts a new current_message record for recipient.\";","\"index, if given, indicates where recipient is to be\";","\"  placed (n = at or after nth entry in .current_message).\";","recip = args[1];","cm = this.current_message;","if (length(args) > 1)","i = max(2, min(args[2], length(cm)));","else","i = 0;","endif","if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))","raise(E_PERM);","elseif (recip == this)","\"...self...\";","elseif (j = $list_utils:iassoc(recip, cm))","\"...already present...\";","if (i)","if (j < i)","this.current_message = {@cm[1..j - 1], @cm[j + 1..i], cm[j], @cm[i + 1..$]};","elseif (j > (i + 1))","this.current_message = {@cm[1..i], cm[j], @cm[i + 1..j - 1], @cm[j + 1..$]};","endif","endif","else","this.current_message = listappend(cm, {recip, 0, 0}, @i ? {i} | {});","endif"]},{"name":"kill_current_message","owner":2,"perms":173,"preposition":-1,"code":["\":kill_current_message(recipient)\";","\"entirely forgets current message for this recipient...\";","\"Returns true iff successful.\";","if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))","raise(E_PERM);","else","return ((recip = args[1]) != this) && ((i = $list_utils:iassoc(recip, cm = this.current_message)) && (this.current_message = listdelete(cm, i)));","endif"]},{"name":"current_folder","owner":2,"perms":173,"preposition":-1,"code":["\":current_folder() => default folder to use, always an object, usually `this'\";","set_task_perms(caller_perms());","return ((!this:mail_option(\"sticky\")) || this.current_folder) && this;"]},{"name":"set_current_folder","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","return this.current_folder = args[1];"]},{"name":"parse_folder_spec","owner":2,"perms":173,"preposition":-1,"code":["\":parse_folder_spec(verb,args,expected_preposition[,allow_trailing_args_p])\";","\" => {folder, msg_seq_args, trailing_args}\";","set_task_perms(caller_perms());","folder = this:current_folder();","if (!prepstr)","return {folder, args[2], {}};","endif","{verb, args, prep, ?extra = 0} = args;","p = prepstr in args;","if (prepstr != prep)","\"...unexpected preposition...\";","if (extra && (!index(prepstr, \" \")))","return {folder, args[1..p - 1], args[p..$]};","else","player:tell(\"Usage:  \", verb, \" [<message numbers>] [\", prep, \" <folder/list-name>]\");","endif","elseif (!((p < length(args)) && (fname = args[p + 1])))","\"...preposition but no iobj...\";","player:tell(verb, \" \", $string_utils:from_list(args, \" \"), \" WHAT?\");","elseif ($mail_agent:match_failed(folder = $mail_agent:match_recipient(fname, this), fname))","\"...bogus mail folder...\";","else","return {folder, args[1..p - 1], args[p + 2..$]};","endif","return 0;"]},{"name":"parse_mailread_cmd","owner":2,"perms":173,"preposition":-1,"code":["\":parse_mailread_cmd(verb,args,default,prep[,trailer])\";","\"  handles anything of the form  `VERB message_seq [PREP folder ...]'\";","\"    default is the default msg-seq to use if none given\";","\"    prep is the expected prepstr (assumes prepstr is set), usually `on'\";","\"    trailer, if present and true, indicates trailing args are permitted.\";","\"  returns {recipient object, message_seq, current_msg,\\\"...\\\"} or 0\";","set_task_perms(caller_perms());","if (!(pfs = this:parse_folder_spec(@listdelete(args, 3))))","return 0;","endif","{verb, args, default, prep, ?extra = 0} = args;","folder = pfs[1];","cur = this:get_current_message(folder) || {0};","if (typeof(pms = folder:parse_message_seq(pfs[2], @cur)) == LIST)","rest = {@listdelete(pms, 1), @pfs[3]};","if ((!extra) && rest)","\"...everything should have been gobbled by :parse_message_seq...\";","player:tell(\"I don't understand `\", rest[1], \"'\");","return 0;","elseif (pms[1])","\"...we have a nonempty message sequence...\";","return {folder, pms[1], cur, rest};","elseif (used = (length(pfs[2]) + 1) - length(pms))","\"...:parse_message_seq used some words, but didn't get anything out of it\";","pms = (\"%f %<has> no `\" + $string_utils:from_list(pfs[2][1..used], \" \")) + \"' messages.\";","elseif (typeof(pms = folder:parse_message_seq(default, @cur)) == LIST)","\"...:parse_message_seq used nothing, try the default; wow it worked\";","return {folder, pms[1], cur, rest};","endif","elseif (typeof(pms) == ERR)","player:tell($mail_agent:name(folder), \" is not readable by you.\");","if (!$object_utils:isa(folder, $mail_recipient))","player:tell(\"Use * to indicate a non-player mail recipient.\");","endif","return 0;","endif","if (folder == this)","subst = {{\"%f's\", \"Your\"}, {\"%f\", \"You\"}, {\"%<has>\", \"have\"}};","elseif (is_player(folder))","subst = {{\"%f\", folder.name}, {\"%<has>\", $gender_utils:get_conj(\"has\", folder)}};","else","subst = {{\"%f\", $mail_agent:name(folder)}, {\"%<has>\", \"has\"}};","endif","player:tell($string_utils:substitute(pms, {@subst, {\"%%\", \"%\"}}));","return 0;"]},{"name":"@mail","owner":2,"perms":93,"preposition":-2,"code":["\"@mail <msg-sequence>                --- as in help @mail\";","\"@mail <msg-sequence> on <recipient> --- shows mail on mailing list or player.\";","set_task_perms(valid(cp = caller_perms()) ? cp | player);","if (p = this:parse_mailread_cmd(\"@mail\", args, this:mail_option(\"@mail\") || $mail_agent.(\"player_default_@mail\"), \"on\"))","this:set_current_folder(folder = p[1]);","msg_seq = p[2];","seq_size = $seq_utils:size(msg_seq);","if ((lim = player:mail_option(\"manymsgs\")) && ((lim <= seq_size) && (!$command_utils:yes_or_no(tostr(\"You are about to see \", seq_size, \" message headers.  Continue?\")))))","player:notify(tostr(\"Aborted.  @mailoption manymsgs=\", lim));","return;","endif","if (1 != seq_size)","player:notify(tostr(seq_size, \" messages\", (folder == this) ? \"\" | (\" on \" + $mail_agent:name(folder)), \":\"));","endif","folder:display_seq_headers(msg_seq, @p[3]);","endif"]},{"name":"@read @peek","owner":2,"perms":93,"preposition":-2,"code":["\"@read <msg>...                  -- as in help @read\";","\"@read <msg>... on *<recipient>  -- reads messages on recipient.\";","\"@peek ...                       -- like @read, but don't set current message\";","set_task_perms(valid(cp = caller_perms()) ? cp | player);","if (p = this:parse_mailread_cmd(\"@read\", args, \"\", \"on\"))","this:set_current_folder(folder = p[1]);","msg_seq = p[2];","if ((lim = player:mail_option(\"manymsgs\")) && ((lim <= (seq_size = $seq_utils:size(msg_seq))) && (!$command_utils:yes_or_no(tostr(\"You are about to see \", seq_size, \" messages.  Continue?\")))))","player:notify(tostr(\"Aborted.  @mailoption manymsgs=\", lim));","return;","endif","this._mail_task = task_id();","if (cur = folder:display_seq_full(msg_seq, tostr(\"Message %d\", (folder == this) ? \"\" | (\" on \" + $mail_agent:name(folder)), \":\")))","if (verb != \"@peek\")","this:set_current_message(folder, @cur);","endif","endif","endif"]},{"name":"@next @prev","owner":2,"perms":89,"preposition":-2,"code":["set_task_perms(player.owner);","if (dobjstr && (!(n = toint(dobjstr))))","player:notify(tostr(\"Usage:  \", verb, \"[<number>] [on <recipient>]\"));","elseif (dobjstr)","this:(\"@read\")(tostr(verb[2..5], n), @listdelete(args, 1));","else","this:(\"@read\")(verb[2..5], @args);","endif"]},{"name":"@rmm*ail","owner":2,"perms":89,"preposition":-2,"code":["\"@rmm <message-sequence> [from <recipient>].   Use @unrmm if you screw up.\";","\" Beware, though.  @unrmm can only undo the most recent @rmm.\";","set_task_perms(player);","if (!(p = this:parse_mailread_cmd(\"@rmm\", args, \"cur\", \"from\")))","\"...parse failed, we've already complained...\";","elseif ((!prepstr) && ((p[1] != this) && (!$command_utils:yes_or_no((\"@rmmail from \" + $mail_agent:name(p[1])) + \".  Continue?\"))))","\"...wasn't the folder player was expecting...\";","player:notify(\"@rmmail aborted.\");","else","this:set_current_folder(folder = p[1]);","e = folder:rm_message_seq(p[2]);","if (typeof(e) == ERR)","player:notify(tostr($mail_agent:name(folder), \":  \", e));","else","count = ((n = $seq_utils:size(p[2])) == 1) ? \".\" | tostr(\" (\", n, \" messages).\");","fname = (folder == this) ? \"\" | (\" from \" + $mail_agent:name(folder));","player:notify(tostr(\"Deleted \", e, fname, count));","endif","endif"]},{"name":"@renumber","owner":2,"perms":25,"preposition":-1,"code":["set_task_perms(player);","if (!dobjstr)","folder = this:current_folder();","elseif ($mail_agent:match_failed(folder = $mail_agent:match_recipient(dobjstr), dobjstr))","return;","endif","cur = this:current_message(folder);","fname = $mail_agent:name(folder);","if (typeof(h = folder:renumber(cur)) == ERR)","player:notify(tostr(h));","else","if (!h[1])","player:notify(tostr(\"No messages on \", fname, \".\"));","else","player:notify(tostr(\"Messages on \", fname, \" renumbered 1-\", h[1], \".\"));","this:set_current_folder(folder);","if (h[2] && this:set_current_message(folder, h[2]))","player:notify(tostr(\"Current message is now \", h[2], \".\"));","endif","endif","endif"]},{"name":"@unrmm*ail","owner":2,"perms":89,"preposition":-2,"code":["\"@unrmm [on <recipient>]  -- undoes the previous @rmm on that recipient.\";","set_task_perms(player);","if (!(p = this:parse_folder_spec(\"@unrmm\", args, \"on\")))","return;","endif","dobjstr = $string_utils:from_list(p[2], \" \");","keep = 0;","if ((!dobjstr) || (keep = index(\"keep\", dobjstr) == 1))","do = \"undo_rmm\";","elseif (index(\"expunge\", dobjstr) == 1)","do = \"expunge_rmm\";","elseif (index(\"list\", dobjstr) == 1)","do = \"list_rmm\";","else","player:notify(tostr(\"Usage:  \", verb, \" [expunge|list] [on <recipient>]\"));","return;","endif","this:set_current_folder(folder = p[1]);","if (msg_seq = folder:(do)(@keep ? {keep} | {}))","if (do == \"undo_rmm\")","player:notify(tostr($seq_utils:size(msg_seq), \" messages restored to \", $mail_agent:name(folder), \".\"));","folder:display_seq_headers(msg_seq, 0);","else","player:notify(tostr(msg_seq, \" zombie message\", (msg_seq == 1) ? \" \" | \"s \", (do == \"expunge_rmm\") ? \"expunged from \" | \"on \", $mail_agent:name(folder), \".\"));","endif","elseif (typeof(msg_seq) == ERR)","player:notify(tostr($mail_agent:name(folder), \":  \", msg_seq));","else","player:notify(tostr(\"No messages to \", (do == \"expunge_rmm\") ? \"expunge from \" | \"restore to \", $mail_agent:name(folder)));","endif"]},{"name":"@send","owner":2,"perms":93,"preposition":-2,"code":["if (args && (args[1] == \"to\"))","args = listdelete(args, 1);","endif","subject = {};","for a in (args)","if (((i = index(a, \"=\")) > 3) && (index(\"subject\", a[1..i - 1]) == 1))","args = setremove(args, a);","a[1..i] = \"\";","subject = {a};","endif","endfor","$mail_editor:invoke(args, verb, @subject);"]},{"name":"@answer @repl*y","owner":2,"perms":89,"preposition":-2,"code":["\"@answer <msg> [on *<recipient>] [<flags>...]\";","set_task_perms(who = valid(caller_perms()) ? caller_perms() | player);","if (p = this:parse_mailread_cmd(verb, args, \"cur\", \"on\", 1))","if ($seq_utils:size(p[2]) != 1)","player:notify(\"You can only answer *one* message at a time.\");","elseif (LIST != typeof(flags_replytos = $mail_editor:check_answer_flags(@p[4])))","player:notify_lines({tostr(\"Usage:  \", verb, \" [message-# [on <recipient>]] [flags...]\"), \"where flags include any of:\", \"  all        reply to everyone\", \"  sender     reply to sender only\", \"  include    include the original message in your reply\", \"  noinclude  don't include the original in your reply\"});","else","this:set_current_folder(p[1]);","$mail_editor:invoke(2, verb, p[1]:messages_in_seq(p[2])[1][2], @flags_replytos);","endif","endif"]},{"name":"@forward","owner":2,"perms":93,"preposition":-2,"code":["\"@forward <msg> [on *<recipient>] to <recipient> [<recipient>...]\";","set_task_perms(valid(cp = caller_perms()) ? cp | player);","if (!(p = this:parse_mailread_cmd(verb, args, \"\", \"on\", 1)))","\"...lose...\";","return;","elseif ($seq_utils:size(sequence = p[2]) != 1)","player:notify(\"You can only forward *one* message at a time.\");","return;","elseif ((length(p[4]) < 2) || (p[4][1] != \"to\"))","player:notify(tostr(\"Usage:  \", verb, \" [<message>] [on <folder>] to <recip>...\"));","return;","endif","recips = {};","for rs in (listdelete(p[4], 1))","if ($mail_agent:match_failed(r = $mail_agent:match_recipient(rs), rs))","return;","endif","recips = {@recips, r};","endfor","this:set_current_folder(folder = p[1]);","m = folder:messages_in_seq(sequence)[1];","msgnum = m[1];","msgtxt = m[2];","from = msgtxt[2];","if (msgtxt[4] != \" \")","subject = tostr(\"[\", from, \":  \", msgtxt[4], \"]\");","elseif ((h = \"\" in msgtxt) && (h < length(msgtxt)))","subject = tostr(\"[\", from, \":  `\", msgtxt[h + 1][1..min(20, $)], \"']\");","else","subject = tostr(\"[\", from, \"]\");","endif","result = $mail_agent:send_message(player, recips, subject, $mail_agent:to_text(@msgtxt));","if (!result)","player:notify(tostr(result));","elseif (result[1])","player:notify(tostr(\"Message \", msgnum, @(folder == this) ? {} | {\" on \", $mail_agent:name(folder)}, \" @forwarded to \", $mail_agent:name_list(@listdelete(result, 1)), \".\"));","else","player:notify(\"Message not sent.\");","endif"]},{"name":"@gripe","owner":2,"perms":89,"preposition":-2,"code":["$mail_editor:invoke($gripe_recipients, \"@gripe\", \"@gripe: \" + argstr);"]},{"name":"@typo @bug @suggest*ion @idea @comment","owner":2,"perms":89,"preposition":-2,"code":["subject = tostr($string_utils:capitalize(verb[2..$]), \":  \", (loc = this.location).name, \"(\", loc, \")\");","if (this != player)","return E_PERM;","elseif (argstr)","result = $mail_agent:send_message(this, {loc.owner}, subject, argstr);","if (result && result[1])","player:notify(tostr(\"Your \", verb, \" sent to \", $mail_agent:name_list(@listdelete(result, 1)), \".  Input is appreciated, as always.\"));","else","player:notify(tostr(\"Huh?  This room's owner (\", loc.owner, \") is invalid?  Tell a wizard...\"));","endif","return;","elseif (!($object_utils:isa(loc, $room) && loc.free_entry))","player:notify_lines({tostr(\"You need to make it a one-liner, i.e., `\", verb, \" something or other'.\"), \"This room may not let you back in if you go to the Mail Room.\"});","elseif ($object_utils:isa(loc, $generic_editor))","player:notify_lines({tostr(\"You need to make it a one-liner, i.e., `\", verb, \" something or other'.\"), \"Sending you to the Mail Room from an editor is usually a bad idea.\"});","else","$mail_editor:invoke({tostr(loc.owner)}, verb, subject);","endif","if (verb == \"@bug\")","player:notify(\"For a @bug report, be sure to mention exactly what it was you typed to trigger the error...\");","endif"]},{"name":"@skip","owner":2,"perms":89,"preposition":-2,"code":["\"@skip [*<folder/mailing_list>...]\";","\"  sets your last-read time for the given lists to now, indicating your\";","\"  disinterest in any new messages that might have appeared recently.\";","set_task_perms(player);","current_folder = this:current_folder();","for a in (args || {0})","if (a ? $mail_agent:match_failed(folder = $mail_agent:match_recipient(a), a) | (folder = this:current_folder()))","\"...bogus folder name, done...  No, try anyway.\";","if (this:kill_current_message(this:my_match_object(a)))","player:notify(\"Invalid folder, but found it subscribed anyway.  Removed.\");","endif","else","lseq = folder:length_all_msgs();","unread = (n = this:get_current_message(folder)) ? folder:length_date_gt(n[2]) | lseq;","this:set_current_message(folder, lseq && folder:messages_in_seq({lseq, lseq + 1})[1][1], time());","player:notify(tostr(unread ? tostr(\"Ignoring \", unread) | \"No\", \" unread message\", (unread != 1) ? \"s\" | \"\", \" on \", $mail_agent:name(folder)));","if (current_folder == folder)","this:set_current_folder(this);","endif","endif","endfor"]},{"name":"@subscribe*-quick @unsubscribed*-quick","owner":2,"perms":89,"preposition":-2,"code":["\"@subscribe *<folder/mailing_list> [with notification] [before|after *<folder>]\";","\"  causes you to be notified when new mail arrives on this list\";","\"@subscribe\";","\"  just lists available mailing lists.\";","\"@unsubscribed\";","\"  prints out available mailing lists you aren't already subscribed to.\";","\"@subscribe-quick and @unsubscribed-quick\";","\"  prints out same as above except without mail list descriptions, just names.\";","set_task_perms(player);","quick = 0;","if (qi = index(verb, \"-q\"))","verb = verb[1..qi - 1];","quick = 1;","endif","fname = {@args, 0}[1];","if (!fname)","ml = $list_utils:slice(this.current_message[3..$]);","all_mlists = {@$mail_agent.contents, @this.mail_lists};","if ((length(all_mlists) > 50) && (!$command_utils:yes_or_no(tostr(\"There are \", length(all_mlists), \" mailing lists.  Are you sure you want the whole list?\"))))","return player:tell(\"OK, aborting.\");","endif","for c in (all_mlists)","$command_utils:suspend_if_needed(0);","if ((c:is_usable_by(this) || c:is_readable_by(this)) && ((verb != \"@unsubscribed\") || (!(c in ml))))","c:look_self(quick);","endif","endfor","player:notify(tostr(\"-------- end of \", verb, \" -------\"));","return;","elseif (verb == \"@unsubscribed\")","player:notify(\"@unsubscribed does not take arguments.\");","return;","elseif ($mail_agent:match_failed(folder = $mail_agent:match_recipient(fname), fname))","return;","elseif (folder == this)","player:notify(\"You don't need to @subscribe to yourself\");","return;","elseif ($object_utils:isa(folder, $mail_recipient) ? !folder:is_readable_by(this) | (!$perm_utils:controls(this, folder)))","player:notify(\"That mailing list is not readable by you.\");","return;","endif","notification = this in folder.mail_notify;","i = 0;","beforeafter = 0;","while (length(args) >= 2)","if (length(args) < 3)","player:notify(args[2] + \" what?\");","return;","elseif (args[2] in {\"with\", \"without\"})","with = args[2] == \"with\";","if (index(\"notification\", args[3]) != 1)","player:notify(tostr(\"with \", args[3], \"?\"));","return;","elseif (!$object_utils:isa(folder, $mail_recipient))","player:notify(tostr(\"You cannot use \", verb, \" to change mail notification from a non-$mail_recipient.\"));","elseif ((!with) == (!notification))","\"... nothing to do...\";","elseif (with)","if (this in folder:add_notify(this))","notification = 1;","else","player:notify(\"This mail recipient does not allow immediate notification.\");","endif","else","folder:delete_notify(this);","notification = 0;","endif","elseif (args[2] in {\"before\", \"after\"})","if (beforeafter)","player:notify((args[2] == beforeafter) ? tostr(\"two `\", beforeafter, \"'s?\") | \"Only use one of `before' or `after'\");","return;","elseif ($mail_agent:match_failed(other = $mail_agent:match_recipient(args[3]), args[3]))","return;","elseif (other == this)","i = 2;","elseif (!(i = $list_utils:iassoc(other, this.current_message)))","player:notify(tostr(\"You aren't subscribed to \", $mail_agent:name(other), \".\"));","return;","endif","beforeafter = args[2];","i = i - (beforeafter == \"before\");","if (this:mail_option(\"rn_order\") != \"fixed\")","player:notify(\"Warning:  Do `@mail-option rn_order=fixed' if you do not want your @rn listing reordered when you next login.\");","endif","endif","args[2..3] = {};","endwhile","this:make_current_message(folder, @i ? {i} | {});","len = folder:length_all_msgs();","player:notify(tostr($mail_agent:name(folder), \" has \", len, \" message\", (len == 1) ? \"\" | \"s\", \".\", notification ? \"  You will be notified immediately when new messages are posted.\" | \"  Notification of new messages will be printed when you connect.\"));","this:set_current_folder(folder);"]},{"name":"mail_catch_up","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms((caller == this) ? this.owner | caller_perms());","this:set_current_folder(this);","dates = new_cm = head = {};","sort = this:mail_option(\"rn_order\") || \"read\";","for n in (this.current_message)","$command_utils:suspend_if_needed(0);","if (typeof(n) != LIST)","head = {@head, n};","elseif ($object_utils:isa(folder = n[1], $mail_recipient) && folder:is_readable_by(this))","\"...set current msg to be the last one you could possibly have read.\";","if (n[3] < folder.last_msg_date)","i = folder:length_date_le(n[3]);","n[2] = i && folder:messages_in_seq(i)[1];","endif","if (sort == \"fixed\")","new_cm = {n, @new_cm};","elseif (sort == \"send\")","j = $list_utils:find_insert(dates, folder.last_msg_date - 1);","dates = listinsert(dates, folder.last_msg_date, j);","new_cm = listinsert(new_cm, n, j);","else","new_cm = listappend(new_cm, n, $list_utils:iassoc_sorted(n[3] - 1, new_cm, 3));","endif","endif","endfor","this.current_message = {@head, @$list_utils:reverse(new_cm)};"]},{"name":"@rn check_mail_lists @subscribed @rn-full","owner":2,"perms":13,"preposition":-1,"code":["set_task_perms((caller == this) ? this.owner | caller_perms());","which = {};","cm = this.current_message;","cm[1..2] = ((verb == \"@rn\") || (verb == \"@rn-full\")) ? {{this, @cm[1..2]}} | {};","all = verb == \"@subscribed\";","fast = this:mail_option(\"fast_check\") && (verb != \"@rn-full\");","for n in (cm)","rcpt = n[1];","if (rcpt == $news)","\"... $news is handled separately ...\";","elseif ($mail_agent:is_recipient(rcpt))","if (fast)","if (rcpt == this)","nmsgs = ((m = this.messages) && (m[length(m)][2][1] > n[3])) ? $maxint | 0;","else","try","nmsgs = (n[1].last_msg_date > n[3]) ? $maxint | 0;","except (E_PERM, E_PROPNF)","player:notify(tostr(\"Bogus recipient \", rcpt, \" removed from .current_message.\"));","this.current_message = setremove(this.current_message, n);","nmsgs = 0;","endtry","endif","else","nmsgs = n[1]:length_date_gt(n[3]);","endif","if (nmsgs || all)","which = {@which, {n[1], nmsgs}};","endif","else","player:notify(tostr(\"Bogus recipient \", rcpt, \" removed from .current_message.\"));","this.current_message = setremove(this.current_message, n);","endif","$command_utils:suspend_if_needed(0);","endfor","if (which)","player:notify(tostr((verb == \"@subscribed\") ? \"You are subscribed to the following\" | \"There is new activity on the following\", (length(which) > 1) ? \" lists:\" | \" list:\"));","for w in (which)","name = (w[1] == this) ? \" me\" | $mail_agent:name(w[1]);","player:notify(tostr($string_utils:left(\"    \" + name, 40), \" \", (w[2] == $maxint) ? \"has\" | w[2], \" new message\", (w[2] == 1) ? \"\" | \"s\"));","$command_utils:suspend_if_needed(0);","endfor","if (verb != \"check_mail_lists\")","player:notify(\"-- End of listing\");","endif","elseif ((verb == \"@rn\") || (verb == \"@rn-full\"))","player:notify(\"No new activity on any of your lists.\");","elseif (verb == \"@subscribed\")","player:notify(\"You aren't subscribed to any mailing lists.\");","endif","return which;"]},{"name":"mail_option","owner":2,"perms":173,"preposition":-1,"code":["\":mail_option(name)\";","\"Returns the value of the specified mail option\";","if ((caller in {this, $mail_editor, $mail_agent}) || $perm_utils:controls(caller_perms(), this))","return $mail_options:get(this.mail_options, args[1]);","else","return E_PERM;","endif"]},{"name":"@unsub*scribe","owner":2,"perms":89,"preposition":-2,"code":["\"@unsubscribe [*<folder/mailing_list> ...]\";","\"entirely removes the record of your current message for the named folders,\";","\"indicating your disinterest in anything that might appear there in the future.\";","set_task_perms(player);","unsubscribed = {};","current_folder = this:current_folder();","for a in (args || {0})","if (a != 0)","folder = $mail_agent:match_recipient(a);","if (folder == $failed_match)","folder = this:my_match_object(a);","endif","else","folder = current_folder;","endif","if (!valid(folder))","\"...bogus folder name...  try removing it anyway.\";","if (this:kill_current_message(folder))","player:notify(\"Invalid folder, but found it subscribed anyway.  Removed.\");","else","$mail_agent:match_failed(folder, a);","endif","elseif (folder == this)","player:notify(tostr(\"You can't \", verb, \" yourself.\"));","else","if (!this:kill_current_message(folder))","player:notify(tostr(\"You weren't subscribed to \", $mail_agent:name(folder)));","if ($object_utils:isa(folder, $mail_recipient))","result = folder:delete_notify(this);","if ((typeof(result) == LIST) && (result[1] == this))","player:notify(\"Removed you from the mail notifications list.\");","endif","endif","else","unsubscribed = {@unsubscribed, folder};","if ($object_utils:isa(folder, $mail_recipient))","folder:delete_notify(this);","endif","endif","endif","endfor","if (unsubscribed)","player:notify(tostr(\"Forgetting about \", $string_utils:english_list($list_utils:map_arg($mail_agent, \"name\", unsubscribed))));","if (current_folder in unsubscribed)","this:set_current_folder(this);","endif","endif"]},{"name":"send_self_netmail","owner":2,"perms":173,"preposition":-1,"code":["\":send_self_netmail(msg [ ,from ])\";","\"return 0 if successful, otherwise error.\";","if (!$perm_utils:controls(caller_perms(), this))","return E_PERM;","elseif (error = $network:invalid_email_address($wiz_utils:get_email_address(this)))","return \"Invalid email address: \" + error;","else","msg = args[1];","if (length(args) > 1)","from = args[2];","this:notify(tostr(\"Receiving mail from \", from:title(), \" (\", from, \") and forwarding it to your .email_address.\"));","endif","oplayer = player;","player = this;","error = $network:sendmail($wiz_utils:get_email_address(this), @msg);","if (error && (length(args) > 1))","this:notify(tostr(\"Mail sending failed: \", error));","endif","player = oplayer;","return error;","endif"]},{"name":"@netforw*ard","owner":2,"perms":93,"preposition":-2,"code":["\"@netforward <msg>...                  -- as in help on @netforward\";","\"@netforward <msg>... on *<recipient>  -- netforwards messages on recipient.\";","\"This command forwards mail-messages to your registered email-address.\";","if (player != this)","return player:tell(E_PERM);","endif","if (reason = $network:email_will_fail(email = $wiz_utils:get_email_address(player)))","return player:notify(tostr(\"Cannot forward mail to your email address: \", reason));","endif","set_task_perms(valid(cp = caller_perms()) ? cp | player);","if (p = player:parse_mailread_cmd(verb, args, \"\", \"on\"))","player:set_current_folder(folder = p[1]);","msg_seq = p[2];","folderstr = (folder == player) ? \"\" | tostr(\" from \", $mail_agent:name(folder));","if ((!this:mail_option(\"expert_netfwd\")) && (!$command_utils:yes_or_no(tostr(\"You are about to forward \", seq_size = $seq_utils:size(msg_seq), \" message(s)\", folderstr, \" to your registered email-address, \", email, \".  Continue?\"))))","player:notify(tostr(\"@Netforward cancelled.\"));","return;","endif","player:notify(\"Attempting to send network mail...\");","player._mail_task = task_id();","multiple_vals = this:format_for_netforward(folder:messages_in_seq(msg_seq), folderstr);","netmail = multiple_vals[1];","header = multiple_vals[2];","reason = player:send_self_netmail({header, @netmail});","player:notify((reason == 0) ? tostr(\"@netforward of \", header, \" completed.\") | tostr(\"@netforward failed: \", reason, \".\"));","endif"]},{"name":"@@sendmail","owner":2,"perms":89,"preposition":-2,"code":["\"Syntax: @@sendmail\";","\"This is intended for use with client editors.  You probably don't want to try using this command manually.\";","\"Reads a formatted mail message, extracts recipients, subject line and/or reply-to header and sends message without going to the mailroom.  Example:\";","\"\";","\"@@send\";","\"To: Rog (#4292)\";","\"Subject: random\";","\"\";","\"first line\";","\"second line\";","\".\";","\"\";","\"Currently, header lines must have the same format as in an actual message.\";","set_task_perms(player);","if (args)","player:notify(tostr(\"The \", verb, \" command takes no arguments.\"));","$command_utils:read_lines();","return;","elseif (this != player)","player:notify(tostr(\"You can't use \", this.pp, \" \", verb, \" verb.\"));","$command_utils:read_lines();","return;","endif","msg = $command_utils:read_lines();","end_head = (\"\" in msg) || (length(msg) + 1);","from = this;","subject = \"\";","replyto = \"\";","rcpts = {};","body = msg[end_head + 1..$];","for i in [1..end_head - 1]","line = msg[i];","if (index(line, \"Subject:\") == 1)","subject = $string_utils:trim(line[9..$]);","elseif (index(line, \"To:\") == 1)","if (!(rcpts = $mail_agent:parse_address_field(line)))","player:notify(\"No recipients found in To: line\");","return;","endif","elseif (index(line, \"Reply-to:\") == 1)","if ((!(replyto = $mail_agent:parse_address_field(line))) && $string_utils:trim(line[10..$]))","player:notify(\"No address found in Reply-to: line\");","return;","endif","elseif (index(line, \"From:\") == 1)","\"... :send_message() bombs if designated sender != player ...\";","if (!(from = $mail_agent:parse_address_field(line)))","player:notify(\"No sender found in From: line\");","return;","elseif (length(from) > 1)","player:notify(\"Multiple senders?\");","return;","endif","from = from[1];","elseif (i = index(line, \":\"))","player:notify(tostr(\"Unknown header \\\"\", line[1..i], \"\\\"\"));","return;","else","player:notify(\"Blank line must separate headers from body.\");","return;","endif","endfor","if (!rcpts)","player:notify(\"No To: line found.\");","elseif (!(subject || body))","player:notify(\"Blank message not sent.\");","else","player:notify(\"Sending...\");","result = $mail_agent:send_message(from, rcpts, replyto ? subject | {subject, replyto}, body);","if (e = result && result[1])","if (length(result) == 1)","player:notify(\"Mail actually went to no one.\");","else","player:notify(tostr(\"Mail actually went to \", $mail_agent:name_list(@listdelete(result, 1)), \".\"));","endif","else","player:notify(tostr((typeof(e) == ERR) ? e | (\"Bogus recipients:  \" + $string_utils:from_list(result[2]))));","player:notify(\"Mail not sent.\");","endif","endif"]},{"name":"@keep-m*ail @keepm*ail","owner":2,"perms":89,"preposition":-2,"code":["\"@keep-mail [<msg-sequence>|none] [on <recipient>]\";","\"marks the indicated messages as `kept'.\";","set_task_perms(valid(cp = caller_perms()) ? cp | player);","if (!args)","return player:notify(\"Usage:  @keep-mail [<msg-sequence>|none] [on <recipient>]\");","elseif (args[1] == \"none\")","args[1..1] = {};","if (!(pfs = this:parse_folder_spec(verb, args, \"on\", 0)))","return;","elseif (pfs[2])","player:notify(tostr(verb, \" <message-sequence> or `none', but not both.\"));","return;","endif","this:set_current_folder(folder = pfs[1]);","if (e = folder:keep_message_seq({}))","player:notify(tostr(\"Messages on \", $mail_agent:name(folder), \" are no longer marked as kept.\"));","else","player:notify(tostr(e));","endif","return;","elseif (p = this:parse_mailread_cmd(verb, args, \"\", \"on\"))","if ((folder = p[1]) != this)","\"... maybe I'll take this clause out some day...\";","player:notify(tostr(verb, \" can only be used on your own mail collection.\"));","return;","endif","this:set_current_folder(folder);","if (e = folder:keep_message_seq(msg_seq = p[2]))","player:notify(tostr(\"Message\", match(e, \"[.,]\") ? \"s \" | \" \", e, \" now marked as kept.\"));","elseif (typeof(e) == ERR)","player:notify(tostr(e));","else","player:notify(tostr(((seq_size = $seq_utils:size(msg_seq)) == 1) ? \"That message is\" | \"Those messages are\", \" already marked as kept.\"));","endif","endif"]},{"name":"my_match_recipient","owner":2,"perms":173,"preposition":-1,"code":["\":my_match_recipient(string) => matches string against player's private mailing lists.\";","if (!(string = args[1]))","return $nothing;","elseif (string[1] == \"*\")","string = string[2..$];","endif","return $string_utils:match(string, this.mail_lists, \"aliases\");"]},{"name":"expire_old_messages","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","if (!$perm_utils:controls(caller_perms(), this))","return E_PERM;","else","seq = this:expirable_msg_seq();","if (seq)","this:rm_message_seq(seq);","return this:expunge_rmm();","else","return 0;","endif","endif"]},{"name":"msg_full_text","owner":2,"perms":173,"preposition":-1,"code":["\":msg_full_text(@msg) => list of strings.\";","\"msg is a mail message (in the usual transmission format).\";","\"display_seq_full calls this to obtain the actual list of strings to display.\";","return player:msg_text(@args);","\"default is to leave it up to the player how s/he wants it to be displayed.\";"]},{"name":"@resend","owner":2,"perms":89,"preposition":-2,"code":["\"@resend <msg> [on *<recipient>] to <recipient> [<recipient>...]\";","set_task_perms(valid(caller_perms()) ? caller_perms() | player);","\"...\";","\"... parse command...\";","\"...\";","if (!(p = this:parse_mailread_cmd(verb, args, \"\", \"on\", 1)))","\"...lose...\";","return;","elseif ($seq_utils:size(sequence = p[2]) != 1)","player:notify(\"You can only resend *one* message at a time.\");","return;","elseif ((length(p[4]) < 2) || (p[4][1] != \"to\"))","player:notify(tostr(\"Usage:  \", verb, \" [<message>] [on <folder>] to <recip>...\"));","return;","endif","recips = {};","for rs in (listdelete(p[4], 1))","if ($mail_agent:match_failed(r = $mail_agent:match_recipient(rs), rs))","return;","endif","recips = {@recips, r};","endfor","this:set_current_folder(folder = p[1]);","\"...\";","\"... retrieve original message...\";","\"...\";","{msgnum, msgtxt} = folder:messages_in_seq(sequence)[1];","if (forward_style = this:mail_option(\"resend_forw\"))","\"...message will be from player...\";","pmh = $mail_agent:parse_misc_headers(msgtxt, \"Reply-To\", \"Original-Date\", \"Original-From\");","orig_from = pmh[3][3] || msgtxt[2];","else","\"...message will be from author...\";","pmh = $mail_agent:parse_misc_headers(msgtxt, \"Reply-To\", \"Original-Date\", \"Original-From\", \"Resent-By\", \"Resent-To\");","orig_from = pmh[3][3];","from = $mail_agent:parse_address_field(msgtxt[2])[1];","to = $mail_agent:parse_address_field(msgtxt[3]);","endif","\"...\";","\"... report bogus headers...\";","\"...\";","if (bogus = pmh[2])","player:notify(\"Bogus headers stripped from original message:\");","for b in (bogus)","player:notify(\"  \" + b);","endfor","if (!$command_utils:yes_or_no(\"Continue?\"))","player:notify(\"Message not resent.\");","return;","endif","endif","\"...\";","\"... subject, replyto, original-date, original-from ...\";","\"...\";","hdrs = {msgtxt[4], pmh[3][1], {\"Original-Date\", pmh[3][2] || ctime(msgtxt[1])}, @orig_from ? {{\"Original-From\", orig_from}} | {}, @pmh[1]};","\"...\";","\"... send it ...\";","\"...\";","if (forward_style)","result = $mail_agent:send_message(player, recips, hdrs, pmh[4]);","else","\"... resend inserts resent-to and resent-by...\";","result = $mail_agent:resend_message(player, recips, from, to, hdrs, pmh[4]);","endif","\"...\";","\"... report outcome...\";","\"...\";","if (!result)","player:notify(tostr(result));","elseif (result[1])","player:notify(tostr(\"Message \", msgnum, @(folder == this) ? {} | {\" on \", $mail_agent:name(folder)}, \" @resent to \", $mail_agent:name_list(@listdelete(result, 1)), \".\"));","else","player:notify(\"Message not resent.\");","endif"]},{"name":"make_current_message_new","owner":2,"perms":173,"preposition":-1,"code":["\":make_current_message(recipient[,index])\";","\"starts a new current_message record for recipient.\";","\"index, if given, indicates where recipient is to be\";","\"  placed (n = at or after nth entry in .current_message).\";","recip = args[1];","cm = this.current_message;","if (length(args) > 1)","i = max(2, min(args[2], length(cm)));","else","i = 0;","endif","if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))","raise(E_PERM);","elseif (recip == this)","\"...self...\";","elseif (j = $list_utils:iassoc(recip, cm))","\"...already present...\";","if (i)","if (j < i)","this.current_message = {@cm[1..j - 1], @cm[j + 1..i], cm[j], @cm[i + 1..$]};","elseif (j > (i + 1))","this.current_message = {@cm[1..i], cm[j], @cm[i + 1..j - 1], @cm[j + 1..$]};","endif","endif","else","this.current_message = listappend(cm, {recip, 0, 0}, @i ? {i} | {});","endif"]},{"name":"expirable_msg_seq","owner":2,"perms":173,"preposition":-1,"code":["\"Return a sequence indicating the expirable messages for this player.\";","set_task_perms(caller_perms());","if (!$perm_utils:controls(caller_perms(), this))","return E_PERM;","elseif (!(curmsg = this:get_current_message(this)))","\"No messages!  Don't even try.\";","return {};","elseif (0 >= (period = this:mail_option(\"expire\") || $mail_agent.player_expire_time))","\"...no expiration allowed here...\";","return {};","else","return $seq_utils:remove(this:unkept_msg_seq(), 1 + this:length_date_le(min(time() - period, curmsg[2] - 86400)));","\"... the 86400 is pure fudge...\";","endif"]},{"name":"format_for_netforward","owner":2,"perms":173,"preposition":-1,"code":["\"Takes a message sequence (the actual messages, not just the sequence describing it) and grovels over it filling text etc.  Returns a two valued list: {formatted message, header for same}\";","set_task_perms(caller_perms());","{message_seq, folderstr} = args;","netmail = {};","linelen = this:linelen();","maxmsg = minmsg = 0;","for msg in (message_seq)","minmsg = minmsg ? min(msg[1], minmsg) | msg[1];","maxmsg = maxmsg ? max(msg[1], maxmsg) | msg[1];","lines = {tostr(\"Message \", msg[1], folderstr, \":\"), tostr(\"Date:     \", ctime(msg[2][1])), \"From:     \" + msg[2][2], \"To:       \" + msg[2][3], @(length(subj = msg[2][4]) > 1) ? {\"Subject:  \" + subj} | {}};","for line in (msg[2][5..$])","if (typeof(line) != STR)","\"I don't know how this can happen, but apparently non-strings can end up in the mail message.  So, cope.\";","line = tostr(line);","endif","lines = {@lines, @$generic_editor:fill_string(line, linelen)};","$command_utils:suspend_if_needed(0);","endfor","netmail = {@netmail, @lines, \"\", \"--------------------------\", \"\", \"\"};","endfor","header = tostr($network.MOO_name, \" Message(s) \", minmsg, @(minmsg != maxmsg) ? {\" - \", maxmsg} | {}, folderstr);","return {netmail, header};"]},{"name":"format_for_netforward_debug","owner":2,"perms":173,"preposition":-1,"code":["\"Takes a message sequence (the actual messages, not just the sequence describing it) and grovels over it filling text etc.  Returns a two valued list: {formatted message, header for same}\";","set_task_perms(caller_perms());","{message_seq, folderstr} = args;","netmail = {};","linelen = this:linelen();","maxmsg = minmsg = 0;","for msg in (message_seq)","minmsg = minmsg ? min(msg[1], minmsg) | msg[1];","maxmsg = maxmsg ? max(msg[1], maxmsg) | msg[1];","lines = {tostr(\"Message \", msg[1], folderstr, \":\"), tostr(\"Date:     \", ctime(msg[2][1])), \"From:     \" + msg[2][2], \"To:       \" + msg[2][3], @(length(subj = msg[2][4]) > 1) ? {\"Subject:  \" + subj} | {}};","for line in (msg[2][5..$])","if (typeof(line) != STR)","\"I don't know how this can happen, but apparently non-strings can end up in the mail message.  So, cope.\";","line = tostr(line);","endif","lines = {@lines, @$generic_editor:fill_string(line, linelen)};","$command_utils:suspend_if_needed(0);","endfor","netmail = {@netmail, @lines, \"\", \"--------------------------\", \"\", \"\"};","endfor","header = tostr($network.MOO_name, \" Message(s) \", minmsg, @(minmsg != maxmsg) ? {\" - \", maxmsg} | {}, folderstr);","return {netmail, header};"]},{"name":"@nn","owner":2,"perms":13,"preposition":-1,"code":["\"@nn  -- reads the first new message on the first mail_recipient (in .current_message) where new mail exists.\";","set_task_perms(valid(cp = caller_perms()) ? cp | player);","cm = this.current_message;","cm[1..2] = {{this, @cm[1..2]}};","for n in (cm)","if ($mail_agent:is_recipient(n[1]))","if (new = n[1]:length_date_gt(n[3]))","next = (n[1]:length_all_msgs() - new) + 1;","this:set_current_folder(folder = n[1]);","this._mail_task = task_id();","cur = folder:display_seq_full({next, next + 1}, tostr(\"Message %d\", \" on \", $mail_agent:name(folder), \":\"));","this:set_current_message(folder, @cur);","return;","endif","else","player:notify(tostr(\"Bogus recipient \", n[1], \" removed from .current_message.\"));","this.current_message = setremove(this.current_message, n);","endif","endfor","player:tell(\"No News (is good news)\");"]},{"name":"@unread","owner":2,"perms":89,"preposition":-2,"code":["\"@unread <msg> [on *<recipient>]  -- resets last-read-date for recipient to just before the first of the indicated messages.\";","set_task_perms(player);","if (p = this:parse_mailread_cmd(\"@unread\", args, \"cur\", \"on\"))","this:set_current_folder(folder = p[1]);","msg_ord = $seq_utils:first(msg_seq = p[2]);","msgdate = folder:messages_in_seq(msg_ord)[2][1] - 1;","if ((!(cm = this:get_current_message(folder))) || (cm[2] < msgdate))","player:notify(\"Already unread.\");","else","if (folder == this)","this.current_message[2] = msgdate - 1;","else","this:kill_current_message(folder);","this:set_current_message(folder, cm[1], min(cm[2], msgdate));","endif","folder:display_seq_headers({msg_ord, msg_ord + 1}, cm[1], msgdate);","endif","endif"]},{"name":"@refile @copym*ail","owner":2,"perms":89,"preposition":-2,"code":["\"@refile/@copym*ail <msg-sequence> [on <recipient>] to <recipient>\";","\"@refile will delete the messages from the source folder.  @copym does not.\";","\"I'm not happy with this one, yet...\";","set_task_perms(player);","if (!(p = this:parse_mailread_cmd(\"@refile\", args, \"cur\", \"on\", 1)))","\"...lose...\";","elseif ((length(p[4]) != 2) || (p[4][1] != \"to\"))","player:notify(tostr(\"Usage:  \", verb, \" [<message numbers>] [on <folder>] to <folder>\"));","elseif ($mail_agent:match_failed(dest = $mail_agent:match_recipient(p[4][2]), p[4][2]))","\"...bogus destination folder...\";","else","source = p[1];","msg_seq = p[2];","for m in (source:messages_in_seq(msg_seq))","if (!(e = dest:receive_message(m[2], source)))","player:notify(tostr(\"Copying msg. \", m[1], \":  \", e));","return;","endif","$command_utils:suspend_if_needed(0);","endfor","if (refile = verb == \"@refile\")","if (typeof(e = source:rm_message_seq(msg_seq)) == ERR)","player:notify(tostr(\"Deleting from \", source, \":  \", e));","endif","endif","count = tostr(n = $seq_utils:size(msg_seq), \" message\", (n == 1) ? \"\" | \"s\");","fname = (source == this) ? \"\" | tostr(is_player(source) ? \" from \" | \" from *\", source.name, \"(\", source, \")\");","suffix = tostr(is_player(dest) ? \" to \" | \" to *\", dest.name, \"(\", dest, \").\");","player:notify(tostr(refile ? \"Refiled \" | \"Copied \", count, fname, suffix));","endif"]},{"name":"@quickr*eply @qreply","owner":2,"perms":89,"preposition":-2,"code":["\"@qreply <msg> [on *<recipient>] [<flags>...]\";","\"like @reply only, as in @qsend, we prompt for the message text using \";","\"$command_utils:read_lines() rather than invoking the $mail_editor.\";","set_task_perms(who = valid(cp = caller_perms()) ? cp | player);","if (!(p = this:parse_mailread_cmd(verb, args, \"cur\", \"on\", 1)))","\"...garbled...\";","elseif ($seq_utils:size(p[2]) != 1)","player:notify(\"You can only answer *one* message at a time.\");","elseif (LIST != typeof(flags_replytos = $mail_editor:check_answer_flags(\"noinclude\", @p[4])))","player:notify_lines({tostr(\"Usage:  \", verb, \" [message-# [on <recipient>]] [flags...]\"), \"where flags include any of:\", \"  all        reply to everyone\", \"  sender     reply to sender only\", tostr(\"  include    include the original message in reply (can't do this for \", verb, \")\"), \"  noinclude  don't include the original in your reply\"});","elseif (\"include\" in flags_replytos[1])","player:notify(tostr(\"Can't include message on a \", verb));","else","this:set_current_folder(p[1]);","if (to_subj = $mail_editor:parse_msg_headers(p[1]:messages_in_seq(p[2])[1][2], flags_replytos[1]))","player:notify(tostr(\"To:       \", $mail_agent:name_list(@to_subj[1])));","if (to_subj[2])","player:notify(tostr(\"Subject:  \", to_subj[2]));","endif","if (replytos = flags_replytos[2])","player:notify(tostr(\"Reply-to: \", $mail_agent:name_list(@replytos)));","endif","hdrs = {to_subj[2], replytos || {}};","player:notify(\"Enter lines of message:\");","message = $command_utils:read_lines_escape((active = player in $mail_editor.active) ? {} | {\"@edit\"}, {tostr(\"You are composing mail to \", $mail_agent:name_list(@to_subj[1]), \".\"), @active ? {} | {\"Type `@edit' to take this into the mail editor.\"}});","if (typeof(message) == ERR)","player:notify(tostr(message));","elseif (message[1] == \"@edit\")","$mail_editor:invoke(1, verb, to_subj[1], @hdrs, message[2]);","elseif (!message[2])","player:notify(\"Blank message not sent.\");","else","result = $mail_agent:send_message(this, to_subj[1], hdrs, message[2]);","if (result && result[1])","player:notify(tostr(\"Message sent to \", $mail_agent:name_list(@listdelete(result, 1)), \".\"));","else","player:notify(\"Message not sent.\");","endif","endif","endif","endif"]},{"name":"@mail-all-new*-mail","owner":2,"perms":13,"preposition":-1,"code":["\"@mail-all-new-mail\";","\" Prints headers for all new mail on every mail-recipient mentioned in .current_message.\";","set_task_perms(valid(cp = caller_perms()) ? cp | player);","cm = this.current_message;","cm[1..2] = {{this, @cm[1..2]}};","this._mail_task = task_id();","nomail = 1;","new_cms = {};","for f in (cm)","if (!($object_utils:isa(folder = f[1], $player) || $object_utils:isa(folder, $mail_recipient)))","player:notify(tostr(folder, \" is neither a $player nor a $mail_recipient\"));","elseif (typeof(flen = folder:length_all_msgs()) == ERR)","player:notify(tostr($mail_agent:name(folder), \" \", flen));","elseif (msg_seq = $seq_utils:range(folder:length_date_le(f[3]) + 1, flen))","nomail = 0;","player:notify(\"===== \" + $string_utils:left(tostr($mail_agent:name(folder), \" (\", s = $seq_utils:size(msg_seq), \" message\", (s == 1) ? \") \" | \"s) \"), 40, \"=\"));","folder:display_seq_headers(msg_seq, @f[2..3]);","player:notify(\"\");","$command_utils:suspend_if_needed(2);","endif","endfor","if (nomail)","player:notify(\"You don't have any new mail anywhere.\");","else","player:notify(\"===== \" + $string_utils:left(\"End of new mail \", 40, \"=\"));","endif"]},{"name":"@read-all-new*-mail @ranm","owner":2,"perms":29,"preposition":-1,"code":["\"@read-all-new-mail [yes]\";","\" Prints all new mail on every mail-recipient mentioned in .current_message\";","\" Generally this will spam you into next Tuesday.\";","\" You will be queried for whether you want your last-read dates updated\";","\"   but you can specify \\\"yes\\\" on the command line to suppress this.\";","\"   If you do so, last-read dates will be updated after each folder read.\";","set_task_perms(valid(cp = caller_perms()) ? cp | player);","noconfirm = args && (\"yes\" in args);","cm = this.current_message;","cm[1..2] = {{this, @cm[1..2]}};","this._mail_task = task_id();","nomail = 1;","new_cms = {};","for f in (cm)","if (!($object_utils:isa(folder = f[1], $player) || $object_utils:isa(folder, $mail_recipient)))","player:notify(tostr(folder, \" is neither a $player nor a $mail_recipient\"));","elseif (typeof(flen = folder:length_all_msgs()) == ERR)","player:notify(tostr($mail_agent:name(folder), \" \", flen));","elseif (msg_seq = $seq_utils:range(folder:length_date_le(f[3]) + 1, flen))","nomail = 0;","player:notify(\"===== \" + $string_utils:left(tostr($mail_agent:name(folder), \" (\", s = $seq_utils:size(msg_seq), \" message\", (s == 1) ? \") \" | \"s) \"), 40, \"=\"));","player:notify(\"\");","if (cur = folder:display_seq_full(msg_seq, tostr(\"Message %d\", (folder == this) ? \"\" | (\" on \" + $mail_agent:name(folder)), \":\")))","if (noconfirm)","this:set_current_message(folder, @cur);","this:set_current_folder(folder);","else","new_cms = {@new_cms, {folder, @cur}};","endif","player:notify(\"\");","endif","endif","$command_utils:suspend_if_needed(1);","this._mail_task = task_id();","endfor","if (nomail)","player:notify(\"You don't have any new mail anywhere.\");","elseif (player:notify(\"===== \" + $string_utils:left(\"End of new mail \", 40, \"=\")) || (noconfirm || $command_utils:yes_or_no(\"Did you get all of that?\")))","for n in (new_cms)","this:set_current_message(@n);","this:set_current_folder(n[1]);","endfor","player:notify(\"Last-read-dates updated\");","else","player:notify(\"Last-read-dates not updated\");","endif"]},{"name":"@quick*send @qsend","owner":2,"perms":89,"preposition":-2,"code":["\"Syntax: @quicksend <recipients(s)> [subj=<text>] [<message>]\";","\"Sends the recipients(s) a quick message, wit{out having to go to the mailroom. If there is more than one recipients, place them all in quotes. If the subj contains spaces, place it in quotes.\";","\"To put line breaks in the message, use a caret (^).\";","\"If no message is given, prompt for lines of message.\";","\"Examples:\";","\"@quicksend Alice subj=\\\"Wonderland is neat!\\\" Have you checked out the Wonderland scenario yet? I think you'd like it!\";","\"@quicksend \\\"Ethel Fred\\\" Have you seen Lucy around?^--Ricky\";","set_task_perms($object_utils:isa(player, $guest) ? player.owner | player);","if (!args)","player:notify(tostr(\"Usage: \", verb, \" <recipients(s)> [subj=<text>] [<message>]\"));","return E_INVARG;","elseif (this != player)","player:notify(tostr(\"You can't use \", this.pp, \" @quicksend verb.\"));","return E_PERM;","elseif (!(recipients = $mail_editor:parse_recipients({}, $string_utils:explode(args[1]))))","return;","else","if ((length(args) > 1) && ((eq = index(args[2], \"=\")) && (index(\"subject\", args[2][1..eq - 1]) == 1)))","subject = $string_utils:trim(args[2][eq + 1..$]);","ws = $string_utils:word_start(argstr);","argstr = argstr[1..ws[1][2]] + argstr[ws[2][2] + 1..$];","args = listdelete(args, 2);","else","subject = \"\";","endif","if (length(args) > 1)","unbroken = argstr[(argstr[1] == \"\\\"\") ? length(args[1]) + 4 | (length(args[1]) + 2)..$] + \"^\";","message = {};","while (unbroken)","if (i = index(unbroken, \"^\"))","message = {@message, unbroken[1..i - 1]};","endif","unbroken = unbroken[i + 1..$];","endwhile","else","if (!(subject || player:mail_option(\"nosubject\")))","player:notify(\"Subject:\");","subject = $command_utils:read();","endif","player:notify(\"Enter lines of message:\");","message = $command_utils:read_lines_escape((active = player in $mail_editor.active) ? {} | {\"@edit\"}, {tostr(\"You are composing mail to \", $mail_agent:name_list(@recipients), \".\"), @active ? {} | {\"Type `@edit' to take this into the mail editor.\"}});","if (typeof(message) == ERR)","player:notify(tostr(message));","return;","elseif (message[1] == \"@edit\")","$mail_editor:invoke(1, verb, recipients, subject, {}, message[2]);","return;","elseif (!(message[2] || subject))","player:notify(\"Blank message not sent.\");","return;","endif","message = message[2];","endif","result = $mail_agent:send_message(this, recipients, subject, message);","if (result && result[1])","player:notify(tostr(\"Message sent to \", $mail_agent:name_list(@listdelete(result, 1)), \".\"));","else","player:notify(\"Message not sent.\");","endif","endif"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","pass();","this.mail_options = {};","endif"]},{"name":"confunc","owner":2,"perms":173,"preposition":-1,"code":["if (((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (caller != #0))","return E_PERM;","endif","nm = this:length_all_msgs() - this:length_date_le(this:get_current_message()[2]);","if (nm)","this:notify(tostr(\"You have new mail (\", nm, \" message\", (nm == 1) ? \"\" | \"s\", \").\", this:mail_option(\"expert\") ? \"\" | \"  Type 'help mail' for info on reading it.\"));","endif","this:mail_catch_up();","this:check_mail_lists();","pass(@args);"]},{"name":"@add-notify","owner":2,"perms":89,"preposition":1,"code":["\"Ideally, in order for one person to be notified that another person has new mail, both the mail recipient and the notification recipient should agree that this is an OK transfer of information.\";","\"Usage:  @add-notify me to player\";","\"    Sends mail to player saying that I want to be added to their mail notification property.\";","\"Usage:  @add-notify player to me\";","\"    Makes sure that player wants to be notified, if so, adds them to my .mail_notify property.  (Deletes from temporary record.)\";","if (this == dobj)","target = $string_utils:match_player(iobjstr);","if ($command_utils:player_match_failed(target, iobjstr))","return;","elseif (this in target.mail_notify[1])","player:tell(\"You already receive notifications when \", target.name, \" receives mail.\");","elseif (this in target.mail_notify[2])","player:tell(\"You already asked to be notified when \", target.name, \" receives mail.\");","else","$mail_agent:send_message(player, {target}, \"mail notification request\", {tostr($string_utils:nn(this), \" would like to receive mail notifications when you get mail.\"), \"Please type:\", tostr(\"  @add-notify \", this.name, \" to me\"), \"if you wish to allow this action.\"});","player:tell(\"Notifying \", $string_utils:nn(target), \" that you would like to be notified when \", target.ps, \" receives mail.\");","target.mail_notify[2] = setadd(target.mail_notify[2], this);","endif","elseif (this == iobj)","target = $string_utils:match_player(dobjstr);","if ($command_utils:player_match_failed(target, dobjstr))","return;","elseif (target in this.mail_notify[2])","this.mail_notify[1] = setadd(this.mail_notify[1], target);","this.mail_notify[2] = setremove(this.mail_notify[2], target);","player:tell(target.name, \" will be notified when you receive mail.\");","else","player:tell(\"It doesn't look like \", target.name, \" wants to be notified when you receive mail.\");","endif","else","player:tell(\"Usage:  @add-notify me to player\");","player:tell(\"        @add-notify player to me\");","endif"]},{"name":"mail_notify","owner":2,"perms":173,"preposition":-1,"code":["if ((length(this.mail_notify) > 0) && (typeof(this.mail_notify[1]) == LIST))","return this.mail_notify[1];","else","return this.mail_notify;","endif"]},{"name":"set","owner":2,"perms":173,"preposition":-1,"code":["\"$gender_utils:set(object,gender) --- sets the pronoun properties of object.\";","\"gender is a string: one of the strings in $gender_utils.genders, the list of rcognized genders.  If the gender change is successful, the (full) name of the gender (e.g., \\\"male\\\") is returned.  E_NONE is returned if gender does not match any recognized gender.  Any other error encountered (e.g., E_PERM, E_PROPNF) is likewise returned and the object's pronoun properties are left unaltered.\";","set_task_perms(caller_perms());","{object, gender} = args;","if (this == object)","return E_DIV;","elseif (gnum = $string_utils:find_prefix(gender, this.genders))","gender = this.genders[gnum];","else","return E_NONE;","endif","save = {};","prons = this.pronouns;","for p in (prons)","save = {@save, e = `object.(p) ! ANY'};","if ((typeof(e) != STR) || (typeof(e = `object.(p) = this.(p)[gnum] ! ANY') == ERR))","for i in [1..length(save) - 1]","object.(prons[i]) = save[i];","endfor","return e;","endif","endfor","return gender;"]},{"name":"add","owner":2,"perms":173,"preposition":-1,"code":["\"$gender_utils:add(object[,perms[,owner]])\";","\"--- adds pronoun properties to object if they're not already there.\";","\"    perms default to \\\"rc\\\", owner defaults to the object owner.\";","set_task_perms(caller_perms());","{object, ?perms = \"rc\", ?owner = object.owner} = args;","prons = this.pronouns;","e = 1;","for p in (prons)","if (!$object_utils:has_property(object, p))","e = `add_property(object, p, \"\", {owner, perms}) ! ANY';","if (typeof(e) == ERR)","player:tell(\"Couldn't add \", object, \".\", p, \":  \", e);","return;","endif","elseif ((typeof(object.(p)) != STR) && (typeof(e = `object.(p) = \"\" ! ANY') == ERR))","player:tell(\"Couldn't reset \", object, \".\", p, \":  \", e);","return;","elseif (!object.(p))","e = 0;","endif","endfor","if ((!e) && (ERR == typeof(e = this:set(object, \"neuter\"))))","player:tell(\"Couldn't initialize pronouns:  \", e);","endif"]},{"name":"get_pronoun","owner":36,"perms":173,"preposition":-1,"code":["\"get_pronoun(key,object) => pronoun corresponding to object.\";","\"key can be one of s,o,p,q,r,S,O,P,Q,R to refer to the pronoun properties relatively directly or it can be something of the form \\\"he/she\\\" or \\\"He/She\\\".\";","\"Next the object is checked for the desired pronoun property.  If that doesn't exist, we look at object.gender and infer the pronoun from the corresponding $gender_utils property.  If .gender doesn't exist or the object itself is invalid, we use the corresponding property on $player.\";","{key, ?object = player} = args;","if (key[1] == \":\")","key = key[2..$];","endif","if ((length(key) == 1) && (i = index(\"sopqrSOPQR\", key, 1)))","prop = this.pronouns[i];","else","search = \"$1:he$s:she$1:he/she$2:him$2:him/her$3:his/her$4:hers$4:his/hers$5:himself$5:herself$5:himself/herself\";","i = index(search, (\":\" + key) + \"$\");","if (!i)","return \"\";","endif","cap = strcmp(\"a\", key) > 0;","prop = this.pronouns[toint(search[i - 1]) + (5 * cap)];","endif","if (!valid(object))","return $player.(prop);","elseif (STR == typeof(p = `object.(prop) ! ANY'))","return p;","elseif ((STR == typeof(g = `object.gender ! ANY')) && (i = g in this.genders))","return this.(prop)[i];","else","return $player.(prop);","endif"]},{"name":"get_conj*ugation","owner":36,"perms":173,"preposition":-1,"code":["\"get_conj(verbspec,object) => verb conjugated according to object.\";","\"verbspec can be one of \\\"singular/plural\\\", \\\"singular\\\", \\\"singular/\\\", or \\\"/plural\\\", e.g., \\\"is/are\\\", \\\"is\\\", \\\"is/\\\", or \\\"/are\\\".\";","\"The object is checked to see whether it is singular or plural.  This is inferred from its .gender property.  If .gender doesn't exist or the object itself is invalid, we assume singular.\";","{spec, ?object = player} = args;","i = index(spec + \"/\", \"/\");","sing = spec[1..i - 1];","if (i < length(spec))","plur = spec[i + 1..$];","else","plur = \"\";","endif","cap = strcmp(\"a\", (i == 1) ? spec[2] | spec) > 0;","if (((valid(object) && (STR == typeof(g = `object.gender ! ANY'))) && (i = g in this.genders)) && this.is_plural[i])","vb = plur || this:_verb_plural(sing, i);","else","vb = sing || this:_verb_singular(plur, i);","endif","if (cap)","return $string_utils:capitalize(vb);","else","return vb;","endif"]},{"name":"_verb_plural","owner":36,"perms":173,"preposition":-1,"code":["{st, idx} = args;","if (typeof(st) != STR)","return E_INVARG;","endif","len = length(st);","if ((len >= 3) && (rindex(st, \"n't\") == (len - 2)))","return this:_verb_plural(st[1..len - 3], idx) + \"n't\";","elseif (i = st in {\"has\", \"is\"})","return this.({\"have\", \"be\"}[i])[idx];","elseif (st == \"was\")","return (idx > 6) ? \"were\" | st;","elseif ((len <= 3) || (st[len] != \"s\"))","return st;","elseif (st[len - 1] != \"e\")","return st[1..len - 1];","\"elseif ((r = (rindex(st, \\\"sses\\\") || rindex(st, \\\"zzes\\\"))) && (r == (len - 3)))\";","elseif ((r = rindex(st, \"zzes\")) && (r == (len - 3)))","return st[1..len - 3];","elseif ((((st[len - 2] == \"h\") && index(\"cs\", st[len - 3])) || index(\"ox\", st[len - 2])) || (st[len - 3..len - 2] == \"ss\"))","return st[1..len - 2];","\"washes => wash, belches => belch, boxes => box\";","\"used to have || ((st[len - 2] == \\\"s\\\") && (!index(\\\"aeiouy\\\", st[len - 3])))\";","\"so that <consonant>ses => <consonant>s\";","\"known examples: none\";","\"counterexample: browses => browse\";","\"update of sorts--put in code to handle passes => pass\";","elseif (st[len - 2] == \"i\")","return st[1..len - 3] + \"y\";","else","return st[1..len - 1];","endif"]},{"name":"_verb_singular","owner":36,"perms":173,"preposition":-1,"code":["{st, idx} = args;","if (typeof(st) != STR)","return E_INVARG;","endif","len = length(st);","if ((len >= 3) && (rindex(st, \"n't\") == (len - 2)))","return this:_verb_singular(st[1..len - 3], idx) + \"n't\";","elseif (i = st in {\"have\", \"are\"})","return this.({\"have\", \"be\"}[i])[idx];","elseif ((st[len] == \"y\") && (!index(\"aeiou\", st[len - 1])))","return st[1..len - 1] + \"ies\";","elseif (index(\"sz\", st[len]) && index(\"aeiou\", st[len - 1]))","return (st + st[len]) + \"es\";","elseif (index(\"osx\", st[len]) || ((len > 1) && (index(\"chsh\", st[len - 1..len]) % 2)))","return st + \"es\";","else","return st + \"s\";","endif"]},{"name":"_do","owner":36,"perms":173,"preposition":-1,"code":["\"_do(cap,object,modifiers...)\";","{cap, object, modifiers} = args;","if (!modifiers)","if (typeof(object) != OBJ)","return tostr(object);","elseif (!valid(object))","return (cap ? \"N\" | \"n\") + \"othing\";","else","return cap ? object:titlec() | object:title();","endif","elseif (modifiers[1] == \".\")","if (i = index(modifiers[2..$], \".\"))","i = i + 1;","elseif (!(i = (index(modifiers, \":\") || index(modifiers, \"#\")) || index(modifiers, \"!\")))","i = length(modifiers) + 1;","endif","if (typeof(o = `object.(modifiers[2..i - 1]) ! ANY') == ERR)","return tostr(\"%(\", o, \")\");","else","return this:_do(cap || (strcmp(\"a\", modifiers[2]) > 0), o, modifiers[i..$]);","endif","elseif (modifiers[1] == \":\")","if (typeof(object) != OBJ)","return tostr(\"%(\", E_TYPE, \")\");","elseif (p = this:get_pronoun(modifiers, object))","return p;","else","return tostr(\"%(\", modifiers, \"??)\");","endif","elseif (modifiers[1] == \"#\")","return tostr(object);","elseif (modifiers[1] == \"!\")","return this:get_conj(modifiers[2..$], object);","else","i = (((index(modifiers, \".\") || index(modifiers, \":\")) || index(modifiers, \"#\")) || index(modifiers, \"!\")) || (length(modifiers) + 1);","s = modifiers[1..i - 1];","if (j = s in {\"dobj\", \"iobj\", \"this\"})","return this:_do(cap, {dobj, iobj, callers()[2][1]}[j], modifiers[i..$]);","else","return tostr(\"%(\", s, \"??)\");","endif","endif"]},{"name":"pronoun_sub","owner":2,"perms":173,"preposition":-1,"code":["\"Experimental pronoun substitution. The official version is on $string_utils.\";","\"syntax:  :pronoun_sub(text[,who])\";","\"experimental version that accomodates Aladdin's style...\";","set_task_perms($no_one);","{old, ?who = player} = args;","if (typeof(old) == LIST)","plines = {};","for line in (old)","plines = {@plines, this:pronoun_sub(line, who)};","endfor","return plines;","endif","new = \"\";","here = valid(who) ? who.location | $nothing;","objspec = \"nditl\";","objects = {who, dobj, iobj, caller, here};","prnspec = \"sopqrSOPQR\";","prprops = {\"ps\", \"po\", \"pp\", \"pq\", \"pr\", \"Ps\", \"Po\", \"Pp\", \"Pq\", \"Pr\"};","oldlen = length(old);","while ((prcnt = index(old, \"%\")) && (prcnt < oldlen))","cp_args = {};","s = old[k = prcnt + 1];","if (brace = index(\"([{\", s))","if (!(w = index(old[k + 1..oldlen], \")]}\"[brace])))","return new + old;","elseif (brace == 3)","s = this:_do(0, who, old[prcnt + 2..(k = k + w) - 1]);","else","p = old[prcnt + 2..(k = k + w) - 1];","if (brace == 1)","cp_args = {who, p};","elseif (p[1] == \"#\")","s = (o = index(objspec, p[2])) ? tostr(objects[o]) | ((\"[\" + p) + \"]\");","elseif (!(o = index(objspec, p[1])))","s = (\"[\" + p) + \"]\";","else","cp_args = {objects[o], p[2..w - 1], strcmp(p[1], \"a\") < 0};","endif","endif","elseif (o = index(objspec, s))","cp_args = {objects[o], \"\", strcmp(s, \"a\") < 0};","elseif (w = index(prnspec, s, 1))","cp_args = {who, prprops[w]};","elseif (s == \"#\")","s = tostr(who);","elseif (s != \"%\")","s = \"%\" + s;","endif","new = (new + old[1..prcnt - 1]) + ((!cp_args) ? s | ((typeof(sub = $string_utils:_cap_property(@cp_args)) != ERR) ? sub | ((\"%(\" + tostr(sub)) + \")\")));","old = old[k + 1..oldlen];","oldlen = oldlen - k;","endwhile","return new + old;"]},{"name":"controls","owner":2,"perms":173,"preposition":-1,"code":["\"$perm_utils:controls(who, what)\";","\"Is WHO allowed to hack on WHAT?\";","return (args[1] == args[2].owner) || args[1].wizard;"]},{"name":"apply","owner":36,"perms":173,"preposition":-1,"code":["\":apply(permstring,mods) => new permstring.\";","\"permstring is a permissions string, mods is a concatenation of strings of the form +<letters>, !<letters>, or -<letters>, where <letters> is a string of letters as might appear in a permissions string (`+' adds the specified permissions, `-' or `!' removes them; `-' and `!' are entirely equivalent).\";","{perms, mods} = args;","if ((!mods) || (!index(\"!-+\", mods[1])))","return mods;","endif","i = 1;","while (i <= length(mods))","if (mods[i] == \"+\")","while (((i = i + 1) <= length(mods)) && (!index(\"!-+\", mods[i])))","if (!index(perms, mods[i]))","perms = perms + mods[i];","endif","endwhile","else","\"mods[i] must be ! or -\";","while (((i = i + 1) <= length(mods)) && (!index(\"!-+\", mods[i])))","perms = strsub(perms, mods[i], \"\");","endwhile","endif","endwhile","return perms;"]},{"name":"caller","owner":2,"perms":173,"preposition":-1,"code":["\":caller([include line numbers])\";","\"  -- returns the first caller in the callers() stack distinct from `this'\";","{?lineno = 0} = args;","c = callers(lineno);","{stage, lc, nono} = {1, length(c), {c[1][1], $nothing}};","while (((stage = stage + 1) <= lc) && (c[stage][1] in nono))","endwhile","return c[stage];"]},{"name":"controls_prop*erty controls_verb","owner":2,"perms":173,"preposition":-1,"code":["\"Syntax:  controls_prop(OBJ who, OBJ what, STR propname)   => 0 | 1\";","\"         controls_verb(OBJ who, OBJ what, STR verbname)   => 0 | 1\";","\"\";","\"Is WHO allowed to hack on WHAT's PROPNAME? Or VERBNAME?\";","{who, what, name} = args;","bi = (verb == \"controls_verb\") ? \"verb_info\" | \"property_info\";","return who.wizard || (who == call_function(bi, what, name)[1]);"]},{"name":"_chparent","owner":2,"perms":173,"preposition":-1,"code":["\"chparent(object, new-parent) -- see help on the builtin\";","who = caller_perms();","{what, papa} = args;","if (typeof(what) != OBJ)","retval = E_TYPE;","elseif (!valid(what))","retval = E_INVARG;","elseif (typeof(papa) != OBJ)","retval = E_TYPE;","elseif ((!valid(papa)) && (papa != #-1))","retval = E_INVARG;","elseif (!this:controls(who, what))","retval = E_PERM;","elseif ((is_player(what) && (!$object_utils:isa(papa, $player_class))) && (!who.wizard))","retval = E_PERM;","elseif ((is_player(what) && (!$object_utils:isa(what, $player_class))) && (!who.wizard))","retval = E_PERM;","elseif ((!valid(papa)) || (this:controls(who, papa) || papa.f))","retval = `chparent(@args) ! ANY';","else","retval = E_PERM;","endif","return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;"]},{"name":"day","owner":36,"perms":13,"preposition":-1,"code":["\"Given a time() or ctime()-style date, this returns the full name of the day.\";","if (typeof(args[1]) == INT)","time = ctime(args[1]);","elseif (typeof(args[1]) == STR)","time = args[1];","else","return E_TYPE;","endif","dayabbr = $string_utils:explode(time)[1];","return this.days[dayabbr in this.dayabbrs];"]},{"name":"month","owner":36,"perms":13,"preposition":-1,"code":["\"Given a time() or ctime()-style date, this returns the full name\";","\"of the month.\";","if (typeof(args[1]) == INT)","time = ctime(args[1]);","elseif (typeof(args[1]) == STR)","time = args[1];","else","return E_TYPE;","endif","monthabbr = $string_utils:explode(time)[2];","return this.months[monthabbr in this.monthabbrs];"]},{"name":"ampm","owner":36,"perms":13,"preposition":-1,"code":["\"Return a time in the form [h]h[:mm[:ss]] {a.m.|p.m.}.  Args are\";","\"[1]   either a time()- or a ctime()-style date, and\";","\"[2]   (optional) the precision desired--1 for hours, 2 for minutes,\";","\"        3 for seconds.  If not given, precision defaults to minutes\";","{time, ?precision = 2} = args;","if (typeof(time) == INT)","time = ctime(time);","elseif (typeof(time) != STR)","return E_TYPE;","endif","time = $string_utils:explode(time)[4];","hour = toint(time[1..2]);","if (hour == 0)","time = (\"12\" + time[3..(precision * 3) - 1]) + \" a.m.\";","elseif (hour == 12)","time = time[1..(precision * 3) - 1] + \" p.m.\";","elseif (hour > 12)","time = (tostr(hour - 12) + time[3..(precision * 3) - 1]) + \" p.m.\";","else","time = (tostr(hour) + time[3..(precision * 3) - 1]) + \" a.m.\";","endif","return time;"]},{"name":"to_seconds","owner":36,"perms":173,"preposition":-1,"code":["\"Given string hh:mm:ss ($string_utils:explode(ctime(time))[4]), this returns\";","\"the number of seconds elapsed since 00:00:00.  I can't remember why I\";","\"created this verb, but I'm sure it serves some useful purpose.\";","return (((60 * 60) * toint(args[1][1..2])) + (60 * toint(args[1][4..5]))) + toint(args[1][7..8]);"]},{"name":"sun","owner":36,"perms":173,"preposition":-1,"code":["{?time = time()} = args;","r = 10000;","h = (r * r) + (r / 2);","t = ((time + 120) % 86400) / 240;","s = (5 * ((time - 14957676) % 31556952)) / 438291;","phi = (s + t) + this.corr;","cs = $trig_utils:cos(s);","spss = ((($trig_utils:sin(phi) * $trig_utils:sin(s)) + h) / r) - r;","cpcs = ((($trig_utils:cos(phi) * cs) + h) / r) - r;","return (((((this.stsd * cs) - (this.ctcd * cpcs)) - (this.ct * spss)) + h) / r) - r;"]},{"name":"from_ctime","owner":36,"perms":173,"preposition":-1,"code":["\"Given a string such as returned by ctime(), return the corresponding time-in-seconds-since-1970 time returned by time(), or E_DIV if the format is wrong in some essential way.\";","words = $string_utils:explode(args[1]);","if (length(words) == 5)","\"Arrgh!  the old ctime() didn't return a time zone, yet it arbitrarily decides whether it's standard or daylight savings time.  URK!!!!!\";","words = listappend(words, \"PST\");","endif","if ((((length(words) != 6) || (length(hms = $string_utils:explode(words[4], \":\")) != 3)) || (!(month = words[2] in this.monthabbrs))) || (!(zone = $list_utils:assoc(words[6], this.timezones))))","return E_DIV;","endif","year = toint(words[5]);","day = ({-1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334}[month] + toint(words[3])) + (year * 366);","zone = zone[2];","return (((((((((((((day - ((day + 1038) / 1464)) - ((day + 672) / 1464)) - ((day + 306) / 1464)) - ((day + 109740) / 146400)) - ((day + 73140) / 146400)) - ((day + 36540) / 146400)) - 719528) * 24) + toint(hms[1])) + zone) * 60) + toint(hms[2])) * 60) + toint(hms[3]);"]},{"name":"dhms dayshoursminutesseconds","owner":36,"perms":173,"preposition":-1,"code":["s = args[1];","if (s < 0)","return \"-\" + this:(verb)(-s);","endif","m = s / 60;","s = s % 60;","if (m)","ss = tostr((s < 10) ? \":0\" | \":\", s);","h = m / 60;","m = m % 60;","if (h)","ss = tostr((m < 10) ? \":0\" | \":\", m, ss);","d = h / 24;","h = h % 24;","return tostr(@d ? {d, (h < 10) ? \":0\" | \":\"} | {}, h, ss);","else","return tostr(m, ss);","endif","else","return tostr(s);","endif"]},{"name":"english_time","owner":36,"perms":173,"preposition":-1,"code":["\"english_time(time [,reference time]): returns the time as a string of\";","\"years, months, days, hours, minutes and seconds using the reference time as\";","\"the start time and incrementing forwards. it can be given in either ctime()\";","\"or time() format. if a reference time is not given, it is set to time().\";","{_time, ?reftime = time()} = args;","if (_time < 1)","return \"0 seconds\";","endif","_ctime = (typeof(reftime) == INT) ? ctime(reftime) | reftime;","seclist = {60, 60, 24};","units = {\"year\", \"month\", \"day\", \"hour\", \"minute\", \"second\"};","timelist = {};","for unit in (seclist)","timelist = {_time % unit, @timelist};","_time = _time / unit;","endfor","months = 0;","month = _ctime[5..7] in $time_utils.monthabbrs;","year = toint(_ctime[21..24]);","\"attribution: the algorithm used is from the eminently eminent g7.\";","while (_time >= (days = this.monthlens[month] + (((month == 2) && ((year % 4) == 0)) && (!((year % 400) in {100, 200, 300})))))","_time = _time - days;","months = months + 1;","if ((month = month + 1) > 12)","year = year + 1;","month = 1;","endif","$command_utils:suspend_if_needed(0);","endwhile","timelist = {months / 12, months % 12, _time, @timelist};","for unit in (units)","i = unit in units;","if (timelist[i] > 0)","units[i] = ((tostr(timelist[i]) + \" \") + units[i]) + ((timelist[i] == 1) ? \"\" | \"s\");","else","units = listdelete(units, i);","timelist = listdelete(timelist, i);","endif","endfor","return $string_utils:english_list(units);"]},{"name":"from_day","owner":36,"perms":173,"preposition":-1,"code":["\"from_day(day_of_week,which)\";","\"numeric time (seconds since 1970) corresponding to midnight (PST) of the given weekday.  Use either the name of the day or a 1..7 number (1==Sunday,...)\";","\"  which==-1 => use most recent such day.\";","\"  which==+1 => use first upcoming such day.\";","\"  which==0  => use closest such day.\";","\"larger (absolute) values for which specify a certain number of weeks into the future or past.\";","{day, ?dir = 0} = args;","if (!(toint(day) || (day = $string_utils:find_prefix(day, this.days))))","return E_DIV;","endif","delta = {288000, 374400, 460800, 547200, 28800, 115200, 201600}[toint(day)];","time = time() - delta;","if (dir)","time = (time / 604800) + ((dir > 0) ? dir | (dir + 1));","else","time = (time + 302400) / 604800;","endif","return (time * 604800) + delta;"]},{"name":"from_month","owner":36,"perms":173,"preposition":-1,"code":["\"from_month(month,which[,d])\";","\"numeric time (seconds since 1970) corresponding to midnight (PST) of the dth (first) day of the given month.  Use either the month name or a 1..12 number (1==January,...)\";","\"  which==-1 => use most recent such month.\";","\"  which==+1 => use first upcoming such month.\";","\"  which==0  => use closest such month.\";","\"larger (absolute) values for which specify a certain number of years into the future or past.\";","{month, ?dir = 0, ?dth = 1} = args;","if (!(toint(month) || (month = $string_utils:find_prefix(month, this.months))))","return E_DIV;","endif","delta = ({0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334}[month] + dth) - 1;","day = (time() - 28800) / 86400;","day = (day - ((day + 672) / 1461)) - delta;","if (dir)","day = ((day / 365) + dir) + (dir <= 0);","else","day = ((2 * day) + 365) / 730;","endif","day = (day * 365) + delta;","day = day + ((day + 671) / 1460);","return (day * 86400) + 28800;"]},{"name":"dst_midnight","owner":36,"perms":173,"preposition":-1,"code":["\"Takes a time that is midnight PST and converts it to the nearest PDT midnight time if it's during that part of the year where we use PDT.\";","time = args[1];","return time - (3600 * (((toint(ctime(time)[12..13]) + 12) % 24) - 12));"]},{"name":"time_sub","owner":36,"perms":173,"preposition":-1,"code":["\"Works like pronoun substitution, but substitutes time stuff.\";","\"Call with time_sub(string, time). returns a string.\";","\"time is an optional integer in time() format.  If omitted, time() is used.\";","\"Macros which are unknown are ignored. $Q -> the empty string.\";","\"Terminal $ are ignored.\";","\"$H -> hour #. $M -> min #. $S -> second #. 24-hour format, fixed width.\";","\"$h, $m, $s same x/c have not-fixed format. 00:03:24 vs. 0:3:24\";","\"$O/$o -> numeric hour in 12-hour format.\";","\"$D -> long day name. $d -> short day name.\";","\"$N -> long month name. $n -> short month name.\";","\"$Y -> long year # (e.g. '1991'). $y -> short year # (e.g. '91')\";","\"$Z -> the time zone    (added in by r'm later)\";","\"$P/$p -> AM/PM, or am/pm.\";","\"$T -> date number. $t -> date number with no extra whitespace etc.\";","\"$1 -> Month in fixed-width numeric format (01-12)   (added by dpk)\";","\"$2 -> Month in nonfixed numeric format (1-12)\";","\"$3 -> Date in fixed-width format, 0-fill\";","\"$$ -> $.\";","\"\";","\"This verb stolen from Ozymandias's #4835:time_subst.\";","res = \"\";","{thestr, ?thetime = time()} = args;","if ((typeof(thestr) != STR) || (typeof(thetime) != INT))","player:tell(\"Bad arguments to time_subst.\");","return;","endif","itslength = length(thestr);","if (!itslength)","return \"\";","endif","done = 0;","cctime = ctime(thetime);","while (dollar = index(thestr, \"$\"))","res = res + thestr[1..dollar - 1];","if (dollar == length(thestr))","return res;","endif","thechar = thestr[dollar + 1];","thestr[1..dollar + 1] = \"\";","if (thechar == \"$\")","res = res + \"$\";","elseif (!strcmp(thechar, \"h\"))","res = res + $string_utils:trim(tostr(toint(cctime[12..13])));","elseif (thechar == \"H\")","res = res + cctime[12..13];","elseif (!strcmp(thechar, \"m\"))","res = res + $string_utils:trim(tostr(toint(cctime[15..16])));","elseif (thechar == \"M\")","res = res + cctime[15..16];","elseif (!strcmp(thechar, \"s\"))","res = res + $string_utils:trim(tostr(toint(cctime[18..19])));","elseif (thechar == \"S\")","res = res + cctime[18..19];","elseif (!strcmp(thechar, \"D\"))","res = res + $time_utils:day(thetime);","elseif (thechar == \"d\")","res = res + cctime[1..3];","elseif (!strcmp(thechar, \"N\"))","res = res + $time_utils:month(thetime);","elseif (thechar == \"n\")","res = res + cctime[5..7];","elseif (!strcmp(thechar, \"T\"))","res = res + cctime[9..10];","elseif (thechar == \"t\")","res = res + $string_utils:trim(cctime[9..10]);","elseif (thechar == \"O\")","res = res + tostr(((toint(cctime[12..13]) + 11) % 12) + 1);","elseif (!strcmp(thechar, \"p\"))","res = res + ((toint(cctime[12..13]) >= 12) ? \"pm\" | \"am\");","elseif (thechar == \"P\")","res = res + ((toint(cctime[12..13]) >= 12) ? \"PM\" | \"AM\");","elseif (!strcmp(thechar, \"y\"))","res = res + cctime[23..24];","elseif (thechar == \"Y\")","res = res + cctime[21..24];","elseif (thechar == \"Z\")","res = res + cctime[26..28];","elseif (thechar == \"1\")","res = res + $string_utils:right(tostr($string_utils:explode(cctime)[2] in this.monthabbrs), 2, \"0\");","elseif (thechar == \"2\")","res = res + tostr($string_utils:explode(cctime)[2] in this.monthabbrs);","elseif (thechar == \"3\")","res = res + $string_utils:subst(cctime[9..10], {{\" \", \"0\"}});","endif","endwhile","return res + thestr;"]},{"name":"mmddyy ddmmyy","owner":36,"perms":173,"preposition":-1,"code":["\"Copied from Archer (#52775):mmddyy Tue Apr  6 17:04:26 1993 PDT\";","\"Given a time() or ctime()-style date and an optional separator, this returns the MM/DD/YY or DD/MM/YY form of the date (depending on the verb called.)  The default seperator is '/'\";","{time, ?divstr = \"/\"} = args;","if (typeof(time) == INT)","time = ctime(time);","elseif (typeof(time) != STR)","return E_TYPE;","endif","date = $string_utils:explode(time);","day = toint(date[3]);","month = date[2] in $time_utils.monthabbrs;","year = date[5];","daystr = (day < 10) ? \"0\" + tostr(day) | tostr(day);","monthstr = (month < 10) ? \"0\" + tostr(month) | tostr(month);","yearstr = tostr(year)[3..4];","if (verb == \"mmddyy\")","return tostr(monthstr, divstr, daystr, divstr, yearstr);","else","return tostr(daystr, divstr, monthstr, divstr, yearstr);","endif"]},{"name":"parse_english_time_interval","owner":36,"perms":173,"preposition":-1,"code":["\"$time_utils:parse_english_time_interval(n1,u1,n2,u2,...)\";","\"or $time_utils:parse_english_time_interval(\\\"n1 u1[,] [and] n2[,] u2 [and] ...\\\")\";","\"There must be an even number of arguments, all of which must be strings,\";","\" or there must be just one argument which is the entire string to be parsed.\";","\"The n's are are numeric strings, and the u's are unit names.\";","\"The known units are in $time_utils.time_units,\";","\" which must be kept sorted with bigger times at the head.\";","\"Returns the time represented by those words.\";","\"For example,\";","\" $time_utils:parse_english_time_interval(\\\"30\\\",\\\"secs\\\",\\\"2\\\",\\\"minutes\\\",\\\"31\\\",\\\"seconds\\\") => 181\";","if ((length(args) == 1) && index(args[1], \" \"))","return $time_utils:parse_english_time_interval(@$string_utils:words(args[1]));","endif","a = $list_utils:setremove_all(args, \"and\");","nargs = length(a);","if (nargs % 2)","return E_ARGS;","endif","nsec = 0;","n = 0;","for i in [1..nargs]","if ((i % 2) == 1)","if ($string_utils:is_numeric(a[i]))","n = toint(a[i]);","elseif (a[i] in {\"a\", \"an\"})","n = 1;","elseif (a[i] in {\"no\"})","n = 0;","else","return E_INVARG;","endif","else","unit = a[i];","if (unit[$] == \",\")","unit = unit[1..$ - 1];","endif","ok = 0;","for entry in ($time_utils.time_units)","if ((!ok) && (unit in entry[2..$]))","nsec = nsec + (entry[1] * n);","ok = 1;","endif","endfor","if (!ok)","return E_INVARG;","endif","endif","endfor","return nsec;"]},{"name":"seconds_until_date","owner":36,"perms":165,"preposition":-1,"code":["\"Copied from Ballroom Complex (#29992):from_date by Keelah! (#30246) Tue Jul 13 19:42:32 1993 PDT\";","\":seconds_until_date(month,day,time,which)\";","\"month is a string or the numeric representation of the month, day is a number, time is a string in the following format, hh:mm:ss.\";","\"which==-1 => use most recent such month.\";","\"which==+1 => use first upcoming such month.\";","\"which==0 => use closest such month.\";","\"This will return the number of seconds until the month, day and time given to it.\";","\"Written by Keelah, on July 5, 1993.\";","{month, day, time, which} = args;","converted = 0;","converted = converted + $time_utils:from_month(month, which, day);","current = this:seconds_until_time(\"12:00:00\");","get_seconds = this:seconds_until_time(time);","if (get_seconds < 0)","get_seconds = (get_seconds + 39600) - current;","else","get_seconds = (get_seconds + 39600) - current;","endif","converted = (converted + get_seconds) - time();","return converted;"]},{"name":"seconds_until_time","owner":36,"perms":165,"preposition":-1,"code":["\"Copied from Ballroom Complex (#29992):seconds_until by Keelah! (#30246) Tue Jul 13 19:42:37 1993 PDT\";","\":seconds_until_time(hh:mm:ss)\";","\"Given the string hh:mm:ss, this returns the number of seconds until that hh:mm:ss. If the hh:mm:ss is before the current time(), the number returned is a negative, else the number is a positive.\";","\"Written by Keelah, on July 4, 1993.\";","current = $time_utils:to_seconds(ctime()[12..19]);","time = $time_utils:to_seconds(args[1]);","return toint(time) - toint(current);"]},{"name":"set_aliases","owner":36,"perms":173,"preposition":-1,"code":["\"For changing mailing list aliases, we check to make sure that none of the aliases match existing mailing list aliases.  Aliases containing spaces are not used in addresses and so are not subject to this restriction ($mail_agent:match will not match on them, however, so they only match if used in the immediate room, e.g., with match_object() or somesuch).\";","\"  => E_PERM   if you don't own this\";","if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))","return E_PERM;","elseif (this.location != $mail_agent)","\"... we don't care...\";","return pass(@args);","else","{newaliases} = args;","for a in (aliases = newaliases)","if (index(a, \" \"))","\"... we don't care...\";","elseif (rp = $mail_agent:reserved_pattern(a))","player:tell(\"Mailing list name \\\"\", a, \"\\\" uses a reserved pattern: \", rp[1]);","aliases = setremove(aliases, a);","elseif (valid(p = $mail_agent:match(a, $nothing)) && ((p != this) && (a in p.aliases)))","player:tell(\"Mailing list name \\\"\", a, \"\\\" in use on \", p.name, \"(\", p, \")\");","aliases = setremove(aliases, a);","endif","endfor","return pass(aliases) && (newaliases == aliases);","endif"]},{"name":"look_self","owner":36,"perms":173,"preposition":-1,"code":["\"Returns full name and mail aliases for this list, read and write status by the player, and a short description. Calling :look_self(1) will omit the description.\";","{?brief = 0} = args;","namelist = \"*\" + ((names = this:mail_names()) ? $string_utils:from_list(names, \", *\") | tostr(this));","if (typeof(fwd = this:mail_forward()) != LIST)","fwd = {};","endif","if (this:is_writable_by(player))","if (player in fwd)","read = \" [Writable/Subscribed]\";","else","read = \" [Writable]\";","endif","elseif (this.readers == 1)","read = tostr(\" [Public\", (player in fwd) ? \"/Subscribed]\" | \"]\");","elseif (player in fwd)","read = \" [Subscribed]\";","elseif (this:is_readable_by(player))","read = \" [Readable]\";","else","read = \"\";","endif","if (this:is_usable_by($no_one))","mod = \"\";","elseif (this:is_usable_by(player))","mod = \" [Approved]\";","else","mod = \" [Moderated]\";","endif","player:tell(namelist, \"  (\", this, \")\", read, mod);","if (!brief)","d = this:description();","if (typeof(d) == STR)","d = {d};","endif","for l in (d)","if (length(l) <= 75)","ls = {l};","else","ls = $generic_editor:fill_string(l, 76);","endif","for line in (ls)","player:tell(\"    \", line);","$command_utils:suspend_if_needed(0);","endfor","endfor","endif"]},{"name":"is_writable_by","owner":36,"perms":173,"preposition":-1,"code":["return $perm_utils:controls(who = args[1], this) || `who in this.writers ! E_TYPE';"]},{"name":"is_readable_by","owner":36,"perms":173,"preposition":-1,"code":["return (typeof(this.readers) != LIST) || (((who = args[1]) in this.readers) || (this:is_writable_by(who) || $mail_agent:sends_to(1, this, who)));"]},{"name":"is_usable_by","owner":36,"perms":173,"preposition":-1,"code":["who = args[1];","if (this.moderated)","return `who in this.moderated ! E_TYPE' || (this:is_writable_by(who) || who.wizard);","else","return this.guests_can_send_here || (!$object_utils:isa(who, $guest));","endif"]},{"name":"mail_notify","owner":36,"perms":173,"preposition":-1,"code":["if ((args && (!this:is_usable_by(args[1]))) && (!args[1].wizard))","return this:moderator_notify(@args);","else","return this.(verb);","endif"]},{"name":"mail_forward","owner":36,"perms":173,"preposition":-1,"code":["if ((args && (!this:is_usable_by(args[1]))) && (!args[1].wizard))","return this:moderator_forward(@args);","elseif (typeof(mf = this.(verb)) == STR)","return $string_utils:pronoun_sub(mf, @args);","else","return mf;","endif"]},{"name":"moderator_forward","owner":36,"perms":173,"preposition":-1,"code":["if (typeof(mf = this.(verb)) == STR)","return $string_utils:pronoun_sub(mf, args ? args[1] | $player);","else","return mf;","endif"]},{"name":"add_forward","owner":36,"perms":173,"preposition":-1,"code":["\":add_forward(recip[,recip...]) adds new recipients to this list.  Returns a string error message or a list of results (recip => success, E_PERM => not allowed, E_INVARG => not a valid recipient, string => other kind of failure)\";","if (caller == $mail_editor)","perms = player;","else","perms = caller_perms();","endif","result = {};","forward_self = (!this.mail_forward) || (this in this.mail_forward);","for recip in (args)","if ((!valid(recip)) || ((!is_player(recip)) && (!($mail_recipient in $object_utils:ancestors(recip)))))","r = E_INVARG;","elseif ($perm_utils:controls(perms, this) || ((typeof(this.readers) != LIST) && $perm_utils:controls(perms, recip)))","this.mail_forward = setadd(this.mail_forward, recip);","r = recip;","else","r = E_PERM;","endif","result = listappend(result, r);","endfor","if ((length(this.mail_forward) > 1) && ($nothing in this.mail_forward))","this.mail_forward = setremove(this.mail_forward, $nothing);","endif","if (forward_self)","this.mail_forward = setadd(this.mail_forward, this);","endif","return result;"]},{"name":"delete_forward","owner":36,"perms":173,"preposition":-1,"code":["\":delete_forward(recip[,recip...]) removes recipients to this list.  Returns a list of results (E_PERM => not allowed, E_INVARG => not on list)\";","if (caller == $mail_editor)","perms = player;","else","perms = caller_perms();","endif","result = {};","forward_self = (!this.mail_forward) || (this in this.mail_forward);","for recip in (args)","if (!(recip in this.mail_forward))","r = E_INVARG;","elseif (((!valid(recip)) || $perm_utils:controls(perms, recip)) || $perm_utils:controls(perms, this))","if (recip == this)","forward_self = 0;","endif","this.mail_forward = setremove(this.mail_forward, recip);","r = recip;","else","r = E_PERM;","endif","result = listappend(result, r);","endfor","if (!(forward_self || this.mail_forward))","this.mail_forward = {$nothing};","elseif (this.mail_forward == {this})","this.mail_forward = {};","endif","return result;"]},{"name":"add_notify","owner":36,"perms":173,"preposition":-1,"code":["\":add_notify(recip[,recip...]) adds new notifiees to this list.  Returns a list of results (recip => success, E_PERM => not allowed, E_INVARG => not a valid recipient)\";","if (caller == $mail_editor)","perms = player;","else","perms = caller_perms();","endif","result = {};","for recip in (args)","if ((!valid(recip)) || (recip == this))","r = E_INVARG;","elseif ($perm_utils:controls(perms, this) || (this:is_readable_by(perms) && $perm_utils:controls(perms, recip)))","this.mail_notify = setadd(this.mail_notify, recip);","r = recip;","else","r = E_PERM;","endif","result = listappend(result, r);","endfor","return result;"]},{"name":"delete_notify","owner":36,"perms":173,"preposition":-1,"code":["\":delete_notify(recip[,recip...]) removes notifiees from this list.  Returns a list of results (E_PERM => not allowed, E_INVARG => not on list)\";","if (caller == $mail_editor)","perms = player;","else","perms = caller_perms();","endif","result = {};","rmthis = 0;","for recip in (args)","if (!(recip in this.mail_notify))","r = E_INVARG;","elseif ((!valid(recip)) || ($perm_utils:controls(perms, recip) || $perm_utils:controls(perms, this)))","if (recip == this)","rmthis = 1;","endif","this.mail_notify = setremove(this.mail_notify, recip);","r = recip;","else","r = E_PERM;","endif","result = listappend(result, r);","endfor","return result;"]},{"name":"receive_message","owner":36,"perms":173,"preposition":-1,"code":["if (!this:ok_write(caller, caller_perms()))","return E_PERM;","else","this.messages = {@this.messages, {new = this:new_message_num(), args[1]}};","this.last_msg_date = args[1][1];","this.last_used_time = time();","return new;","endif"]},{"name":"ok","owner":36,"perms":173,"preposition":-1,"code":["\":ok(caller,callerperms) => true iff caller can do read operations\";","return (args[1] in {this, $mail_agent}) || (args[2].wizard || this:is_readable_by(args[2]));"]},{"name":"ok_write","owner":36,"perms":173,"preposition":-1,"code":["\":ok_write(caller,callerperms) => true iff caller can do write operations\";","return (args[1] in {this, $mail_agent}) || (args[2].wizard || this:is_writable_by(args[2]));"]},{"name":"parse_message_seq from_msg_seq %from_msg_seq to_msg_seq %to_msg_seq subject_msg_seq body_msg_seq kept_msg_seq unkept_msg_seq display_seq_headers display_seq_full messages_in_seq list_rmm new_message_num length_num_le length_date_le length_all_msgs exists_num_eq msg_seq_to_msg_num_list msg_seq_to_msg_num_string","owner":36,"perms":173,"preposition":-1,"code":["\":parse_message_seq(strings,cur) => {msg_seq,@unused_strings} or string error\";","\"\";","\":from_msg_seq(olist)     => msg_seq of messages from those people\";","\":%from_msg_seq(strings)  => msg_seq of messages with strings in the From: line\";","\":to_msg_seq(olist)       => msg_seq of messages to those people\";","\":%to_msg_seq(strings)    => msg_seq of messages with strings in the To: line\";","\":subject_msg_seq(target) => msg_seq of messages with target in the Subject:\";","\":body_msg_seq(target)    => msg_seq of messages with target in the body\";","\":new_message_num()    => number that the next incoming message will receive.\";","\":length_num_le(num)   => number of messages in folder numbered <= num\";","\":length_date_le(date) => number of messages in folder dated <= date\";","\":length_all_msgs()    => number of messages in folder\";","\":exists_num_eq(num)   => index of message in folder numbered == num, or 0\";","\"\";","\":display_seq_headers(msg_seq[,cur])   display message summary lines\";","\":display_seq_full(msg_seq[,preamble]) display entire messages\";","\"            => number of final message displayed\";","\":list_rmm() displays contents of .messages_going.\";","\"            => the number of messages in .messages_going.\";","\"\";","\":messages_in_seq(msg_seq) => list of messages in msg_seq on folder\";","\"\";","\"See the corresponding routines on $mail_agent for more detail.\";","return this:ok(caller, caller_perms()) ? $mail_agent:(verb)(@args) | E_PERM;"]},{"name":"length_date_gt","owner":36,"perms":173,"preposition":-1,"code":["\":length_date_le(date) => number of messages in folder dated > date\";","\"\";","if (this:ok(caller, caller_perms()))","date = args[1];","return (this.last_msg_date <= date) ? 0 | $mail_agent:(verb)(date);","else","return E_PERM;","endif"]},{"name":"rm_message_seq","owner":36,"perms":173,"preposition":-1,"code":["\":rm_message_seq(msg_seq) removes the given sequence of from folder\";","\"               => string giving msg numbers removed\";","\"See the corresponding routine on $mail_agent.\";","if (this:ok_write(caller, caller_perms()))","return $mail_agent:(verb)(@args);","elseif (this:ok(caller, caller_perms()) && (seq = this:own_messages_filter(caller_perms(), @args)))","return $mail_agent:(verb)(@listset(args, seq, 1));","else","return E_PERM;","endif"]},{"name":"undo_rmm expunge_rmm renumber keep_message_seq","owner":36,"perms":173,"preposition":-1,"code":["\":rm_message_seq(msg_seq) removes the given sequence of from folder\";","\"               => string giving msg numbers removed\";","\":list_rmm()    displays contents of .messages_going.\";","\"               => number of messages in .messages_going.\";","\":undo_rmm()    restores previously deleted messages from .messages_going.\";","\"               => msg_seq of restored messages\";","\":expunge_rmm() destroys contents of .messages_going once and for all.\";","\"               => number of messages in .messages_going.\";","\":renumber([cur])  renumbers all messages\";","\"               => {number of messages,new cur}.\";","\"\";","\"See the corresponding routines on $mail_agent.\";","return this:ok_write(caller, caller_perms()) ? $mail_agent:(verb)(@args) | E_PERM;"]},{"name":"own_messages_filter","owner":36,"perms":173,"preposition":-1,"code":["\":own_messages_filter(who,msg_seq) => subsequence of msg_seq consisting of those messages that <who> is actually allowed to remove (on the assumption that <who> is not one of the allowed writers of this folder.\";","if (!this.rmm_own_msgs)","return E_PERM;","elseif ((typeof(seq = this:from_msg_seq({args[1]}, args[2])) != LIST) || (seq != args[2]))","return {};","else","return seq;","endif"]},{"name":"messages","owner":36,"perms":173,"preposition":-1,"code":["\"NOTE:  this routine is obsolete, use :messages_in_seq()\";","\":messages(num) => returns the message numbered num.\";","\":messages()    => returns the entire list of messages (can be SLOW).\";","if (!this:ok(caller, caller_perms()))","return E_PERM;","elseif (!args)","return this:messages_in_seq({1, this:length_all_msgs() + 1});","elseif (!(n = this:exists_num_eq(args[1])))","return E_RANGE;","else","return this:messages_in_seq(n)[2];","endif"]},{"name":"date_sort","owner":36,"perms":173,"preposition":-1,"code":["if (!this:ok_write(caller, caller_perms()))","return E_PERM;","endif","date_seq = {};","for msg in (this.messages)","date_seq = {@date_seq, msg[2][1]};","endfor","msg_order = $list_utils:sort($list_utils:range(n = length(msgs = this.messages)), date_seq);","newmsgs = {};","for i in [1..n]","if ($command_utils:suspend_if_needed(0))","player:tell(\"...\", i);","endif","newmsgs = {@newmsgs, {i, msgs[msg_order[i]][2]}};","endfor","if (length(this.messages) != n)","\"...shit, new mail received,... start again...\";","fork (0)","this:date_sort();","endfork","else","this.messages = newmsgs;","this.last_used_time = newmsgs[$][2][1];","endif"]},{"name":"_fix_last_msg_date","owner":36,"perms":173,"preposition":-1,"code":["mlen = this:length_all_msgs();","this.last_msg_date = mlen && this:messages_in_seq(mlen)[2][1];"]},{"name":"moderator_notify","owner":36,"perms":173,"preposition":-1,"code":["return this.(verb);"]},{"name":"msg_summary_line","owner":36,"perms":173,"preposition":-1,"code":["return $mail_agent:msg_summary_line(@args);"]},{"name":"__check","owner":36,"perms":173,"preposition":-1,"code":["for m in (this.messages)","$mail_agent:__convert_new(@m[2]);","$command_utils:suspend_if_needed(0);","endfor"]},{"name":"__fix","owner":2,"perms":173,"preposition":-1,"code":["if (!this:ok_write(caller, caller_perms()))","return E_PERM;","endif","msgs = {};","i = 1;","for m in (oldmsgs = this.messages)","msgs = {@msgs, {m[1], $mail_agent:__convert_new(@m[2])}};","if ($command_utils:running_out_of_time())","player:notify(tostr(\"...\", i, \" \", this));","suspend(0);","if (oldmsgs != this.messages)","return 0;","endif","endif","i = i + 1;","endfor","this.messages = msgs;","return 1;"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","pass();","if (!(this in {$mail_recipient, $big_mail_recipient}))","\"...generic mail recipients stay in #-1...\";","move(this, $mail_agent);","this:_fix_last_msg_date();","endif","endif"]},{"name":"initialize","owner":2,"perms":173,"preposition":-1,"code":["if ($perm_utils:controls(caller_perms(), this))","this.mail_forward = {};","return pass(@args);","endif"]},{"name":"mail_name short_mail_name","owner":36,"perms":173,"preposition":-1,"code":["return \"*\" + this.aliases[1];"]},{"name":"mail_names","owner":36,"perms":173,"preposition":-1,"code":["names = {};","for a in (this.aliases)","if (!index(a, \" \"))","names = setadd(names, strsub(a, \"_\", \"-\"));","endif","endfor","return names;"]},{"name":"expire_old_messages","owner":2,"perms":173,"preposition":-1,"code":["if (this:ok_write(caller, caller_perms()))","\"Passed security check...\";","set_task_perms($wiz_utils:random_wizard());","for x in (this.mail_notify)","if (!$object_utils:has_verb(x, \"notify_mail\"))","\"In theory I should call this:delete_notify but it's ugly and ticky as sin and I'm lazy.\";","this.mail_notify = setremove(this.mail_notify, x);","endif","endfor","if (this.expire_period && (rmseq = $seq_utils:remove(this:unkept_msg_seq(), 1 + this:length_date_le(time() - this.expire_period))))","\"... i.e., everything not marked kept that is older than expire_period\";","if (this.registered_email && this.email_validated)","format = this.owner:format_for_netforward(this:messages_in_seq(rmseq), \" expired from \" + $mail_agent:name(this));","$network:sendmail(this.registered_email, @{format[2], @format[1]});","\"Do nothing if it bounces, etc.\";","endif","this:rm_message_seq(rmseq);","return this:expunge_rmm();","else","return 0;","endif","else","return E_PERM;","endif"]},{"name":"moveto","owner":36,"perms":173,"preposition":-1,"code":["if (this:is_writable_by(caller_perms()) || this:is_writable_by(caller))","pass(@args);","else","return E_PERM;","endif"]},{"name":"msg_full_text","owner":36,"perms":173,"preposition":-1,"code":["\":msg_full_text(@msg) => list of strings.\";","\"msg is a mail message (in the usual transmission format).\";","\"display_seq_full calls this to obtain the actual list of strings to display.\";","return player:msg_text(@args);","\"default is to leave it up to the player how s/he wants it to be displayed.\";"]},{"name":"@set_expire","owner":36,"perms":109,"preposition":1,"code":["\"Syntax:  @set_expire <recipient> to <time>\";","\"         @set_expire <recipient> to\";","\"\";","\"Allows the list owner to set the expiration period of this mail recipient. This is the time messages will remain before they are removed from the list. The <time> given can be in english terms (e.g., 2 months, 45 days, etc.).\";","\"Non-wizard mailing list owners are limited to a maximum expire period of 180 days. They are also prohibited from setting the list to non-expiring.\";","\"Wizards may set the expire period to 0 for no expiration.\";","\"The second form, leaving off the time specification, will tell you what the recipient's expire period is currently set to.\";","if ((caller_perms() != #-1) && (caller_perms() != player))","return player:tell(E_PERM);","elseif (!this:is_writable_by(player))","return player:tell(E_PERM);","elseif (!iobjstr)","return player:tell(this.expire_period ? tostr(\"Messages will automatically expire from \", this:mail_name(), \" after \", $time_utils:english_time(this.expire_period), \".\") | tostr(\"Messages will not expire from \", this:mail_name()));","elseif (typeof(time = $time_utils:parse_english_time_interval(iobjstr)) == ERR)","return player:tell(time);","elseif ((time == 0) && (!player.wizard))","return player:tell(\"Only wizards may set a mailing list to not expire.\");","elseif ((time > (180 * 86400)) && (!player.wizard))","return player:tell(\"Only a wizard may set the expiration period on a mailing list to greater than 180 days.\");","endif","this.expire_period = time;","player:tell(\"Messages will \", (time != 0) ? tostr(\"automatically expire from \", this:mail_name(), \" after \", $time_utils:english_time(time)) | tostr(\"not expire from \", this:mail_name()), \".\");"]},{"name":"@register @netregister","owner":2,"perms":109,"preposition":1,"code":["\"Syntax:   @register <recipient> to <email-address>\";","\"alias     @netregister <recipient> to <email-address>\";","\"          @register <recipient> to\";","\"\";","\"The list owner may use this command to set a registered email address for the mail recipient. When set, mail messages that expire off of the mail recipient will be mailed to that address.\";","\"If you leave the email address off of the command, it will return the current registration and expiration information for that recipient if you own it.\";","\"The owner may register a mail recipient to any email address. However, if the address does not match his registered email address, then a password will be generated and sent to the address specified when this command is used. Then, the owner may retrieve that password and verify the address with the command:\";","\"\";","\"  @validate <recipient> with <password>\";","\"\";","\"See *B:MailingListReform #98087 for full details.\";","if ((caller_perms() != #-1) && (caller_perms() != player))","return player:tell(E_PERM);","elseif (!$perm_utils:controls(player, this))","return player:tell(E_PERM);","elseif (!iobjstr)","if (this.registered_email)","player:tell(this:mail_name(), \" is registered to \", this.registered_email, \". Messages will be sent there when they expire after \", (this.expire_period == 0) ? \"never\" | $time_utils:english_time(this.expire_period), \".\");","else","player:tell(this:mail_name(), \" is not registered to any address. Messages will be deleted when they expire after \", (this.expire_period == 0) ? \"never\" | $time_utils:english_time(this.expire_period), \".\");","player:tell(\"Usage:  @register <recipient> to <email-address>\");","endif","return;","elseif (iobjstr == $wiz_utils:get_email_address(player))","this.registered_email = $wiz_utils:get_email_address(player);","this.email_validated = 1;","player:tell(\"Messages expired from \", this:mail_name(), \" after \", (this.expire_period == 0) ? \"never\" | $time_utils:english_time(this.expire_period), \" will be emailed to \", this.registered_email, \" (which is your registered email address).\");","elseif (reason = $network:invalid_email_address(iobjstr))","return player:tell(reason, \".\");","elseif (!$network.active)","return player:tell(\"The network is not up at the moment. Please try again later or contact a wizard for help.\");","else","password = $wiz_utils:random_password(5);","result = $network:sendmail(iobjstr, tostr($network.MOO_Name, \" mailing list verification\"), @$generic_editor:fill_string(tostr(\"The mailing list \", this:mail_name(), \" on \", $network.MOO_Name, \" has had this address designated as the recipient of expired mail messages. If this is not correct, then you need do nothing but ignore this message. If this is correct, you must log into the MOO and type:  `@validate \", this:mail_name(), \" with \", password, \"' to start receiving expired mail messages.\"), 75));","if (result != 0)","return player:tell(\"Mail sending did not work: \", result, \". Address not set.\");","endif","this.registered_email = iobjstr;","this.email_validated = 0;","this.validation_password = password;","player:tell(\"Registration complete. Password sent to the address you specified. When you receive the email, log back in to validate it with the command:  @validate <recipient> with <password>. If you do not receive the password email, try again or notify a wizard if this is a recurring problem.\");","endif"]},{"name":"@validate","owner":36,"perms":109,"preposition":0,"code":["\"Syntax:  @validate <recipient> with <password>\";","\"\";","\"This command is used to validate an email address set to receive expired messages that did not match the list owner's registered email address. When using the @register command, a password was sent via email to the address specified. This command is to verify that the password was received properly.\";","if ((caller_perms() != #-1) && (caller_perms() != player))","return player:tell(E_PERM);","elseif (!$perm_utils:controls(player, this))","return player:tell(E_PERM);","elseif (!this.registered_email)","return player:tell(\"No email address has even been set for \", this:mail_name(), \".\");","elseif (this.email_validated)","return player:tell(\"The email address for \", this:mail_name(), \" has already been validated.\");","elseif (!iobjstr)","return player:tell(\"Usage:  @validate <recipient> with <password>\");","elseif (iobjstr != this.validation_password)","return player:tell(\"That is not the correct password.\");","else","this.email_validated = 1;","player:tell(\"Password validated. Messages that expire after \", (this.expire_period == 0) ? \"never\" | $time_utils:english_time(this.expire_period), \" from \", this:mail_name(), \" will be emailed to \", this.registered_email, \".\");","endif"]},{"name":"set_name","owner":36,"perms":173,"preposition":-1,"code":["{name} = args;","if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))","return E_PERM;","elseif (this.location != $mail_agent)","\"... we don't care...\";","return pass(@args);","elseif (index(name, \" \"))","\"... we don't care...\";","elseif (rp = $mail_agent:reserved_pattern(name))","player:tell(\"Mailing list name \\\"\", a, \"\\\" uses a reserved pattern: \", rp[1]);","return 0;","elseif (valid(p = $mail_agent:match(name, $nothing)) && ((p != this) && (name in p.aliases)))","player:tell(\"Mailing list name \\\"\", name, \"\\\" in use on \", p.name, \"(\", p, \")\");","return 0;","endif","return pass(name);"]},{"name":"resolve_addr","owner":36,"perms":173,"preposition":-1,"code":["\"resolve(name,from,seen,prevrcpts,prevnotifs) => {rcpts,notifs} or E_INVARG\";","\"resolve(list,from,seen,prevrcpts,prevnotifs) => {bogus,rcpts,notifs}\";","\"Given either an address (i.e., objectid) or a list of such, traces down all .mail_forward lists and .mail_notify to determine where a message should actually go and who should be told about it.  Both forms take previous lists of recipients/notifications and add only those addresses that weren't there before.  `seen' is the stack of addresses we are currently resolving (for detecting loops).  The first form returns E_INVARG if `name' is invalid.  The second form returns all invalid addresses in the `bogus' list but still does the appropriate search on the remaining addresses.\";","{recip, from, ?seen = {}, ?prevrcpts = {}, ?prevnotifs = {}} = args;","sofar = {prevrcpts, prevnotifs};","if (typeof(recip) == LIST)","bogus = {};","for r in (recip)","result = this:resolve_addr(r, from, seen, @sofar);","if (result)","sofar = result;","else","bogus = setadd(bogus, r);","endif","endfor","return {bogus, @sofar};","else","fwd = include_recip = 0;","if ((recip == $nothing) || (recip in seen))","return sofar;","elseif ((!valid(recip)) || ((!(is_player(recip) || $object_utils:isa(recip, $mail_recipient))) || (typeof(fwd = recip:mail_forward(from)) != LIST)))","\"recip is a non-player non-mailing-list/folder or forwarding is screwed.\";","if (typeof(fwd) == STR)","player:tell(fwd);","endif","return E_INVARG;","elseif (is_player(recip) && `recip:refuses_action(from, \"mail\") ! E_VERBNF')","player:tell(recip:mail_refused_msg());","return E_INVARG;","elseif (fwd)","if (r = recip in fwd)","include_recip = 1;","fwd = listdelete(fwd, r);","endif","result = this:resolve_addr(fwd, recip, setadd(seen, recip), @sofar);","if (bogus = result[1])","player:tell(recip.name, \"(\", recip, \")'s .mail_forward list includes the following bogus entr\", (length(bogus) > 1) ? \"ies:  \" | \"y:  \", $string_utils:english_list(bogus));","endif","sofar = result[2..3];","else","include_recip = 1;","endif","if ((ticks_left() < 1000) || (seconds_left() < 2))","suspend(0);","endif","biffs = sofar[2];","for n in (this:mail_notify(recip, from))","if (valid(n))","if (i = $list_utils:iassoc_suspended(n, biffs))","biffs[i] = setadd(biffs[i], recip);","else","biffs = {{n, recip}, @biffs};","endif","endif","if ((ticks_left() < 1000) || (seconds_left() < 2))","suspend(0);","endif","endfor","return {include_recip ? setadd(sofar[1], recip) | sofar[1], biffs};","endif"]},{"name":"sends_to","owner":36,"perms":173,"preposition":-1,"code":["\"sends_to(from,addr,rcpt[,seen]) ==> true iff mail sent to addr passes through rcpt.\";","{from, addr, rcpt, ?seen = {}} = args;","if (addr == rcpt)","return 1;","elseif (!(addr in seen))","seen = {@seen, addr};","for a in ((typeof(fwd = this:mail_forward(addr, @from ? {} | {from})) == LIST) ? fwd | {})","if (this:sends_to(addr, a, rcpt, seen))","return 1;","endif","$command_utils:suspend_if_needed(0);","endfor","endif","return 0;"]},{"name":"send_message","owner":36,"perms":173,"preposition":-1,"code":["\"send_message(from,rcpt-list,hdrs,msg) -- formats and sends a mail message.  hders is either the text of the subject line, or a {subject,{reply-to,...}} list.\";","\"Return E_PERM if from isn't owned by the caller.\";","\"Return {0, @invalid_rcpts} if rcpt-list contains any invalid addresses.  No mail is sent in this case.\";","\"Return {1, @actual_rcpts} if successful.\";","{from, to, orig_hdrs, msg} = args;","\"...\";","\"... remove bogus Resent-To/Resent-By headers...\";","\"...\";","if ((typeof(orig_hdrs) == LIST) && (length(orig_hdrs) > 2))","hdrs = orig_hdrs[1..2];","orig_hdrs[1..2] = {};","strip = {\"Resent-To\", \"Resent-By\"};","for h in (orig_hdrs)","(h[1] in strip) || (hdrs = {@hdrs, h});","endfor","else","hdrs = orig_hdrs;","endif","\"...\";","\"... send it...\";","\"...\";","if ($perm_utils:controls(caller_perms(), from))","text = $mail_agent:make_message(from, to, hdrs, msg);","return this:raw_send(text, to, from);","else","return E_PERM;","endif"]},{"name":"raw_send","owner":2,"perms":173,"preposition":-1,"code":["\"Copied from Mail Distribution Center (#6418):raw_send by Nosredna (#2487) Mon Feb 24 10:46:26 1997 PST\";","\"WIZARDLY\";","\"raw_send(text,rcpts,sender) -- does the actual sending of a message.  Assumes that text has already been formatted correctly.  Decides who to send it to and who wants to be notified about it and does so.\";","\"Return {E_PERM} if the caller is not entitled to use this verb.\";","\"Return {0, @invalid_rcpts} if rcpts contains any invalid addresses.  No mail is sent in this case.\";","\"Return {1, @actual_rcpts} if successful.\";","{text, rcpts, from} = args;","if (typeof(rcpts) != LIST)","rcpts = {rcpts};","endif","if (!(caller in {$mail_agent, $mail_editor}))","return {E_PERM};","elseif (bogus = (resolve = this:resolve_addr(rcpts, from))[1])","return {0, bogus};","else","set_task_perms($wiz_utils:random_wizard());","this:touch(rcpts);","actual_rcpts = resolve[2];","biffs = resolve[3];","results = {};","for recip in (actual_rcpts)","if ((ticks_left() < 10000) || (seconds_left() < 2))","player:notify(tostr(\"...\", recip));","suspend(1);","endif","if (typeof(e = recip:receive_message(text, from)) in {ERR, STR})","\"...receive_message bombed...\";","player:notify(tostr(recip, \":receive_message:  \", e));","e = 0;","elseif ((!is_player(recip)) || (!e))","\"...not a player or receive_message isn't giving out the message number\";","\"...no need to force a notification...\";","elseif (i = $list_utils:iassoc(recip, biffs))","\"...player-recipient was already getting a notification...\";","\"...make sure notification includes a mention of him/her/itself.\";","if (!(recip in listdelete(biffs[i], 1)))","biffs[i][2..1] = {recip};","endif","else","\"...player-recipient wasn't originally being notified at all...\";","biffs = {{recip, recip}, @biffs};","endif","results = {@results, e};","endfor","\"The following is because the scheduler can BITE ME. --Nosredna\";","fork (0)","for b in (biffs)","if ((ticks_left() < 10000) || (seconds_left() < 2))","suspend(1);","endif","if ($object_utils:has_callable_verb(b[1], \"notify_mail\"))","mnums = {};","for r in (listdelete(b, 1))","mnums = {@mnums, (rn = r in actual_rcpts) && results[rn]};","endfor","b[1]:notify_mail(from, listdelete(b, 1), mnums);","endif","endfor","endfork","return {1, @actual_rcpts};","endif"]},{"name":"mail_forward mail_notify","owner":36,"perms":173,"preposition":-1,"code":["who = args[1];","if ($object_utils:has_verb(who, verb))","return who:(verb)(@listdelete(args, 1));","else","return {};","endif"]},{"name":"touch","owner":36,"perms":173,"preposition":-1,"code":["\"touch(name or list,seen) => does .last_used_time = time() if we haven't already touched this in the last hour\";","{recip, ?seen = {}} = args;","if (typeof(recip) == LIST)","for r in (recip)","result = this:touch(r, seen);","$command_utils:suspend_if_needed(0);","endfor","else","if (((!valid(recip)) || (recip in seen)) || ((!is_player(recip)) && (!($mail_recipient in $object_utils:ancestors(recip)))))","\"recip is neither a player nor a mailing list/folder\";","else","if (fwd = this:mail_forward(recip))","this:touch(fwd, {@seen, recip});","endif","if (!is_player(recip))","recip.last_used_time = time();","endif","endif","endif"]},{"name":"look_self","owner":36,"perms":173,"preposition":-1,"code":["player:tell_lines(this.description);","for c in (this.contents)","c:look_self();","endfor"]},{"name":"acceptable","owner":36,"perms":173,"preposition":-1,"code":["\"Only allow mailing lists/folders in here and only if their names aren't already taken.\";","what = args[1];","return ($object_utils:isa(what, $mail_recipient) && this:check_names(@what.aliases)) && (what:description() != parent(what):description());"]},{"name":"check_names","owner":36,"perms":173,"preposition":-1,"code":["\"...make sure the list has at least one usable name.\";","\"...make sure none of the aliases are already taken.\";","ok = 0;","for a in (args)","sub1 = strsub(a, \"_\", \"-\");","sub2 = strsub(a, \"-\", \"_\");","if (sub1 == sub2)","check = 0;","else","check = 1;","endif","if (index(a, \" \"))","elseif (rp = $mail_agent:reserved_pattern(a))","player:tell(\"Mailing list name \\\"\", a, \"\\\" uses a reserved pattern: \", rp[1]);","return 0;","elseif (valid(p = $mail_agent:match(a, #-1)) && (a in p.aliases))","player:tell(\"Mailing list name \\\"\", a, \"\\\" in use on \", p.name, \"(\", p, \")\");","return 0;","elseif ((check && valid(p = $mail_agent:match(sub1, #-1))) && (sub1 in p.aliases))","player:tell(\"Mailing list name \\\"\", sub1, \"\\\" in use on \", p.name, \"(\", p, \")\");","return 0;","elseif ((check && valid(p = $mail_agent:match(sub2, #-1))) && (sub2 in p.aliases))","player:tell(\"Mailing list name \\\"\", sub2, \"\\\" in use on \", p.name, \"(\", p, \")\");","return 0;","else","ok = 1;","endif","endfor","return ok;"]},{"name":"match","owner":36,"perms":173,"preposition":-1,"code":["\":match(string) => mailing list object in here that matches string.\";","\":match(string,player) => similar but also matches against player's private mailing lists (as kept in .mail_lists).\";","if (!(string = args[1]))","return $nothing;","elseif (string[1] == \"*\")","string = string[2..$];","endif","if (valid(o = $string_utils:literal_object(string)) && ($mail_recipient in $object_utils:ancestors(o)))","return o;","elseif (rp = this:reserved_pattern(string))","return rp[2]:match_mail_recipient(string);","else","if (valid(who = {@args, player}[2]) && (typeof(use = `who.mail_lists ! E_PROPNF, E_PERM') == LIST))","use = {@this.contents, @use};","else","use = this.contents;","endif","partial = 1;","string = strsub(string, \"_\", \"-\");","for l in (use)","if (string in l.aliases)","return l;","endif","if (partial != $ambiguous_match)","for a in (l.aliases)","if ((index(a, string) == 1) && (!index(a, \" \")))","if (partial)","partial = l;","elseif (partial != l)","partial = $ambiguous_match;","endif","endif","$command_utils:suspend_if_needed(2);","endfor","endif","endfor","return partial && $failed_match;","endif"]},{"name":"match_recipient","owner":36,"perms":173,"preposition":-1,"code":["\":match_recipient(string[,meobj]) => $player or $mail_recipient object that matches string.  Optional second argument (defaults to player) is returned in the case string==\\\"me\\\" and is also used to obtain a list of private $mail_recipients to match against.\";","{string, ?me = player} = args;","if (valid(me) && ($failed_match != (o = me:my_match_recipient(string))))","return o;","elseif (!string)","return $nothing;","elseif ((string[1] == \"*\") && (string != \"*\"))","return this:match(@args);","elseif (string[1] == \"`\")","args[1][1..1] = \"\";","return $string_utils:match_player(@args);","elseif (valid(o = $string_utils:match_player(@args)) || (o == $ambiguous_match))","return o;","else","return this:match(@args);","endif"]},{"name":"match_failed","owner":36,"perms":173,"preposition":-1,"code":["{match_result, string, ?cmd_id = \"\"} = args;","cmd_id = cmd_id || \"\";","if (match_result == $nothing)","player:tell(cmd_id, \"You must specify a valid mail recipient.\");","elseif (match_result == $failed_match)","player:tell(cmd_id, \"There is no mail recipient called \\\"\", string, \"\\\".\");","elseif (match_result == $ambiguous_match)","if ((nostar = index(string, \"*\") != 1) && (lst = $player_db:find_all(string)))","player:tell(cmd_id, \"\\\"\", string, \"\\\" could refer to \", (length(lst) > 20) ? tostr(\"any of \", length(lst), \" players\") | $string_utils:english_list($list_utils:map_arg(2, $string_utils, \"pronoun_sub\", \"%n (%#)\", lst), \"no one\", \" or \"), \".\");","else","player:tell(cmd_id, \"I don't know which \\\"\", nostar ? \"*\" | \"\", string, \"\\\" you mean.\");","endif","elseif (!valid(match_result))","player:tell(cmd_id, match_result, \" does not exist.\");","else","return 0;","endif","return 1;"]},{"name":"make_message","owner":36,"perms":173,"preposition":-1,"code":["\":make_message(sender,recipients,subject/replyto/additional-headers,body)\";","\" => message in the form as it will get sent.\";","{from, recips, hdrs, body} = args;","try","fromowner = from.owner;","except (E_INVIND)","raise(E_PERM);","endtry","fromline = this:name_list(from);","if (typeof(recips) != LIST)","recips = {recips};","endif","recips = this:name_list(@recips);","others = {};","replyto = 0;","if (typeof(hdrs) != LIST)","hdrs = {hdrs};","endif","subj = hdrs[1];","if (!valid(from))","others = {\"Probable-Sender:   \" + this:name(fromowner)};","\"  others = {'Possible-Sender:   ' + this:name(player)}\";","\"  if (caller_perms() != player)\";","\"    others = {@others, 'Possible-Sender:   ' + this:name(caller_perms())}\";","\"  endif\";","elseif (!is_player(from))","others = {\"Sender:   \" + this:name(from.owner)};","endif","replyto = {@hdrs, 0}[2] && this:name_list(@hdrs[2]);","if (length(hdrs) > 2)","hdrs[1..2] = {};","for h in (hdrs)","if (match(h[1], \"[a-z1-9-]+\"))","others = {@others, $string_utils:left(h[1] + \": \", 15) + h[2]};","endif","endfor","endif","if (typeof(body) != LIST)","body = body ? {body} | {};","endif","return {time(), fromline, recips, subj || \" \", @replyto ? {\"Reply-to: \" + replyto} | {}, @others, \"\", @body};"]},{"name":"name","owner":36,"perms":173,"preposition":-1,"code":["what = args[1];","if (!valid(what))","name = \"???\";","elseif ((!is_player(what)) && $object_utils:has_callable_verb(what, \"mail_name\"))","name = what:mail_name();","else","name = what.name;","endif","return tostr(strsub(strsub(name, \"(\", \"\"), \")\", \"\"), \" (\", what, \")\");"]},{"name":"name_list","owner":36,"perms":173,"preposition":-1,"code":["return $string_utils:english_list($list_utils:map_arg(this, \"name\", args), \"no one\");"]},{"name":"parse_address_field","owner":36,"perms":173,"preposition":-1,"code":["\":parse_address_field(string) => list of objects\";","\"This is the standard routine for parsing address lists that appear in From:, To: and Reply-To: lines\";","objects = {};","string = args[1];","while (e = index(string, \")\"))","if ((s = rindex(string[1..e], \"(#\")) && (#0 != (o = toobj(string[s + 2..e - 1]))))","objects = {@objects, o};","endif","string = string[e + 1..$];","endwhile","return objects;"]},{"name":"display_seq_full","owner":2,"perms":173,"preposition":-1,"code":["\":display_seq_full(msg_seq[,preamble]) => {cur, last-read-date}\";","\"This is the default message display routine.\";","\"Prints entire messages on folder (caller) to player.  msg_seq is the handle returned by :parse_message_seq(...) and indicates which messages should be printed.  preamble, if given will precede the output of the message itself, in which case the message number will be substituted for \\\"%d\\\".  Returns the number of the final message in the sequence (which can be then used as the new current message number).\";","set_task_perms(caller_perms());","{msg_seq, ?preamble = \"\"} = args;","cur = date = 0;","for x in (msgs = caller:messages_in_seq(msg_seq))","cur = x[1];","date = x[2][1];","player:display_message(preamble ? strsub(preamble, \"%d\", tostr(cur)) | {}, caller:msg_full_text(@x[2]));","if ((ticks_left() < 500) || (seconds_left() < 2))","suspend(0);","endif","endfor","return {cur, date};"]},{"name":"display_seq_headers","owner":2,"perms":173,"preposition":-1,"code":["\":display_seq_headers(msg_seq[,cur[,last_read_date]])\";","\"This is the default header display routine.\";","\"Prints a list of headers of messages on caller to player.  msg_seq is the handle returned by caller:parse_message_seq(...).  cur is the player's current message.  last_read_date is the date of the last of the already-read messages.\";","set_task_perms(caller_perms());","{msg_seq, ?cur = 0, ?last_old = $maxint} = args;","keep_seq = {@$seq_utils:contract(caller:kept_msg_seq(), $seq_utils:complement(msg_seq, 1, caller:length_all_msgs())), $maxint};","k = 1;","mcount = 0;","width = player:linelen() || 79;","for x in (msgs = caller:messages_in_seq(msg_seq))","if (keep_seq[k] <= (mcount = mcount + 1))","k = k + 1;","endif","annot = ((d = x[2][1]) > last_old) ? \"+\" | ((k % 2) ? \" \" | \"=\");","line = tostr($string_utils:right(x[1], 4, (cur == x[1]) ? \">\" | \" \"), \":\", annot, \" \", caller:msg_summary_line(@x[2]));","player:tell(line[1..min(width, $)]);","if ((ticks_left() < 500) || (seconds_left() < 2))","suspend(0);","endif","endfor","player:tell(\"----+\");"]},{"name":"rm_message_seq","owner":2,"perms":173,"preposition":-1,"code":["\":rm_message_seq(msg_seq)  removes the given sequence of from folder (caller)\";","\"...removed messages are saved in .messages_going for possible restoration.\";","set_task_perms(caller_perms());","old = caller.messages;","new = save = nums = {};","next = 1;","for i in [1..length(seq = args[1]) / 2]","if ($command_utils:running_out_of_time())","player:tell(\"... rmm \", old[next][1] - 1);","suspend(0);","endif","start = seq[(2 * i) - 1];","new = {@new, @old[next..start - 1]};","save = {@save, {start - next, old[start..(next = seq[2 * i]) - 1]}};","nums = {@nums, old[start][1], old[next - 1][1] + 1};","endfor","new = {@new, @old[next..$]};","$command_utils:suspend_if_needed(0, \"... rmm ...\");","save_kept = $seq_utils:intersection(caller.messages_kept, seq);","$command_utils:suspend_if_needed(0, \"... rmm ...\");","new_kept = $seq_utils:contract(caller.messages_kept, seq);","$command_utils:suspend_if_needed(0, \"... rmm ...\");","caller.messages_going = save_kept ? {save_kept, save} | save;","caller.messages = new;","caller.messages_kept = new_kept;","if ($object_utils:has_callable_verb(caller, \"_fix_last_msg_date\"))","caller:_fix_last_msg_date();","endif","return $seq_utils:tostr(nums);"]},{"name":"undo_rmm","owner":2,"perms":173,"preposition":-1,"code":["\":undo_rmm()  restores previously deleted messages in .messages_going to .messages.\";","set_task_perms(caller_perms());","old = caller.messages;","going = caller.messages_going;","new = seq = {};","last = 0;","next = 1;","\"there are two possible formats here:\";","\"OLD: {{n,msgs},{n,msgs},...}\";","\"NEW: {kept_seq, {{n,msgs},{n,msgs},...}}\";","if (going && ((!going[1]) || (typeof(going[1][2]) == INT)))","kept = going[1];","going = going[2];","else","kept = {};","endif","for s in (going)","new = {@new, @old[last + 1..last + s[1]], @s[2]};","last = last + s[1];","seq = {@seq, next + s[1], next = length(new) + 1};","endfor","caller.messages = {@new, @old[last + 1..$]};","caller.messages_going = {};","caller.messages_kept = $seq_utils:union(kept, $seq_utils:expand(caller.messages_kept, seq));","if ($object_utils:has_callable_verb(caller, \"_fix_last_msg_date\"))","caller:_fix_last_msg_date();","endif","return seq;"]},{"name":"expunge_rmm list_rmm","owner":2,"perms":173,"preposition":-1,"code":["\":list_rmm()    displays contents of .messages_going.\";","\":expunge_rmm() destroys contents of .messages_going once and for all.\";","\"... both return the number of messages in .messages_going.\";","set_task_perms(caller_perms());","cmg = caller.messages_going;","if (cmg && ((!cmg[1]) || (typeof(cmg[1][2]) == INT)))","kept = cmg[1];","cmg = cmg[2];","else","kept = {};","endif","if (verb == \"expunge_rmm\")","caller.messages_going = {};","count = 0;","for s in (cmg)","count = count + length(s[2]);","endfor","return count;","elseif (!cmg)","return 0;","else","msgs = seq = {};","next = 1;","for s in (cmg)","msgs = {@msgs, @s[2]};","seq = {@seq, next = next + s[1], next = next + length(s[2])};","endfor","kept = {@$seq_utils:contract(kept, $seq_utils:complement(seq, 1, $seq_utils:last(seq))), $maxint};","k = 1;","mcount = 0;","for x in (msgs)","if (kept[k] <= (mcount = mcount + 1))","k = k + 1;","endif","player:tell($string_utils:right(x[1], 4), \":\", (k % 2) ? \"  \" | \"= \", caller:msg_summary_line(@x[2]));","if ((ticks_left() < 500) || (seconds_left() < 2))","suspend(0);","endif","endfor","if (msgs)","player:tell(\"----+\");","endif","return length(msgs);","endif"]},{"name":"renumber","owner":2,"perms":173,"preposition":-1,"code":["\":renumber([cur]) -- assumes caller is a $mail_recipient or a $player.\";","\"...renumbers caller.messages, doing a suspend() if necessary.\";","\"...returns {number of messages,new cur}.\";","set_task_perms(caller_perms());","{?cur = 0} = args;","caller.messages_going = {};","\"... blow away @rmm'ed messages since there's no way to tell what their new numbers should be...\";","msgs = caller.messages;","if (cur)","cur = $list_utils:iassoc_sorted(cur, msgs);","endif","while (1)","\"...find first out-of-sequence message...\";","l = 0;","r = (len = length(msgs)) + 1;","while ((r - 1) > l)","if (msgs[i = (r + l) / 2][1] > i)","r = i;","else","l = i;","endif","endwhile","\"... r == first out-of-sequence, l == last in-sequence, l+1 == r ...\";","if (l >= len)","return {l, cur};","endif","\"...renumber as many messages as we have time for...\";","chunk = {};","while (((r <= len) && (ticks_left() > 3000)) && (seconds_left() > 2))","for x in (msgs[r..min(r + 9, len)])","chunk = {@chunk, {r, x[2]}};","r = r + 1;","endfor","endwhile","caller.messages = {@msgs[1..l], @chunk, @msgs[r..len]};","if (chunk)","player:tell(\"...(renumbering \", l + 1, \" -- \", r - 1, \")\");","suspend(0);","else","player:tell(\"You lose.  This message collection is just too big.\");","return;","endif","\"... have to be careful since new mail may be received at this point...\";","msgs = caller.messages;","endwhile"]},{"name":"msg_summary_line","owner":36,"perms":173,"preposition":-1,"code":["\":msg_summary_line(@msg) => date/from/subject as a single string.\";","body = (\"\" in {@args, \"\"}) + 1;","if ((body > length(args)) || (!(subject = args[body])))","subject = \"(None.)\";","endif","if (args[1] < (time() - 31536000))","c = player:ctime(args[1]);","date = c[5..11] + c[21..25];","else","date = player:ctime(args[1])[5..16];","endif","from = args[2];","if (args[4] != \" \")","subject = args[4];","endif","return tostr(date, \"   \", $string_utils:left(from, 20), \"   \", subject);"]},{"name":"parse_message_seq","owner":2,"perms":173,"preposition":-1,"code":["\"parse_message_seq(strings,cur[,last_old])\";","\"This is the default <message-sequence> parsing routine for those mail commands that refer to sequences of messages (@mail, @read,...) on a folder.\";","\"  caller (the folder) is assumed to be a $mail_recipient or a player.\";","\"  strings is the <message-sequence> portion of the arg list.\";","\"  cur is the number of the player's current message for this folder.\";","\"Returns a string error message if the parse fails, otherwise\";","\"returns a list {msg_seq, @unused_strings}, where\";","\"   msg_seq is a handle understood by caller:display_seq_full/headers(), and \";","\"   unused_strings is the list of remaining uninterpreted strings\";","set_task_perms(caller_perms());","{strings, ?cur = 0, ?last_old = 0} = args;","if (!(nummsgs = caller:length_all_msgs()))","return \"%f %<has> no messages.\";","elseif (typeof(strings) != LIST)","strings = {strings};","endif","seq = result = {};","mode = #0;","\"... changes to 0 if we start seeing message numbers, to 1 if we see masks...\";","keywords = \":from:%from:to:%to:subject:body:before:after:since:until:first:last:kept:unkept\";","keyalist = {{1, \"from\"}, {6, \"%from\"}, {12, \"to\"}, {15, \"%to\"}, {19, \"subject\"}, {27, \"body\"}, {32, \"before\"}, {39, \"after\"}, {45, \"since\"}, {51, \"until\"}, {57, \"first\"}, {63, \"last\"}, {68, \"kept\"}, {73, \"unkept\"}};","strnum = 0;","for string in (strings)","strnum = strnum + 1;","$command_utils:suspend_if_needed(0);","if (string && ((c = index(string, \":\")) && ((k = index(keywords, \":\" + string[1..c - 1])) && (k == rindex(keywords, \":\" + string[1..c - 1])))))","\"...we have a mask to apply...\";","keywd = $list_utils:assoc(k, keyalist)[2];","if (mode == #0)","seq = {1, nummsgs + 1};","endif","mode = 1;","if (k <= 27)","\"...from, subject, to, body...\";","pattern = string[c + 1..$];","if (keywd in {\"subject\", \"body\"})","elseif (keywd[1] == \"%\")","pattern = $string_utils:explode(pattern, \"|\");","else","pattern = this:((keywd == \"to\") ? \"_parse_to\" | \"_parse_from\")(pattern);","if (typeof(pattern) == STR)","return pattern;","endif","endif","seq = caller:(keywd + \"_msg_seq\")(pattern, seq);","if (typeof(seq) == STR)","if (strnum == 1)","return seq;","else","seq = {};","endif","endif","elseif (k <= 51)","\"...before, since, after, until...\";","if (typeof(date = this:_parse_date(string[c + 1..$])) != INT)","return tostr(\"Bad date `\", string, \"':  \", date);","endif","s = caller:length_date_le((keywd in {\"before\", \"since\"}) ? date - 1 | (date + 86399));","if (keywd in {\"before\", \"until\"})","seq = $seq_utils:remove(seq, s + 1, nummsgs);","else","seq = $seq_utils:remove(seq, 1, s);","endif","elseif (k <= 63)","\"...first, last...\";","if (n = toint(string[c + 1..$]))","seq = $seq_utils:(keywd + \"n\")(seq, n);","else","return tostr(\"Bad number in `\", string, \"'\");","endif","else","\"...kept, unkept...\";","if (c < length(string))","return tostr(\"Unexpected junk after `\", keywd, \":'\");","elseif ((!(seq = caller:(keywd + \"_msg_seq\")(seq))) && (strnum == 1))","return tostr(\"%f %<has> no \", keywd, \" messages.\");","endif","endif","else","\"...continue building the present sequence...\";","if (mode)","seq && (result = $seq_utils:union(result, seq));","seq = {};","endif","mode = 0;","if (!string)","\"...default case for @read: get the current message but skip to the next one if it's not there...\";","if (cur)","i = min(caller:length_num_le(cur - 1) + 1, nummsgs);","seq = $seq_utils:add(seq, i, i);","else","return \"%f %<has> no current message.\";","endif","elseif ((index(string, \"next\") == 1) && (!index(string, \"-\")))","string[1..4] = \"\";","if ((n = string ? toint(string) | 1) <= 0)","return tostr(\"Bad number `\", string, \"'\");","elseif ((i = caller:length_num_le(cur) + 1) <= nummsgs)","seq = $seq_utils:add(seq, i, min((i + n) - 1, nummsgs));","else","return \"%f %<has> no next message.\";","endif","elseif ((index(string, \"prev\") == 1) && (!index(string, \"-\")))","string[1..4] = \"\";","if ((n = string ? toint(string) | 1) <= 0)","return tostr(\"Bad number `\", string, \"'\");","elseif (i = caller:length_num_le(cur - 1))","seq = $seq_utils:add(seq, max(1, (i - n) + 1), i);","else","return \"%f %<has> no previous message.\";","endif","elseif (string == \"new\")","s = last_old ? caller:length_date_le(last_old) | caller:length_num_le(cur);","if (s < nummsgs)","seq = $seq_utils:add(seq, s + 1, nummsgs);","else","return \"%f %<has> no new messages.\";","endif","elseif (string == \"first\")","seq = $seq_utils:add(seq, 1, 1);","elseif (n = toint(string) || (((string in {\"last\", \"$\"}) && -1) || ((string == \"cur\") && cur)))","if (n <= 0)","seq = $seq_utils:add(seq, max(0, nummsgs + n) + 1, nummsgs);","elseif (i = caller:exists_num_eq(n))","seq = $seq_utils:add(seq, i, i);","else","return (string == \"cur\") ? \"%f's current message has been removed.\" | tostr(\"%f %<has> no message numbered `\", string, \"'.\");","endif","elseif (((i = index(string, \"..\")) > 1) || ((i = index(string, \"-\")) > 1))","if ((start = toint(sst = string[1..i - 1])) > 0)","s = caller:length_num_le(start - 1);","elseif (sst in {\"next\", \"prev\", \"cur\"})","s = max(0, caller:length_num_le(cur - (sst != \"next\")) - (sst == \"prev\"));","elseif (sst in {\"last\", \"$\"})","s = nummsgs - 1;","elseif (sst == \"first\")","s = 0;","else","return {$seq_utils:union(result, seq), @strings[strnum..$]};","endif","j = (string[i] == \".\") ? i + 2 | (i + 1);","if ((end = toint(est = string[j..$])) > 0)","e = caller:length_num_le(end);","elseif (est in {\"next\", \"prev\", \"cur\"})","e = min(nummsgs, caller:length_num_le(cur - (est == \"prev\")) + (est == \"next\"));","elseif (est in {\"last\", \"$\"})","e = nummsgs;","elseif (est == \"first\")","e = 1;","else","return {$seq_utils:union(result, seq), @strings[strnum..$]};","endif","if (s < e)","seq = $seq_utils:add(seq, s + 1, e);","else","return tostr(\"%f %<has> no messages in range \", string, \".\");","endif","elseif (string == \"cur\")","return \"%f %<has> no current message.\";","else","return {$seq_utils:union(result, seq), @strings[strnum..$]};","endif","endif","endfor","return {$seq_utils:union(result, seq)};"]},{"name":"_parse_from _parse_to","owner":36,"perms":173,"preposition":-1,"code":["\":_parse_from(string with |'s in it) => object list\";","\":_parse_to(string with |'s in it) => object list\";","\"  for from:string and to:string items in :parse_message_seq\";","if (verb == \"_parse_to\")","match_obj = fail_obj = this;","match_verb = \"match_recipient\";","fail_verb = \"match_failed\";","else","match_obj = $string_utils;","match_verb = \"match_player\";","fail_obj = $command_utils;","fail_verb = \"player_match_failed\";","endif","plist = {};","for w in ($string_utils:explode(args[1], \"|\"))","if (fail_obj:(fail_verb)(p = match_obj:(match_verb)(w), w))","p = $string_utils:literal_object(w);","if ((p == $failed_match) || (!$command_utils:yes_or_no(\"Continue? \")))","return \"Bad address list:  \" + args[1];","endif","endif","plist = setadd(plist, p);","endfor","return plist;"]},{"name":"_parse_date","owner":36,"perms":173,"preposition":-1,"code":["words = $string_utils:explode(args[1], \"-\");","if (length(words) == 1)","if (index(\"yesterday\", words[1]) == 1)","time = $time_utils:dst_midnight((time() - (time() % 86400)) - 86400);","elseif (index(\"today\", words[1]) == 1)","time = $time_utils:dst_midnight(time() - (time() % 86400));","elseif (typeof(time = $time_utils:from_day(words[1], -1)) == ERR)","time = \"weekday, `Today', `Yesterday', or date expected.\";","endif","elseif ((!words) || ((length(words) > 3) || ((!toint(words[1])) || (E_TYPE == (year = $code_utils:toint({@words, \"-1\"}[3]))))))","time = \"Date should be of the form `5-Jan', `5-Jan-92', `Wed',`Wednesday'\";","else","day = toint(words[1]);","time = $time_utils:dst_midnight($time_utils:from_month(words[2], -1, day));","if (length(words) == 3)","thisyear = toint(ctime(time)[21..24]);","if (100 > year)","year = (thisyear + 50) - (((thisyear - year) + 50) % 100);","endif","time = $time_utils:dst_midnight($time_utils:from_month(words[2], (year - thisyear) - (year <= thisyear), day));","endif","endif","return time;"]},{"name":"new_message_num","owner":2,"perms":173,"preposition":-1,"code":["\":new_message_num() => number that the next incoming message will receive.\";","set_task_perms(caller_perms());","new = (msgs = caller.messages) ? msgs[$][1] + 1 | 1;","if (rmsgs = caller.messages_going)","if ((!rmsgs[1]) || (typeof(rmsgs[1][2]) == INT))","rmsgs = rmsgs[2];","endif","lbrm = rmsgs[$][2];","return max(new, lbrm[$][1] + 1);","else","return new;","endif"]},{"name":"length_all_msgs","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","return length(caller.messages);"]},{"name":"length_date_le","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","date = args[1];","msgs = caller.messages;","if ((r = length(caller.messages)) < 25)","for l in [1..r]","if (msgs[l][2][1] > date)","return l - 1;","endif","endfor","return r;","else","l = 1;","while (l <= r)","if (date < msgs[i = (r + l) / 2][2][1])","r = i - 1;","else","l = i + 1;","endif","endwhile","return r;","endif"]},{"name":"length_date_gt","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","date = args[1];","msgs = caller.messages;","if ((len = length(caller.messages)) < 25)","for r in [0..len - 1]","if (msgs[len - r][2][1] <= date)","return r;","endif","endfor","return len;","else","l = 1;","r = len;","while (l <= r)","if (date < msgs[i = (r + l) / 2][2][1])","r = i - 1;","else","l = i + 1;","endif","endwhile","return len - r;","endif"]},{"name":"length_num_le","owner":2,"perms":173,"preposition":-1,"code":["\":length_num_le(num) => number of messages in folder numbered <= num\";","set_task_perms(caller_perms());","return $list_utils:iassoc_sorted(args[1], caller.messages);"]},{"name":"exists_num_eq","owner":2,"perms":173,"preposition":-1,"code":["\":exists_num_eq(num) => index of message in folder numbered == num\";","set_task_perms(caller_perms());","return (i = $list_utils:iassoc_sorted(args[1], caller.messages)) && ((caller.messages[i][1] == args[1]) && i);"]},{"name":"from_msg_seq","owner":2,"perms":173,"preposition":-1,"code":["\":from_msg_seq(object or list[,mask])\";","\" => msg_seq of messages from any of these senders\";","set_task_perms(caller_perms());","{plist, ?mask = {1}} = args;","if (typeof(plist) != LIST)","plist = {plist};","endif","i = 1;","fseq = {};","for msg in (caller.messages)","if ((!mask) || (i < mask[1]))","elseif ((length(mask) < 2) || (i < mask[2]))","fromline = msg[2][2];","if (toobj(fromline[rindex(fromline, \"(\") + 1..rindex(fromline, \")\") - 1]) in plist)","fseq = $seq_utils:add(fseq, i, i);","endif","else","mask = mask[3..$];","endif","i = i + 1;","$command_utils:suspend_if_needed(0);","endfor","return fseq || (\"%f %<has> no messages from \" + $string_utils:english_list($list_utils:map_arg(2, $string_utils, \"pronoun_sub\", \"%n (%#)\", plist), \"no one\", \" or \"));"]},{"name":"%from_msg_seq","owner":2,"perms":173,"preposition":-1,"code":["\":%from_msg_seq(string or list of strings[,mask])\";","\" => msg_seq of messages with one of these strings in the from line\";","set_task_perms(caller_perms());","{nlist, ?mask = {1}} = args;","if (typeof(nlist) != LIST)","nlist = {nlist};","endif","i = 1;","fseq = {};","for msg in (caller.messages)","if ((!mask) || (i < mask[1]))","elseif ((length(mask) < 2) || (i < mask[2]))","fromline = \" \" + msg[2][2];","for n in (nlist)","if (index(fromline, n))","fseq = $seq_utils:add(fseq, i, i);","endif","endfor","else","mask = mask[3..$];","endif","i = i + 1;","$command_utils:suspend_if_needed(0);","endfor","return fseq || (\"%f %<has> no messages from \" + $string_utils:english_list($list_utils:map_arg($string_utils, \"print\", nlist), \"no one\", \" or \"));"]},{"name":"to_msg_seq","owner":2,"perms":173,"preposition":-1,"code":["\":to_msg_seq(object or list[,mask]) => msg_seq of messages to those people\";","set_task_perms(caller_perms());","{plist, ?mask = {1}} = args;","if (typeof(plist) != LIST)","plist = {plist};","endif","i = 1;","seq = {};","for msg in (caller.messages)","if ((!mask) || (i < mask[1]))","elseif ((length(mask) < 2) || (i < mask[2]))","toline = msg[2][3];","for r in ($mail_agent:parse_address_field(toline))","if (r in plist)","seq = $seq_utils:add(seq, i, i);","endif","endfor","else","mask = mask[3..$];","endif","i = i + 1;","$command_utils:suspend_if_needed(0);","endfor","return seq || (\"%f %<has> no messages to \" + $string_utils:english_list($list_utils:map_arg(2, $string_utils, \"pronoun_sub\", \"%n (%#)\", plist), \"no one\", \" or \"));"]},{"name":"%to_msg_seq","owner":2,"perms":173,"preposition":-1,"code":["\":%to_msg_seq(string or list of strings[,mask])\";","\" => msg_seq of messages containing one of strings in the to line\";","set_task_perms(caller_perms());","{nlist, ?mask = {1}} = args;","if (typeof(nlist) != LIST)","nlist = {nlist};","endif","i = 1;","seq = {};","for msg in (caller.messages)","if ((!mask) || (i < mask[1]))","elseif ((length(mask) < 2) || (i < mask[2]))","toline = \" \" + msg[2][3];","for n in (nlist)","if (index(toline, n))","seq = $seq_utils:add(seq, i, i);","endif","endfor","else","mask = mask[3..$];","endif","i = i + 1;","$command_utils:suspend_if_needed(0);","endfor","return seq || (\"%f %<has> no messages to \" + $string_utils:english_list($list_utils:map_arg($string_utils, \"print\", nlist), \"no one\", \" or \"));"]},{"name":"subject_msg_seq","owner":2,"perms":173,"preposition":-1,"code":["\":subject_msg_seq(target) => msg_seq of messages with target in the Subject:\";","set_task_perms(caller_perms());","{target, ?mask = {1}} = args;","i = 1;","seq = {};","for msg in (caller.messages)","if ((!mask) || (i < mask[1]))","elseif ((length(mask) < 2) || (i < mask[2]))","subject = msg[2][4];","if (index(subject, target))","seq = $seq_utils:add(seq, i, i);","endif","else","mask = mask[3..$];","endif","i = i + 1;","$command_utils:suspend_if_needed(0);","endfor","return seq || ((\"%f %<has> no messages with subjects containing `\" + target) + \"'\");"]},{"name":"body_msg_seq","owner":2,"perms":173,"preposition":-1,"code":["\":body_msg_seq(target[,mask]) => msg_seq of messages with target in the body\";","set_task_perms(caller_perms());","{target, ?mask = {1}} = args;","i = 1;","seq = {};","for msg in (caller.messages)","if ((!mask) || (i < mask[1]))","elseif ({@mask, $maxint}[2] <= i)","mask = mask[3..$];","\"Old code follows. Lets save ticks and munge up the whole message body into one big string and index it. Don't need to know where target is in there, just that it is or isn't there\";","elseif (((bstart = \"\" in (msg = msg[2])) && (length(msg) > bstart)) && index(tostr(@msg[bstart + 1..$]), target))","seq = $seq_utils:add(seq, i, i);","\"elseif ((bstart = \\\"\\\" in (msg = msg[2])) && (l = length(msg)) > bstart)\";","\"while (!index(msg[l], target) && (l = l - 1) > bstart)\";","\"$command_utils:suspend_if_needed(0);\";","\"endwhile\";","\"if (l > bstart)\";","\"seq = $seq_utils:add(seq, i, i);\";","\"endif\";","endif","i = i + 1;","$command_utils:suspend_if_needed(0);","endfor","return seq || tostr(\"%f %<has> no messages containing `\", target, \"' in the body.\");"]},{"name":"messages_in_seq","owner":2,"perms":173,"preposition":-1,"code":["\":messages_in_seq(msg_seq) => list of messages in msg_seq on folder (caller)\";","set_task_perms(caller_perms());","if (typeof(msgs = args[1]) != LIST)","return caller.messages[msgs];","elseif (length(msgs) == 2)","return caller.messages[msgs[1]..msgs[2] - 1];","else","return $seq_utils:extract(msgs, caller.messages);","endif"]},{"name":"__convert_new","owner":2,"perms":173,"preposition":-1,"code":["\":__convert_new(@msg) => msg in new format (if it isn't already)\";","\"               ^ don't forget the @ here.\";","\"If the msg is already in the new format it passes through unchanged.\";","\"If the msg format is unrecognizable, warnings are printed.\";","if (typeof(date = args[1]) != INT)","date = 0;","start = 1;","else","start = 2;","if (!((colon = index(args[2], \":\")) && (args[2][1..colon] in {\"From:\", \"To:\", \"Subject:\"})))","return args;","endif","endif","from = to = 0;","subject = \" \";","blank = \"\" in {@args, \"\"};","newhdr = {};","for line in (args[start..blank - 1])","if (index(line, \"Date:\") == 1)","if (date)","player:notify(\"Warning: two dates?\");","endif","date = $time_utils:from_ctime(line[6..$]);","elseif (index(line, \"From:\") == 1)","if (from)","player:notify(\"Warning: two from-lines?\");","endif","from = $string_utils:triml(line[6..$]);","elseif (index(line, \"To:\") == 1)","if (to)","player:notify(\"Warning: two to-lines?\");","endif","to = $string_utils:triml(line[6..$]);","elseif (index(line, \"Subject:\") == 1)","subject = $string_utils:triml(line[9..$]);","else","newhdr = {@newhdr, line};","endif","endfor","if (!from)","player:notify(\"Warning: no from-line.\");","endif","if (!to)","player:notify(\"Warning: no to-line.\");","endif","return {date, from, to, subject, @newhdr, @args[blank..$]};"]},{"name":"to_text","owner":36,"perms":173,"preposition":-1,"code":["\":to_text(@msg) => message in text form (suitable for printing)\";","return {\"Date:     \" + ctime(args[1]), \"From:     \" + args[2], \"To:       \" + args[3], @(args[4] == \" \") ? {} | {\"Subject:  \" + args[4]}, @args[5..$]};"]},{"name":"is_readable_by is_writable_by is_usable_by","owner":36,"perms":173,"preposition":-1,"code":["what = args[1];","if ($object_utils:isa(what, $mail_recipient))","return what:(verb)(@listdelete(args, 1));","else","\"...it's a player:\";","\"...  anyone can send mail to it.\";","\"...  only the player itself or a wizard can read it.\";","return (verb == \"is_usable_by\") || $perm_utils:controls(args[2], what);","endif"]},{"name":"reserved_pattern","owner":36,"perms":173,"preposition":-1,"code":["\":reserved_pattern(string)\";","\"  if string matches one of the reserved patterns for mailing list names, \";","\"  we return that element of .reserved_patterns.\";","string = args[1];","for p in (this.reserved_patterns)","if (match(string, p[1]))","return p;","endif","endfor","return 0;"]},{"name":"is_recipient","owner":36,"perms":173,"preposition":-1,"code":["return valid(what = args[1]) && (($mail_recipient_class in (ances = $object_utils:ancestors(what))) || ($mail_recipient in ances));"]},{"name":"keep_message_seq","owner":2,"perms":173,"preposition":-1,"code":["\":keep_message_seq(msg_seq)\";","\"...If msg_seq nonempty {}, this marks the indicated messages on this folder (caller)\";","\"...as immune from expiration.\";","\"...If msg_seq == {}, this clears all such marks.\";","set_task_perms(caller_perms());","msg_seq = args[1];","if (!msg_seq)","caller.messages_kept = {};","return 1;","endif","prev_kept = caller.messages_kept;","caller.messages_kept = new_kept = $seq_utils:union(prev_kept, msg_seq);","added = $seq_utils:intersection(new_kept, $seq_utils:complement(prev_kept));","if (!added)","return \"\";","endif","\"... urk.  now we need to get the actual numbers of the messages being kept.\";","nums = {};","start = 0;","for a in (added)","nums = {@nums, (start = !start) ? caller:messages_in_seq(a)[1] | (caller:messages_in_seq(a - 1)[1] + 1)};","endfor","return $seq_utils:tostr(nums);"]},{"name":"kept_msg_seq unkept_msg_seq","owner":2,"perms":173,"preposition":-1,"code":["\":kept_msg_seq([mask])\";","\" => msg_seq of messages that are marked kept\";","\":unkept_msg_seq([mask])\";","\" => msg_seq of messages that are not marked kept\";","set_task_perms(caller_perms());","{?mask = {1}} = args;","if (k = verb == \"kept_msg_seq\")","kseq = $seq_utils:intersection(mask, caller.messages_kept);","else","kseq = $seq_utils:intersection(mask, $seq_utils:range(1, caller:length_all_msgs()), $seq_utils:complement(caller.messages_kept));","endif","return kseq;"]},{"name":"msg_seq_to_msg_num_string","owner":2,"perms":173,"preposition":-1,"code":["\":msg_seq_to_msg_num_string(msg_seq) => string giving the corresponding message numbers\";","set_task_perms(caller_perms());","return $seq_utils:tostr($seq_utils:from_list($list_utils:slice(caller:messages_in_seq(args[1]))));"]},{"name":"msg_seq_to_msg_num_list","owner":2,"perms":173,"preposition":-1,"code":["\":msg_seq_to_msg_num_list(msg_seq) => list of corresponding message numbers\";","set_task_perms(caller_perms());","return $list_utils:slice(caller:messages_in_seq(args[1]));"]},{"name":"send_log_message","owner":36,"perms":173,"preposition":-1,"code":["\"send_log_message(perms,from,rcpt-list,hdrs,msg) -- formats and sends a mail message. hders is either the text of the subject line, or a {subject,{reply-to,...}} list.\";","\"KLUDGE.  this may go away.\";","\"Send a message while supplying a different permission for use by :mail_forward to determine moderation action.\";","\"Return E_PERM unless called by a wizard.\";","\"Return {0, @invalid_rcpts} if rcpt-list contains any invalid addresses.  No mail is sent in this case.\";","\"Return {1, @actual_rcpts} if successful.\";","{perms, from, to, hdrs, msg} = args;","if (caller_perms().wizard)","text = $mail_agent:make_message(from, to, hdrs, msg);","return this:raw_send(text, to, perms);","else","return E_PERM;","endif"]},{"name":"parse_misc_headers","owner":36,"perms":173,"preposition":-1,"code":["\":parse_misc_headers(msg,@extract_names)\";","\"Extracts the miscellaneous (i.e., not including Date: From: To: Subject:)\";","\"from msg (a mail message in the usual transmission format).\";","\"Extract_names is a list of header names\";","\"=> {other_headers,bogus_headers,extract_texts,body}\";","\"where each element of extract_texts is a string or 0\";","\"  according as the corresponding header in extract_names is present.\";","\"bogus_headers is a list of those headers that are undecipherable\";","\"other_headers is a list of {header_name,header_text} for the remaining\";","\"  miscellaneous headers.\";","\"headers in msg\";","msgtxt = args[1];","extract_names = listdelete(args, 1);","extract_texts = $list_utils:make(length(extract_names));","heads = bogus = {};","for h in (msgtxt[5..(bstart = \"\" in {@msgtxt, \"\"}) - 1])","if (m = match(h, \"%([a-z1-9-]+%): +%(.*%)\"))","hname = h[m[3][1][1]..m[3][1][2]];","htext = h[m[3][2][1]..m[3][2][2]];","if (i = hname in extract_names)","extract_texts[i] = htext;","else","heads = {@heads, {hname, htext}};","endif","else","bogus = {@bogus, h};","endif","endfor","return {heads, bogus, extract_texts, msgtxt[bstart + 1..$]};"]},{"name":"resend_message","owner":2,"perms":173,"preposition":-1,"code":["\"resend_message(new_sender,new_rcpts,from,to,hdrs,body)\";","\" -- reformats and resends a previously sent message to new recipients.\";","\"msg is the previous message\";","\"Return E_PERM if new_sender isn't owned by the caller.\";","\"Return {0, @invalid_rcpts} if new_rcpts contains any invalid addresses.  No mail is sent in this case.\";","\"Return {1, @actual_rcpts} if successful.\";","{new_sender, new_rcpts, from, to, hdrs, body} = args;","if (typeof(hdrs) != LIST)","hdrs = {hdrs, 0};","elseif (length(hdrs) < 2)","hdrs = {@hdrs || {\"\"}, 0};","endif","hdrs[3..2] = {{\"Resent-By\", this:name_list(new_sender)}, {\"Resent-To\", this:name_list(@new_rcpts)}};","if ($perm_utils:controls(caller_perms(), new_sender))","text = $mail_agent:make_message(from, to, hdrs, body);","return this:raw_send(text, new_rcpts, new_sender);","else","return E_PERM;","endif"]},{"name":"init_for_core","owner":2,"perms":165,"preposition":-1,"code":["if (caller_perms().wizard)","this.reserved_patterns = {};","`set_verb_code(this, \"raw_send\", verb_code(this, \"raw_send(core)\")) ! ANY';","`delete_verb(this, \"raw_send(core)\") ! ANY';","pass(@args);","endif"]},{"name":"working_on","owner":36,"perms":173,"preposition":-1,"code":["return this:ok(who = args[1]) && tostr(\"a letter \", this:sending(who) ? \"(in transit) \" | \"\", \"to \", this:recipient_names(who), (subject = `this.subjects[who] ! ANY') && tostr(\" entitled \\\"\", subject, \"\\\"\"));"]},{"name":"parse_invoke","owner":36,"perms":173,"preposition":-1,"code":["\"invoke(rcptstrings,verb[,subject]) for a @send\";","\"invoke(1,verb,rcpts,subject,replyto,body) if no parsing is needed\";","\"invoke(2,verb,msg,flags,replytos) for an @answer\";","if (!(which = args[1]))","player:tell_lines({tostr(\"Usage:  \", args[2], \" <list-of-recipients>\"), tostr(\"        \", args[2], \"                      to continue with a previous draft\")});","elseif (typeof(which) == LIST)","\"...@send...\";","if (rcpts = this:parse_recipients({}, which))","if (replyto = player:mail_option(\"replyto\"))","replyto = this:parse_recipients({}, replyto, \".mail_options: \");","endif","if (0 == (subject = {@args, 0}[3]))","if (player:mail_option(\"nosubject\"))","subject = \"\";","else","player:tell(\"Subject:\");","subject = $command_utils:read();","endif","endif","return {rcpts, subject, replyto, {}};","endif","elseif (which == 1)","return args[3..6];","elseif (!(to_subj = this:parse_msg_headers(msg = args[3], flags = args[4])))","else","include = {};","if (\"include\" in flags)","prefix = \">            \";","for line in ($mail_agent:to_text(@msg))","if (!line)","prefix = \">  \";","include = {@include, prefix};","else","include = {@include, @this:fill_string(\">  \" + line, 70, prefix)};","endif","endfor","endif","return {@to_subj, args[5], include};","endif","return 0;"]},{"name":"init_session","owner":36,"perms":173,"preposition":-1,"code":["{who, recip, subj, replyto, msg} = args;","if (this:ok(who))","this.sending[who] = 0;","this.recipients[who] = recip;","this.subjects[who] = subj;","this.replytos[who] = replyto || {};","this:load(who, msg);","this.active[who]:tell(\"Composing \", this:working_on(who));","p = this.active[who];","\"if (p:mail_option(\\\"enter\\\") && !args[5])\";","\"Changed from above so that @reply can take advantage of @mailoption +enter. Ho_Yan 11/9/94\";","if (p:mail_option(\"enter\"))","if (typeof(lines = $command_utils:read_lines()) == ERR)","p:tell(lines);","else","this:insert_line(p in this.active, lines, 0);","endif","endif","endif"]},{"name":"pri*nt","owner":36,"perms":25,"preposition":-1,"code":["if (!dobjstr)","plyr = player;","elseif ($command_utils:player_match_result(plyr = $string_utils:match_player(dobjstr), dobjstr)[1])","return;","endif","if ((plyr != player) && (!this:readable(plyr in this.active)))","player:tell(plyr.name, \"(\", plyr, \") has not published anything here.\");","elseif (typeof(msg = this:message_with_headers(plyr in this.active)) != LIST)","player:tell(msg);","else","player:display_message({((plyr == player) ? \"Your\" | tostr(plyr.name, \"(\", plyr, \")'s\")) + \" message so far:\", \"\"}, player:msg_text(@msg));","endif"]},{"name":"message_with_headers","owner":36,"perms":173,"preposition":-1,"code":["return (this:readable(who = args[1]) || this:ok(who)) && $mail_agent:make_message(this.active[who], this.recipients[who], {this.subjects[who], this.replytos[who]}, this:text(who));"]},{"name":"subj*ect:","owner":36,"perms":89,"preposition":-2,"code":["if (!(who = this:loaded(player)))","player:tell(this:nothing_loaded_msg());","elseif (!argstr)","player:tell(this.subjects[who]);","elseif (ERR == typeof(subj = this:set_subject(who, argstr)))","player:tell(subj);","else","player:tell(subj ? (\"Setting the subject line for your message to \\\"\" + subj) + \"\\\".\" | \"Deleting the subject line for your message.\");","endif"]},{"name":"set_subject","owner":36,"perms":173,"preposition":-1,"code":["if (!(fuckup = this:ok(who = args[1])))","return fuckup;","else","this.subjects[who] = subj = args[2];","this:set_changed(who, 1);","return subj;","endif"]},{"name":"sending","owner":36,"perms":173,"preposition":-1,"code":["if (!(fuckup = this:ok(who = args[1])))","return fuckup;","elseif ((!(task = this.sending[who])) || $code_utils:task_valid(task))","return task;","else","\"... uh oh... sending task crashed...\";","this:set_changed(who, 1);","return this.sending[who] = 0;","endif"]},{"name":"to*:","owner":36,"perms":89,"preposition":-2,"code":["if (!(who = this:loaded(player)))","player:tell(this:nothing_loaded_msg());","elseif (!args)","player:tell(\"Your message is currently to \", this:recipient_names(who), \".\");","else","this.recipients[who] = this:parse_recipients({}, args);","this:set_changed(who, 1);","player:tell(\"Your message is now to \", this:recipient_names(who), \".\");","endif"]},{"name":"also*-to: cc*:","owner":36,"perms":89,"preposition":-2,"code":["if (!(who = this:loaded(player)))","player:tell(this:nothing_loaded_msg());","else","this.recipients[who] = this:parse_recipients(this.recipients[who], args);","this:set_changed(who, 1);","player:tell(\"Your message is now to \", this:recipient_names(who), \".\");","endif"]},{"name":"not-to*: uncc*:","owner":36,"perms":89,"preposition":-2,"code":["if (!(who = this:loaded(player)))","player:tell(this:nothing_loaded_msg());","else","recips = this.recipients[who];","nonmrs = {};","mrs = {};","for o in (recips)","if ($object_utils:isa(o, $mail_recipient))","mrs = {@mrs, o};","else","nonmrs = {@nonmrs, o};","endif","endfor","for a in (args)","if (!a)","player:tell(\"\\\"\\\"?\");","return;","elseif (valid(aobj = $mail_agent:match_recipient(a)) && (aobj in recips))","elseif ($failed_match != (aobj = $string_utils:literal_object(a)))","if (!(aobj in recips))","player:tell(aobj, \" was not a recipient.\");","return;","endif","elseif ((a[1] == \"*\") && valid(aobj = $string_utils:match(a[2..$], mrs, \"aliases\")))","elseif ((a[1] != \"*\") && valid(aobj = $string_utils:match(a, nonmrs, \"aliases\")))","elseif (valid(aobj = $string_utils:match(a, recips, \"aliases\")))","else","player:tell(\"couldn't find \\\"\", a, \"\\\" in To: list.\");","return;","endif","recips = setremove(recips, aobj);","endfor","this.recipients[who] = recips;","this:set_changed(who, 1);","player:tell(\"Your message is now to \", this:recipient_names(who), \".\");","endif"]},{"name":"parse_recipients","owner":36,"perms":173,"preposition":-1,"code":["\"parse_recipients(prev_list,list_of_strings) -- parses list of strings and adds any resulting player objects to prev_list.  Optional 3rd arg is prefixed to any mismatch error messages\";","{recips, l, ?cmd_id = \"\"} = args;","cmd_id = cmd_id || \"\";","for s in ((typeof(l) == LIST) ? l | {l})","if (typeof(s) != STR)","if ($mail_agent:is_recipient(s))","recips = setadd(recips, s);","else","player:tell(cmd_id, s, \" is not a valid mail recipient.\");","endif","elseif (!$mail_agent:match_failed(md = $mail_agent:match_recipient(s), s, cmd_id))","recips = setadd(recips, md);","endif","endfor","return recips;"]},{"name":"recipient_names","owner":36,"perms":173,"preposition":-1,"code":["return this:ok(who = args[1]) && $mail_agent:name_list(@this.recipients[who]);"]},{"name":"make_message","owner":36,"perms":173,"preposition":-1,"code":["return $mail_agent:make_message(@args);"]},{"name":"name_list","owner":36,"perms":173,"preposition":-1,"code":["\"(obsolete verb... see $mail_agent:name_list)\";","return $mail_agent:(verb)(@args[1]);"]},{"name":"parse_msg_headers","owner":36,"perms":173,"preposition":-1,"code":["\"parse_msg_headers(msg,flags)\";","\"  parses msg to extract reply recipients and construct a subject line\";","\"  if the \\\"all\\\" flag is present, reply goes to all of the original recipients\";","\"  returns a list {recipients, subjectline} or 0 in case of error.\";","{msg, flags} = args;","replyall = \"all\" in flags;","objects = {};","if (\"followup\" in flags)","\"...look for first non-player recipient in To: line...\";","for o in ($mail_agent:parse_address_field(msg[3]))","if (objects)","break o;","elseif ($object_utils:isa(o, $mail_recipient))","objects = {o};","endif","endfor","endif","objects = objects || $mail_agent:parse_address_field(msg[2] + (replyall ? msg[3] | \"\"));","for line in (msg[5..(\"\" in {@msg, \"\"}) - 1])","if (rt = index(line, \"Reply-to:\") == 1)","objects = $mail_agent:parse_address_field(line);","endif","endfor","recips = {};","for o in (objects)","if (o == #0)","player:tell(\"Sorry, but I can't parse the header of that message.\");","return 0;","elseif ((!valid(o)) || (!(is_player(o) || ($mail_recipient in $object_utils:ancestors(o)))))","player:tell(o, \" is no longer a valid player or maildrop; ignoring that recipient.\");","elseif (o != player)","recips = setadd(recips, o);","endif","endfor","subject = msg[4];","if (subject == \" \")","subject = \"\";","elseif (subject && (index(subject, \"Re: \") != 1))","subject = \"Re: \" + subject;","endif","return {recips, subject};"]},{"name":"check_answer_flags","owner":36,"perms":173,"preposition":-1,"code":["flags = {};","for o in ({\"all\", \"include\", \"followup\"})","if (player:mail_option(o))","flags = {@flags, o};","endif","endfor","reply_to = player:mail_option(\"replyto\") || {};","flaglist = \"+1#include -1#noinclude +2#all -2#sender 0#replyto +3#followup \";","for a in (args)","if (i = index(a, \"=\"))","value = a[i + 1..$];","a = a[1..i - 1];","else","value = \"\";","endif","if ((typeof(a) != STR) || ((i = index(flaglist, \"#\" + a)) < 3))","player:tell(\"Unrecognized answer/reply option:  \", a);","return 0;","elseif (i != rindex(flaglist, \"#\" + a))","player:tell(\"Ambiguous answer/reply option:  \", a);","return 0;","elseif (j = index(\"0123456789\", flaglist[i - 1]) - 1)","if (value)","player:tell(\"Flag does not take a value:  \", a);","return 0;","endif","f = {\"include\", \"all\", \"followup\"}[j];","flags = (flaglist[i - 2] == \"+\") ? setadd(flags, f) | setremove(flags, f);","if (f == \"all\")","flags = setremove(flags, \"followup\");","endif","elseif ((!value) || (value = this:parse_recipients({}, $string_utils:explode(value), \"replyto flag:  \")))","reply_to = value || {};","endif","endfor","return {flags, reply_to};"]},{"name":"reply-to*: replyto*:","owner":36,"perms":89,"preposition":-2,"code":["if (!(who = this:loaded(player)))","player:tell(this:nothing_loaded_msg());","else","if (args)","this.replytos[who] = rt = this:parse_recipients({}, args);","this:set_changed(who, 1);","else","rt = this.replytos[who];","endif","player:tell(rt ? (\"Replies will go to \" + $mail_agent:name_list(@this.replytos[who])) + \".\" | \"Reply-to field is empty.\");","endif"]},{"name":"send","owner":2,"perms":9,"preposition":-1,"code":["\"WIZARDLY\";","if (!(who = this:loaded(player)))","player:notify(this:nothing_loaded_msg());","elseif (!(recips = this.recipients[who]))","player:notify(\"Umm... your message isn't addressed to anyone.\");","elseif (this:sending(who))","player:notify(\"Again? ... relax... it'll get there eventually.\");","else","msg = this:message_with_headers(who);","this.sending[who] = old_sending = task_id();","this:set_changed(who, 0);","player:notify(\"Sending...\");","\"... this sucker can suspend BIG TIME...\";","result = $mail_agent:raw_send(msg, recips, player);","\"... the world changes...\";","who = player in this.active;","if (who && (this.sending[who] == old_sending))","\"... same editing session; no problemo...\";","previous = \"\";","this.sending[who] = 0;","else","\"... uh oh, different session... tiptoe quietly out...\";","\"... Don't mess with the session.\";","previous = \"(prior send) \";","endif","if (!(e = result[1]))","player:notify(tostr(previous, (typeof(e) == ERR) ? e | (\"Bogus recipients:  \" + $string_utils:from_list(result[2]))));","player:notify(tostr(previous, \"Mail not sent.\"));","previous || this:set_changed(who, 1);","elseif (length(result) == 1)","player:notify(tostr(previous, \"Mail not actually sent to anyone.\"));","previous || this:set_changed(who, 1);","else","player:notify(tostr(previous, \"Mail actually sent to \", $mail_agent:name_list(@listdelete(result, 1))));","if (previous)","\"...don't even think about it...\";","elseif (player.location == this)","if (ticks_left() < 10000)","suspend(0);","endif","this:done();","elseif (!this:changed(who))","\"... player is gone, no further edits...\";","this:kill_session(who);","endif","endif","endif"]},{"name":"who","owner":36,"perms":29,"preposition":-1,"code":["if (dobjstr)","if (!(recips = this:parse_recipients({}, args)))","\"parse_recipients has already complained about anything it doesn't like\";","return;","endif","elseif (caller != player)","return E_PERM;","elseif (!(who = this:loaded(player)))","player:tell(this:nothing_loaded_msg());","return;","else","recips = this.recipients[who];","endif","resolve = $mail_agent:resolve_addr(recips, player);","if (resolve[1])","player:tell(\"Bogus addresses:  \", $string_utils:english_list(resolve[1]));","else","player:tell(dobjstr ? (\"Mail to \" + $mail_agent:name_list(@recips)) + \" actually goes to \" | \"Your mail will actually go to \", $mail_agent:name_list(@resolve[2]));","endif"]},{"name":"showlists","owner":36,"perms":25,"preposition":-1,"code":["player:tell_lines({\"Available aliases:\", \"\"});","for c in ((dobjstr == \"all\") ? $object_utils:descendants($mail_recipient) | $mail_agent.contents)","if (c:is_usable_by(player) || c:is_readable_by(player))","c:look_self();","endif","endfor"]},{"name":"subsc*ribe","owner":36,"perms":89,"preposition":1,"code":["player:tell(\"This command is obsolete.  Use @subscribe instead.  See `help @subscribe'\");","return;","if (!iobjstr)","player:tell(\"Usage:  \", verb, \" [<list-of-people/lists>] to <list>\");","return;","elseif ($mail_agent:match_failed(iobj = $mail_agent:match(iobjstr), iobjstr))","return;","endif","rstrs = dobjstr ? $string_utils:explode(dobjstr) | {\"me\"};","recips = this:parse_recipients({}, rstrs);","outcomes = iobj:add_forward(@recips);","if (typeof(outcomes) != LIST)","player:tell(outcomes);","return;","endif","added = {};","for r in [1..length(recips)]","if ((t = typeof(e = outcomes[r])) == OBJ)","added = setadd(added, recips[r]);","else","player:tell(verb, \" \", recips[r].name, \" to \", iobj.name, \":  \", e);","endif","endfor","if (added)","player:tell($string_utils:english_list($list_utils:map_arg(2, $string_utils, \"pronoun_sub\", \"%(name) (%#)\", added)), \" added to \", iobj.name, \" (\", iobj, \")\");","endif"]},{"name":"unsubsc*ribe","owner":36,"perms":89,"preposition":5,"code":["if (!iobjstr)","player:tell(\"Usage:  \", verb, \" [<list-of-people/lists>] from <list>\");","return;","elseif ($mail_agent:match_failed(iobj = $mail_agent:match(iobjstr), iobjstr))","return;","endif","rstrs = dobjstr ? $string_utils:explode(dobjstr) | {\"me\"};","recips = this:parse_recipients({}, rstrs);","outcomes = iobj:delete_forward(@recips);","if (typeof(outcomes) != LIST)","player:tell(outcomes);","return;","endif","removed = {};","for r in [1..length(recips)]","if (typeof(e = outcomes[r]) == ERR)","player:tell(verb, \" \", recips[r].name, \" from \", iobj.name, \":  \", (e == E_INVARG) ? \"Not on list.\" | e);","else","removed = setadd(removed, recips[r]);","endif","endfor","if (removed)","player:tell($string_utils:english_list($list_utils:map_arg(2, $string_utils, \"pronoun_sub\", \"%(name) (%#)\", removed)), \" removed from \", iobj.name, \" (\", iobj, \")\");","endif"]},{"name":"retain_session_on_exit","owner":36,"perms":173,"preposition":-1,"code":["return this:ok(who = args[1]) && (this:sending(who) || pass(@args));"]},{"name":"no_littering_msg","owner":36,"perms":173,"preposition":-1,"code":["\"recall that this only gets called if :retain_session_on_exit returns true\";","return (this:ok(who = player in this.active) && (!this:changed(who))) ? {\"Your message is in transit.\"} | this.(verb);"]},{"name":"parse_msg_headers(slow)","owner":36,"perms":173,"preposition":-1,"code":["\"parse_msg_headers(msg,flags)\";","\"  parses msg to extract reply recipients and construct a subject line\";","\"  if the \\\"all\\\" flag is present, reply goes to all of the original recipients\";","\"  returns a list {recipients, subjectline} or 0 in case of error.\";","msg = args[1];","replyall = \"all\" in args[2];","recipients = $mail_agent:parse_address_field(msg[2] + (replyall ? msg[3] | \"\"));","subject = msg[4];","if (subject == \" \")","subject = \"\";","endif","noreplyto = 1;","for line in (msg[1..(\"\" in msg) || length(msg)])","if (typeof(line) != STR)","\"Skip it\";","elseif (index(line, \"Subject:\") == 1)","subject = $string_utils:triml(line[9..length(line)]);","elseif ((rt = index(line, \"Reply-to:\") == 1) || (noreplyto && ((index(line, \"From:\") == 1) || (replyall && (index(line, \"To:\") == 1)))))","if (rt)","noreplyto = 0;","recipients = {};","endif","recipients = {@recipients, @$mail_agent:parse_address_field(line)};","endif","endfor","if (subject && (index(subject, \"Re: \") != 1))","subject = \"Re: \" + subject;","endif","recips = {};","for o in (recipients)","if (o == #0)","player:tell(\"Sorry, but I can't parse the header of that message.\");","return 0;","elseif ((!valid(o)) || (!(is_player(o) || ($mail_recipient in $object_utils:ancestors(o)))))","player:tell(o, \" is no longer a valid player or maildrop; ignoring that recipient.\");","elseif (o != player)","recips = setadd(recips, o);","endif","endfor","return {recips, subject};"]},{"name":"local_editing_info","owner":36,"perms":173,"preposition":-1,"code":["lines = {\"To:       \" + (toline = $mail_agent:name_list(@args[1])), \"Subject:  \" + $string_utils:trim(subject = args[2])};","if (args[3])","lines = {@lines, \"Reply-to: \" + $mail_agent:name_list(@args[3])};","endif","lines = {@lines, \"\", @args[4]};","return {tostr(\"MOOMail\", subject ? (\"(\" + subject) + \")\" | ((\"-to(\" + toline) + \")\")), lines, \"@@sendmail\"};"]},{"name":"e*dit","owner":36,"perms":25,"preposition":-1,"code":["if (this:changed(who = player in this.active))","player:tell(\"You are still editing \", this:working_on(who), \".  Please type ABORT or SAVE first.\");","elseif (spec = this:parse_invoke(dobjstr, verb))","this:init_session(who, @spec);","endif"]},{"name":"save","owner":36,"perms":25,"preposition":-1,"code":["if (!(who = this:loaded(player)))","player:tell(this:nothing_loaded_msg());","return;","endif","if (!dobjstr)","note = this.objects[who];","elseif (1 == (note = this:note_match_failed(dobjstr)))","return;","else","this.objects[who] = note;","endif","text = this:text(who);","strmode = (length(text) <= 1) && this.strmode[who];","if (strmode)","text = text ? text[1] | \"\";","endif","if (ERR == typeof(result = this:set_note_text(note, text)))","player:tell(\"Text not saved to \", this:working_on(who), \":  \", result);","if ((result == E_TYPE) && (typeof(note) == OBJ))","player:tell(\"Do `mode list' and try saving again.\");","elseif (!dobjstr)","player:tell(\"Use `save' with an argument to save the text elsewhere.\");","endif","else","player:tell(\"Text written to \", this:working_on(who), strmode ? \" as a single string.\" | \".\");","this:set_changed(who, 0);","endif"]},{"name":"init_session","owner":36,"perms":173,"preposition":-1,"code":["if (this:ok(who = args[1]))","this.strmode[who] = strmode = typeof(text = args[3]) == STR;","this:load(who, strmode ? text ? {text} | {} | text);","this.objects[who] = args[2];","player:tell(\"Now editing \", this:working_on(who), \".\", strmode ? \"  [string mode]\" | \"\");","endif"]},{"name":"working_on","owner":36,"perms":173,"preposition":-1,"code":["if (!(who = args[1]))","return \"????\";","endif","spec = this.objects[who];","if (typeof(spec) == LIST)","object = spec[1];","prop = spec[2];","else","object = spec;","prop = 0;","endif","return valid(object) ? tostr(\"\\\"\", object.name, \"\\\"(\", object, \")\", prop ? \".\" + prop | \"\") | tostr(prop ? (\".\" + prop) + \" on \" | \"\", \"invalid object (\", object, \")\");"]},{"name":"parse_invoke","owner":36,"perms":173,"preposition":-1,"code":["\":parse_invoke(string,verb)\";","\" string is the actual commandline string indicating what we are to edit\";","\" verb is the command verb that is attempting to invoke the editor\";","if (!(string = args[1]))","player:tell_lines({(\"Usage:  \" + args[2]) + \" <note>   (where <note> is some note object)\", (\"        \" + args[2]) + \"          (continues editing an unsaved note)\"});","elseif (1 == (note = this:note_match_failed(string)))","elseif (ERR == typeof(text = this:note_text(note)))","player:tell(\"Couldn't retrieve text:  \", text);","else","return {note, text};","endif","return 0;"]},{"name":"note_text","owner":2,"perms":173,"preposition":-1,"code":["\"WIZARDLY\";","if ((caller != $note_editor) || (caller_perms() != $note_editor.owner))","return E_PERM;","endif","set_task_perms(player);","if (typeof(spec = args[1]) == OBJ)","text = spec:text();","else","text = `spec[1].(spec[2]) ! ANY';","endif","if (((tt = typeof(text)) in {ERR, STR}) || ((tt == LIST) && ((!text) || (typeof(text[1]) == STR))))","return text;","else","return E_TYPE;","endif"]},{"name":"set_note_text","owner":2,"perms":173,"preposition":-1,"code":["\"WIZARDLY\";","if ((caller != $note_editor) || (caller_perms() != $note_editor.owner))","return E_PERM;","endif","set_task_perms(player);","attempt = E_NONE;","if (typeof(spec = args[1]) == OBJ)","return spec:set_text(args[2]);","elseif ($object_utils:has_callable_verb(spec[1], \"set_\" + spec[2]))","attempt = spec[1]:(\"set_\" + spec[2])(args[2]);","endif","if (typeof(attempt) == ERR)","return `spec[1].(spec[2]) = args[2] ! ANY';","else","return attempt;","endif"]},{"name":"note_match_failed","owner":36,"perms":173,"preposition":-1,"code":["if (pp = $code_utils:parse_propref(string = args[1]))","object = pp[1];","prop = pp[2];","else","object = string;","prop = 0;","endif","if ($command_utils:object_match_failed(note = player:my_match_object(object, this:get_room(player)), object))","elseif (prop)","if (!$object_utils:has_property(note, prop))","player:tell(object, \" has no \\\".\", prop, \"\\\" property.\");","else","return {note, prop};","endif","elseif ((!$object_utils:has_callable_verb(note, \"text\")) || (!$object_utils:has_callable_verb(note, \"set_text\")))","return {note, \"description\"};","\"... what we used to do.  but why barf?   that's no fun...\";","player:tell(object, \"(\", note, \") doesn't look like a note.\");","else","return note;","endif","return 1;"]},{"name":"w*hat","owner":36,"perms":9,"preposition":-1,"code":["pass(@args);","if ((who = this:loaded(player)) && this.strmode[who])","player:tell(\"Text will be stored as a single string instead of a list when possible.\");","endif"]},{"name":"mode","owner":36,"perms":25,"preposition":-1,"code":["\"mode [string|list]\";","if (!(who = this:loaded(player)))","player:tell(this:nothing_loaded_msg());","return;","endif","if (dobjstr && (index(\"string\", dobjstr) == 1))","this.strmode[who] = mode = 1;","player:tell(\"Now in string mode:\");","elseif (dobjstr && (index(\"list\", dobjstr) == 1))","this.strmode[who] = mode = 0;","player:tell(\"Now in list mode:\");","elseif (dobjstr)","player:tell(\"Unrecognized mode:  \", dobjstr);","player:tell(\"Should be one of `string' or `list'\");","return;","else","player:tell(\"Currently in \", mode = this.strmode[who] ? \"string \" | \"list \", \"mode:\");","endif","if (mode)","player:tell(\"  store text as a single string instead of a list when possible.\");","else","player:tell(\"  always store text as a list of strings.\");","endif"]},{"name":"local_editing_info","owner":36,"perms":173,"preposition":-1,"code":["{what, text} = args;","cmd = (typeof(text) == STR) ? \"@set-note-string\" | \"@set-note-text\";","name = (typeof(what) == OBJ) ? what.name | tostr(what[1].name, \".\", what[2]);","note = (typeof(what) == OBJ) ? what | tostr(what[1], \".\", what[2]);","return {name, text, tostr(cmd, \" \", note)};"]},{"name":"set_*","owner":36,"perms":173,"preposition":-1,"code":["if ($perm_utils:controls(caller_perms(), this))","return pass(@args);","else","return E_PERM;","endif"]},{"name":"e*dit","owner":36,"perms":25,"preposition":-1,"code":["if (!args)","player:tell(\"edit what?\");","else","this:invoke(argstr, verb);","endif"]},{"name":"com*pile save","owner":36,"perms":73,"preposition":-2,"code":["pas = {{}, {}};","if (!(who = this:loaded(player)))","player:tell(this:nothing_loaded_msg());","return;","elseif (!args)","object = this.objects[who];","vname = this.verbnames[who];","if (typeof(vname) == LIST)","vargs = listdelete(vname, 1);","vname = vname[1];","else","vargs = {};","endif","changeverb = 0;","elseif ((args[1] != \"as\") || ((length(args) < 2) || ((!(spec = $code_utils:parse_verbref(args[2]))) || ((typeof(pas = $code_utils:parse_argspec(@args[3..$])) != LIST) || pas[2]))))","if (typeof(pas) != LIST)","player:tell(pas);","elseif (pas[2])","player:tell(\"I don't understand \\\"\", $string_utils:from_list(pas[2], \" \"), \"\\\"\");","endif","player:tell(\"Usage: \", verb, \" [as <object>:<verb>]\");","return;","elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1], this:get_room(player)), spec[1]))","return;","else","vname = spec[2];","vargs = pas[1] && {@pas[1], \"none\", \"none\"}[1..3];","if (vargs)","vargs[2] = $code_utils:full_prep(vargs[2]) || vargs[2];","endif","changeverb = 1;","endif","if (vargs)","vnum = $code_utils:find_verb_named(object, vname);","while (vnum && (verb_args(object, vnum) != vargs))","vnum = $code_utils:find_verb_named(object, vname, vnum + 1);","endwhile","if (!vnum)","player:tell(\"There is no \", object, \":\", vname, \" verb with args (\", $string_utils:from_list(vargs, \" \"), \").\");","if (!changeverb)","player:tell(\"Use 'compile as ...' to write your code to another verb.\");","endif","return;","endif","objverbname = tostr(object, \":\", vname, \" (\", $string_utils:from_list(vargs, \" \"), \")\");","else","vnum = 0;","objverbname = tostr(object, \":\", ($code_utils:toint(vname) == E_TYPE) ? vname | this:verb_name(object, vname));","endif","\"...\";","\"...perform eval_subs on verb code if necessary...\";","\"...\";","if (player.eval_subs && player:edit_option(\"eval_subs\"))","verbcode = {};","for x in (this:text(who))","verbcode = {@verbcode, $code_utils:substitute(x, player.eval_subs)};","endfor","else","verbcode = this:text(who);","endif","\"...\";","\"...write it out...\";","\"...\";","if (result = this:set_verb_code(object, vnum ? vnum | vname, verbcode))","player:tell(objverbname, \" not compiled because:\");","for x in (result)","player:tell(\"  \", x);","endfor","elseif (typeof(result) == ERR)","player:tell({result, (\"You do not have write permission on \" + objverbname) + \".\", (\"The verb \" + objverbname) + \" does not exist (!?!)\", (\"The object \" + tostr(object)) + \" does not exist (!?!)\"}[1 + (result in {E_PERM, E_VERBNF, E_INVARG})]);","if (!changeverb)","player:tell(\"Do 'compile as <object>:<verb>' to write your code to another verb.\");","endif","changeverb = 0;","else","player:tell(objverbname, verbcode ? \" successfully compiled.\" | \" verbcode removed.\");","this:set_changed(who, 0);","endif","if (changeverb)","this.objects[who] = object;","this.verbnames[who] = vargs ? {vname, @vargs} | vname;","endif"]},{"name":"working_on","owner":36,"perms":173,"preposition":-1,"code":["if (!(fuckup = this:ok(who = args[1])))","return fuckup;","else","object = this.objects[who];","verbname = this.verbnames[who];","if (typeof(verbname) == LIST)","return tostr(object, \":\", verbname[1], \" (\", $string_utils:from_list(listdelete(verbname, 1), \" \"), \")\");","else","return tostr(object, \":\", this:verb_name(object, verbname), \" (\", this:verb_args(object, verbname), \")\");","endif","endif","\"return this:ok(who = args[1]) && tostr(this.objects[who]) + \\\":\\\" + this.verbnames[who];\";"]},{"name":"init_session","owner":36,"perms":173,"preposition":-1,"code":["{who, object, vname, vcode} = args;","if (this:ok(who))","this:load(who, vcode);","this.verbnames[who] = vname;","this.objects[who] = object;","this.active[who]:tell(\"Now editing \", this:working_on(who), \".\");","\"this.active[who]:tell(\\\"Now editing \\\", object, \\\":\\\", vname, \\\".\\\");\";","endif"]},{"name":"parse_invoke","owner":36,"perms":173,"preposition":-1,"code":["\":parse_invoke(string,v,?code)\";","\"  string is the commandline string to parse to obtain the obj:verb to edit\";","\"  v is the actual command verb used to invoke the editor\";","\" => {object, verbname, verb_code} or error\";","vref = $string_utils:words(args[1]);","if ((!vref) || (!(spec = $code_utils:parse_verbref(vref[1]))))","player:tell(\"Usage: \", args[2], \" object:verb\");","return;","endif","if (argspec = listdelete(vref, 1))","if (typeof(pas = $code_utils:parse_argspec(@argspec)) == LIST)","if (pas[2])","player:tell(\"I don't understand \\\"\", $string_utils:from_list(pas[2], \" \"), \"\\\"\");","return;","endif","argspec = {@pas[1], \"none\", \"none\"}[1..3];","argspec[2] = $code_utils:full_prep(argspec[2]) || argspec[2];","else","player:tell(pas);","return;","endif","endif","if (!$command_utils:object_match_failed(object = player:my_match_object(spec[1], this:get_room(player)), spec[1]))","vnum = $code_utils:find_verb_named(object, vname = spec[2]);","if (argspec)","while (vnum && (verb_args(object, vnum) != argspec))","vnum = $code_utils:find_verb_named(object, vname, vnum + 1);","endwhile","endif","if (length(args) > 2)","code = args[3];","elseif (vnum)","code = this:fetch_verb_code(object, vnum);","else","code = E_VERBNF;","endif","if (typeof(code) == ERR)","player:tell((code != E_VERBNF) ? code | \"That object does not define that verb\", argspec ? \" with those args.\" | \".\");","return code;","else","return {object, argspec ? {vname, @argspec} | vname, code};","endif","endif","return 0;"]},{"name":"fetch_verb_code","owner":2,"perms":173,"preposition":-1,"code":["\"WIZARDLY\";","if ((caller != $verb_editor) || (caller_perms() != $verb_editor.owner))","return E_PERM;","else","set_task_perms(player);","return `verb_code(args[1], args[2], !player:edit_option(\"no_parens\")) ! ANY';","endif"]},{"name":"set_verb_code","owner":2,"perms":173,"preposition":-1,"code":["\"WIZARDLY\";","if ((caller != $verb_editor) || (caller_perms() != $verb_editor.owner))","return E_PERM;","else","set_task_perms(player);","return `set_verb_code(args[1], args[2], args[3]) ! ANY';","endif"]},{"name":"local_editing_info","owner":2,"perms":173,"preposition":-1,"code":["if (caller == $verb_editor)","set_task_perms(player);","endif","{object, vname, code} = args;","if (typeof(vname) == LIST)","vargs = tostr(\" \", vname[2], \" \", $code_utils:short_prep(vname[3]), \" \", vname[4]);","vname = vname[1];","else","vargs = \"\";","endif","name = tostr(object.name, \":\", vname);","\"... so the next 2 lines are actually wrong, since verb_info won't\";","\"... necessarily retrieve the correct verb if we have more than one\";","\"... matching the given same name; anyway, if parse_invoke understood vname,\";","\"... so will @program.  I suspect these were put here because in the\";","\"... old scheme of things, vname was always a number.\";","\"vname = strsub($string_utils:explode(verb_info(object, vname)[3])[1], \\\"*\\\", \\\"\\\")\";","\"vargs = verb_args(object, vname)\";","\"\";","return {name, code, tostr(\"@program \", object, \":\", vname, vargs)};"]},{"name":"verb_name","owner":2,"perms":173,"preposition":-1,"code":["\"verb_name(object, vname)\";","\"Find vname on object and return its full name (quoted).\";","\"This is useful for when we're working with verb numbers.\";","if ((caller != $verb_editor) || (caller_perms() != $verb_editor.owner))","return E_PERM;","else","set_task_perms(player);","given = args[2];","if (typeof(info = `verb_info(args[1], given) ! ANY') == ERR)","return tostr(given, \"[\", info, \"]\");","elseif (info[3] == given)","return given;","else","return tostr(given, \"/\\\"\", info[3], \"\\\"\");","endif","endif"]},{"name":"verb_args","owner":2,"perms":173,"preposition":-1,"code":["\"verb_name(object, vname)\";","\"Find vname on object and return its full name (quoted).\";","\"This is useful for when we're working with verb numbers.\";","if ((caller != $verb_editor) || (caller_perms() != $verb_editor.owner))","return E_PERM;","else","set_task_perms(player);","return $string_utils:from_list(`verb_args(args[1], args[2]) ! ANY', \" \");","endif"]},{"name":"comment","owner":36,"perms":89,"preposition":-2,"code":["\"Syntax: comment [<range>]\";","\"\";","\"Turns the specified range of lines, into comments.\";","if ((caller != player) && (caller_perms() != player))","return E_PERM;","elseif (!(who = this:loaded(player)))","player:tell(this:nothing_loaded_msg());","elseif (typeof(range = this:parse_range(who, {\".\"}, @args)) != LIST)","player:tell(tostr(range));","elseif (range[3])","player:tell_lines($code_utils:verb_documentation());","else","text = this.texts[who];","{from, to, crap} = range;","cut = $maxint;","for line in [from..to]","cut = min(cut, `match(text[line], \"[^ ]\")[1] ! E_RANGE => 1');","endfor","for line in [from..to]","text[line] = toliteral(text[line][cut..$]) + \";\";","endfor","this.texts[who] = text;","player:tell((to == from) ? \"Line\" | \"Lines\", \" changed.\");","this.changes[who] = 1;","this.times[who] = time();","endif"]},{"name":"uncomment","owner":36,"perms":89,"preposition":-2,"code":["\"Syntax: uncomment [<range>]\";","\"\";","\"Turns the specified range of lines from comments to, uh, not comments.\";","if ((caller != player) && (caller_perms() != player))","return E_PERM;","elseif (!(who = this:loaded(player)))","player:tell(this:nothing_loaded_msg());","elseif (typeof(range = this:parse_range(who, {\".\"}, @args)) != LIST)","player:tell(tostr(range));","elseif (range[3])","player:tell_lines($code_utils:verb_documentation());","else","text = this.texts[who];","{from, to, crap} = range;","bogus = {};","for line in [from..to]","if (match(text[line], \"^ *\\\"%([^\\\\\\\"]%|\\\\.%)*\\\";$\"))","\"check from $code_utils:verb_documentation\";","if (!bogus)","text[line] = $no_one:eval(text[line])[2];","endif","else","bogus = setadd(bogus, line);","endif","endfor","if (bogus)","player:tell((length(bogus) == 1) ? \"Line\" | \"Lines\", \" \", $string_utils:english_list(bogus), \" \", (length(bogus) == 1) ? \"is\" | \"are\", \" not comments.\");","player:tell(\"No changes.\");","return;","endif","this.texts[who] = text;","player:tell((to == from) ? \"Line\" | \"Lines\", \" changed.\");","this.changes[who] = 1;","this.times[who] = time();","endif"]},{"name":"say","owner":36,"perms":93,"preposition":-2,"code":["if ((caller != player) && (caller_perms() != player))","return E_PERM;","endif","if (!(who = this:loaded(player)))","player:tell(this:nothing_loaded_msg());","else","this:insert_line(who, argstr);","endif"]},{"name":"emote","owner":36,"perms":93,"preposition":-2,"code":["if ((caller != player) && (caller_perms() != player))","return E_PERM;","endif","if (!(who = this:loaded(player)))","player:tell(this:nothing_loaded_msg());","else","this:append_line(who, argstr);","endif"]},{"name":"enter","owner":36,"perms":25,"preposition":-1,"code":["if (!this:loaded(player))","player:tell(this:nothing_loaded_msg());","else","lines = $command_utils:read_lines();","if (typeof(lines) == ERR)","player:notify(tostr(lines));","return;","endif","this:insert_line(this:loaded(player), lines, 0);","endif"]},{"name":"lis*t view","owner":36,"perms":89,"preposition":-2,"code":["nonum = 0;","if (verb == \"view\")","if (!args)","l = {};","for i in [1..length(this.active)]","if (this.readable[i])","l = {@l, this.active[i]};","endif","endfor","if (l)","player:tell(\"Players having readable texts in this editor:  \", $string_utils:names_of(l));","else","player:tell(\"No one has published anything in this editor.\");","endif","return;","elseif ($command_utils:player_match_result(plyr = $string_utils:match_player(args[1]), args[1])[1])","\"...no such player\";","return;","elseif ((!(who = this:loaded(plyr))) || (!this:readable(who)))","player:tell(plyr.name, \"(\", plyr, \") has not published anything in this editor.\");","return;","endif","args = listdelete(args, 1);","elseif (!(who = this:loaded(player)))","player:tell(this:nothing_loaded_msg());","return;","endif","len = length(this.texts[who]);","ins = this.inserting[who];","window = 8;","if (len < (2 * window))","default = {\"1-$\"};","elseif (ins <= window)","default = {tostr(\"1-\", 2 * window)};","else","default = {tostr(window, \"_-\", window, \"^\"), tostr(2 * window, \"$-$\")};","endif","if (typeof(range = this:parse_range(who, default, @args)) != LIST)","player:tell(tostr(range));","elseif (range[3] && (!(nonum = \"nonum\" == $string_utils:trim(range[3]))))","player:tell(\"Don't understand this:  \", range[3]);","elseif (nonum)","player:tell_lines(this.texts[who][range[1]..range[2]]);","else","for line in [range[1]..range[2]]","this:list_line(who, line);","if ($command_utils:running_out_of_time())","suspend(0);","if (!(who = this:loaded(player)))","player:tell(\"ack!  something bad happened during a suspend...\");","return;","endif","endif","endfor","if ((ins > len) && (len == range[2]))","player:tell(\"^^^^\");","endif","endif"]},{"name":"ins*ert n*ext p*revious .","owner":36,"perms":25,"preposition":-1,"code":["if (i = index(argstr, \"\\\"\"))","text = argstr[i + 1..$];","argstr = argstr[1..i - 1];","else","text = 0;","endif","spec = $string_utils:trim(argstr);","if (index(\"next\", verb) == 1)","verb = \"next\";","spec = \"+\" + (spec || \"1\");","elseif (index(\"prev\", verb) == 1)","verb = \"prev\";","spec = \"-\" + (spec || \"1\");","else","spec = spec || \".\";","endif","if (!(who = this:loaded(player)))","player:tell(this:nothing_loaded_msg());","elseif (ERR == typeof(number = this:parse_insert(who, spec)))","if (verb in {\"next\", \"prev\"})","player:tell(\"Argument must be a number.\");","else","player:tell(\"You must specify an integer or `$' for the last line.\");","endif","elseif ((number > (max = length(this.texts[who]) + 1)) || (number < 1))","player:tell(\"That would take you out of range (to line \", number, \"?).\");","else","this.inserting[who] = number;","if (typeof(text) == STR)","this:insert_line(who, text);","else","if (verb != \"next\")","(number > 1) ? this:list_line(who, number - 1) | player:tell(\"____\");","endif","if (verb != \"prev\")","(number < max) ? this:list_line(who, number) | player:tell(\"^^^^\");","endif","endif","endif"]},{"name":"del*ete","owner":36,"perms":89,"preposition":-2,"code":["if (!(who = this:loaded(player)))","player:tell(this:nothing_loaded_msg());","elseif (typeof(range = this:parse_range(who, {\"_\", \"1\"}, @args)) != LIST)","player:tell(range);","elseif (range[3])","player:tell(\"Junk at end of cmd:  \", range[3]);","else","player:tell_lines((text = this.texts[who])[from = range[1]..to = range[2]]);","player:tell(\"---Line\", (to > from) ? \"s\" | \"\", \" deleted.  Insertion point is before line \", from, \".\");","this.texts[who] = {@text[1..from - 1], @text[to + 1..$]};","if (!this.changes[who])","this.changes[who] = 1;","this.times[who] = time();","endif","this.inserting[who] = from;","endif"]},{"name":"f*ind","owner":36,"perms":93,"preposition":-2,"code":["if (callers() && (caller != this))","return E_PERM;","endif","if (!(who = this:loaded(player)))","player:tell(this:nothing_loaded_msg());","elseif (typeof(subst = this:parse_subst(argstr && (argstr[1] + argstr), \"c\", \"Empty search string?\")) != LIST)","player:tell(tostr(subst));","elseif (typeof(start = subst[4] ? this:parse_insert(who, subst[4]) | this.inserting[who]) == ERR)","player:tell(\"Starting from where?\", subst[4] ? (\"  (can't parse \" + subst[4]) + \")\" | \"\");","else","search = subst[2];","case = !index(subst[3], \"c\", 1);","text = this.texts[who];","tlen = length(text);","while ((start <= tlen) && (!index(text[start], search, case)))","start = start + 1;","endwhile","if (start > tlen)","player:tell(\"`\", search, \"' not found.\");","else","this.inserting[who] = start + 1;","this:list_line(who, start);","endif","endif"]},{"name":"m*ove c*opy","owner":36,"perms":89,"preposition":-2,"code":["verb = (is_move = verb[1] == \"m\") ? \"move\" | \"copy\";","if (!(who = this:loaded(player)))","player:tell(this:nothing_loaded_msg());","return;","endif","wargs = args;","t = to_pos = 0;","while (t = \"to\" in (wargs = wargs[t + 1..$]))","to_pos = to_pos + t;","endwhile","range_args = args[1..to_pos - 1];","if ((!to_pos) || (ERR == typeof(dest = this:parse_insert(who, $string_utils:from_list(wargs, \" \")))))","player:tell(verb, \" to where? \");","elseif ((dest < 1) || (dest > ((last = length(this.texts[who])) + 1)))","player:tell(\"Destination (\", dest, \") out of range.\");","elseif ((\"from\" in range_args) || (\"to\" in range_args))","player:tell(\"Don't use that kind of range specification with this command.\");","elseif (typeof(range = this:parse_range(who, {\"_\", \"^\"}, @args[1..to_pos - 1])) != LIST)","player:tell(range);","elseif (range[3])","player:tell(\"Junk before `to':  \", range[3]);","elseif ((is_move && (dest >= range[1])) && (dest <= (range[2] + 1)))","player:tell(\"Destination lies inside range of lines to be moved.\");","else","from = range[1];","to = range[2];","ins = this.inserting[who];","text = this.texts[who];","if (!is_move)","this.texts[who] = {@text[1..dest - 1], @text[from..to], @text[dest..last]};","if (ins >= dest)","this.inserting[who] = ((ins + to) - from) + 1;","endif","else","\"oh shit... it's a move\";","if (dest < from)","newtext = {@text[1..dest - 1], @text[from..to], @text[dest..from - 1], @text[to + 1..last]};","if ((ins >= dest) && (ins <= to))","ins = (ins > from) ? (ins - from) + dest | (((ins + to) - from) + 1);","endif","else","newtext = {@text[1..from - 1], @text[to + 1..dest - 1], @text[from..to], @text[dest..last]};","if ((ins > from) && (ins < dest))","ins = (ins <= to) ? ((ins + dest) - to) - 1 | (((ins - to) + from) - 1);","endif","endif","this.texts[who] = newtext;","this.inserting[who] = ins;","endif","if (!this.changes[who])","this.changes[who] = 1;","this.times[who] = time();","endif","player:tell(\"Lines \", is_move ? \"moved.\" | \"copied.\");","endif"]},{"name":"join*literal","owner":36,"perms":89,"preposition":-2,"code":["if (!(who = this:loaded(player)))","player:tell(this:nothing_loaded_msg());","elseif (typeof(range = this:parse_range(who, {\"_-^\", \"_\", \"^\"}, @args)) != LIST)","player:tell(range);","elseif (range[3])","player:tell(\"Junk at end of cmd:  \", range[3]);","elseif (!(result = this:join_lines(who, @range[1..2], length(verb) <= 4)))","player:tell((result == 0) ? \"Need at least two lines to join.\" | result);","else","this:list_line(who, range[1]);","endif"]},{"name":"fill","owner":36,"perms":89,"preposition":-2,"code":["fill_column = 70;","if (!(who = this:loaded(player)))","player:tell(this:nothing_loaded_msg());","elseif (typeof(range = this:parse_range(who, {\"_\", \"1\"}, @args)) != LIST)","player:tell(range);","elseif (range[3] && ((range[3][1] != \"@\") || ((fill_column = toint(range[3][2..$])) < 10)))","player:tell(\"Usage:  fill [<range>] [@ column]   (where column >= 10).\");","else","join = this:join_lines(who, @range[1..2], 1);","newlines = this:fill_string((text = this.texts[who])[from = range[1]], fill_column);","if (fill = ((nlen = length(newlines)) > 1) || (newlines[1] != text[from]))","this.texts[who] = {@text[1..from - 1], @newlines, @text[from + 1..$]};","if (((insert = this.inserting[who]) > from) && (nlen > 1))","this.inserting[who] = (insert + nlen) - 1;","endif","endif","if (fill || join)","for line in [from..(from + nlen) - 1]","this:list_line(who, line);","endfor","else","player:tell(\"No changes.\");","endif","endif"]},{"name":"pub*lish perish unpub*lish depub*lish","owner":36,"perms":9,"preposition":-1,"code":["if (!(who = this:loaded(player)))","player:tell(this:nothing_loaded_msg());","return;","endif","if (typeof(e = this:set_readable(who, index(\"publish\", verb) == 1)) == ERR)","player:tell(e);","elseif (e)","player:tell(\"Your text is now globally readable.\");","else","player:tell(\"Your text is read protected.\");","endif"]},{"name":"w*hat","owner":36,"perms":13,"preposition":-1,"code":["if (!(this:ok(who = player in this.active) && (typeof(this.texts[who]) == LIST)))","player:tell(this:nothing_loaded_msg());","else","player:tell(\"You are editing \", this:working_on(who), \".\");","player:tell(\"Your insertion point is \", (this.inserting[who] > length(this.texts[who])) ? \"after the last line: next line will be #\" | \"before line \", this.inserting[who], \".\");","player:tell(this.changes[who] ? this:change_msg() | this:no_change_msg());","if (this.readable[who])","player:tell(\"Your text is globally readable.\");","endif","endif"]},{"name":"abort","owner":36,"perms":9,"preposition":-1,"code":["if (!this.changes[who = player in this.active])","player:tell(\"No changes to throw away.  Editor cleared.\");","else","player:tell(\"Throwing away session for \", this:working_on(who), \".\");","endif","this:reset_session(who);","if (this.exit_on_abort)","this:done();","endif"]},{"name":"done q*uit pause","owner":36,"perms":13,"preposition":-1,"code":["if (!(caller in {this, player}))","return E_PERM;","elseif (!(who = player in this.active))","player:tell(\"You are not actually in \", this.name, \".\");","return;","elseif (!valid(origin = this.original[who]))","player:tell(\"I don't know where you came here from.\");","else","player:moveto(origin);","if (player.location == this)","player:tell(\"Hmmm... the place you came from doesn't want you back.\");","else","if (msg = this:return_msg())","player.location:announce($string_utils:pronoun_sub(msg));","endif","return;","endif","endif","player:tell(\"You'll have to use 'home' or a teleporter.\");"]},{"name":"huh2","owner":2,"perms":173,"preposition":-1,"code":["\"This catches subst and find commands that don't fit into the usual model, e.g., s/.../.../ without the space after the s, and find commands without the verb `find'.  Still behaves in annoying ways (e.g., loses if the search string contains multiple whitespace), but better than before.\";","set_task_perms(caller_perms());","if ((c = callers()) && ((c[1][1] != this) || (length(c) > 1)))","return pass(@args);","endif","verb = args[1];","v = 1;","vmax = min(length(verb), 5);","while ((v <= vmax) && (verb[v] == \"subst\"[v]))","v = v + 1;","endwhile","argstr = $code_utils:argstr(verb, args[2]);","if (((v > 1) && (v <= length(verb))) && (((vl = verb[v]) < \"A\") || (vl > \"Z\")))","argstr = (verb[v..$] + (argstr && \" \")) + argstr;","return this:subst();","elseif (\"/\" == verb[1])","argstr = (verb + (argstr && \" \")) + argstr;","return this:find();","else","pass(@args);","endif"]},{"name":"insertion","owner":36,"perms":173,"preposition":-1,"code":["return this:ok(who = args[1]) && this.inserting[who];"]},{"name":"set_insertion","owner":36,"perms":173,"preposition":-1,"code":["return this:ok(who = args[1]) && ((((ins = toint(args[2])) < 1) ? E_INVARG | ((ins <= (max = length(this.texts[who]) + 1)) || (ins = max))) && (this.inserting[who] = ins));"]},{"name":"changed retain_session_on_exit","owner":36,"perms":173,"preposition":-1,"code":["return this:ok(who = args[1]) && this.changes[who];"]},{"name":"set_changed","owner":36,"perms":173,"preposition":-1,"code":["return this:ok(who = args[1]) && (((unchanged = !args[2]) || (this.times[who] = time())) && (this.changes[who] = !unchanged));"]},{"name":"origin","owner":36,"perms":173,"preposition":-1,"code":["return this:ok(who = args[1]) && this.original[who];"]},{"name":"set_origin","owner":36,"perms":173,"preposition":-1,"code":["return this:ok(who = args[1]) && (((valid(origin = args[2]) && (origin != this)) || ((origin == $nothing) || E_INVARG)) && (this.original[who] = origin));"]},{"name":"readable","owner":36,"perms":173,"preposition":-1,"code":["return (((who = args[1]) < 1) || (who > length(this.active))) ? E_RANGE | this.readable[who];"]},{"name":"set_readable","owner":36,"perms":173,"preposition":-1,"code":["return this:ok(who = args[1]) && (this.readable[who] = !(!args[2]));"]},{"name":"text","owner":36,"perms":173,"preposition":-1,"code":["{?who = player in this.active} = args;","return (this:readable(who) || this:ok(who)) && this.texts[who];"]},{"name":"load","owner":36,"perms":173,"preposition":-1,"code":["texts = args[2];","if (!(fuckup = this:ok(who = args[1])))","return fuckup;","elseif (typeof(texts) == STR)","texts = {texts};","elseif ((typeof(texts) != LIST) || (length(texts) && (typeof(texts[1]) != STR)))","return E_TYPE;","endif","this.texts[who] = texts;","this.inserting[who] = length(texts) + 1;","this.changes[who] = 0;","this.readable[who] = 0;","this.times[who] = time();"]},{"name":"working_on","owner":36,"perms":173,"preposition":-1,"code":["\"Dummy routine.  The child editor should provide something informative\";","return this:ok(who = args[1]) && ((\"something [in \" + this.name) + \"]\");"]},{"name":"ok","owner":36,"perms":173,"preposition":-1,"code":["who = args[1];","if ((who < 1) || (who > length(this.active)))","return E_RANGE;","elseif ((length(c = callers()) < 2) ? player == this.active[who] | ((c[2][1] == this) || ($perm_utils:controls(c[2][3], this.active[who]) || (c[2][3] == $generic_editor.owner))))","return 1;","else","return E_PERM;","endif"]},{"name":"loaded","owner":36,"perms":173,"preposition":-1,"code":["return ((who = args[1] in this.active) && (typeof(this.texts[who]) == LIST)) && who;"]},{"name":"list_line","owner":36,"perms":173,"preposition":-1,"code":["if (this:ok(who = args[1]))","f = 1 + ((line = args[2]) in {(ins = this.inserting[who]) - 1, ins});","player:tell($string_utils:right(line, 3, \" _^\"[f]), \":_^\"[f], \" \", this.texts[who][line]);","endif"]},{"name":"insert_line","owner":36,"perms":173,"preposition":-1,"code":["\":insert_line([who,] line or list of lines [,quiet])\";","\"  inserts the given text at the insertion point.\";","\"  returns E_NONE if the session has no text loaded yet.\";","if (typeof(args[1]) != INT)","args = {player in this.active, @args};","endif","{who, lines, ?quiet = this.active[who]:edit_option(\"quiet_insert\")} = args;","if (!(fuckup = this:ok(who)))","return fuckup;","elseif (typeof(text = this.texts[who]) != LIST)","return E_NONE;","else","if (typeof(lines) != LIST)","lines = {lines};","endif","p = this.active[who];","insert = this.inserting[who];","this.texts[who] = {@text[1..insert - 1], @lines, @text[insert..$]};","this.inserting[who] = insert + length(lines);","if (lines)","if (!this.changes[who])","this.changes[who] = 1;","this.times[who] = time();","endif","if (!quiet)","if (length(lines) != 1)","p:tell(\"Lines \", insert, \"-\", (insert + length(lines)) - 1, \" added.\");","else","p:tell(\"Line \", insert, \" added.\");","endif","endif","else","p:tell(\"No lines added.\");","endif","endif"]},{"name":"append_line","owner":36,"perms":173,"preposition":-1,"code":["\":append_line([who,] string)\";","\"  appends the given string to the line before the insertion point.\";","\"  returns E_NONE if the session has no text loaded yet.\";","if (typeof(args[1]) != INT)","args = {player in this.active, @args};","endif","{who, string} = args;","if (!(fuckup = this:ok(who)))","return fuckup;","elseif ((append = this.inserting[who] - 1) < 1)","return this:insert_line(who, {string});","elseif (typeof(text = this.texts[who]) != LIST)","return E_NONE;","else","this.texts[who][append] = text[append] + string;","if (!this.changes[who])","this.changes[who] = 1;","this.times[who] = time();","endif","p = this.active[who];","if (!p:edit_option(\"quiet_insert\"))","p:tell(\"Appended to line \", append, \".\");","endif","endif"]},{"name":"join_lines","owner":36,"perms":173,"preposition":-1,"code":["{who, from, to, english} = args;","if (!(fuckup = this:ok(who)))","return fuckup;","elseif (from >= to)","return 0;","else","nline = \"\";","for line in ((text = this.texts[who])[from..to])","if (!english)","nline = nline + line;","else","len = length(line) + 1;","while ((len = len - 1) && (line[len] == \" \"))","endwhile","if (len > 0)","nline = (nline + line) + (index(\".:\", line[len]) ? \"  \" | \" \");","endif","endif","endfor","this.texts[who] = {@text[1..from - 1], nline, @text[to + 1..$]};","if ((insert = this.inserting[who]) > from)","this.inserting[who] = (insert <= to) ? from + 1 | ((insert - to) + from);","endif","if (!this.changes[who])","this.changes[who] = 1;","this.times[who] = time();","endif","return to - from;","endif"]},{"name":"parse_number","owner":36,"perms":173,"preposition":-1,"code":["\"parse_number(who,string,before)   interprets string as a line number.  In the event that string is `.', `before' tells us which line to use.  Return 0 if string is bogus.\";","{who, string, before} = args;","if (!(fuckup = this:ok(who)))","return fuckup;","endif","last = length(this.texts[who]);","ins = this.inserting[who] - 1;","after = !before;","if (!string)","return 0;","elseif (\".\" == string)","return ins + after;","elseif (!(i = index(\"_^$\", string[slen = length(string)])))","return toint(string);","else","start = {ins + 1, ins, last + 1}[i];","n = 1;","if ((slen > 1) && (!(n = toint(string[1..slen - 1]))))","return 0;","elseif (i % 2)","return start - n;","else","return start + n;","endif","endif"]},{"name":"parse_range","owner":36,"perms":173,"preposition":-1,"code":["\"parse_range(who,default,@args) => {from to rest}\";","numargs = length(args);","if (!(fuckup = this:ok(who = args[1])))","return fuckup;","elseif (!(last = length(this.texts[who])))","return this:no_text_msg();","endif","default = args[2];","r = 0;","while (default && (LIST != typeof(r = this:parse_range(who, {}, default[1]))))","default = listdelete(default, 1);","endwhile","if (typeof(r) == LIST)","from = r[1];","to = r[2];","else","from = to = 0;","endif","saw_from_to = 0;","not_done = 1;","a = 2;","while (((a = a + 1) <= numargs) && not_done)","if (args[a] == \"from\")","if ((a == numargs) || (!(from = this:parse_number(who, args[a = a + 1], 0))))","return \"from ?\";","endif","saw_from_to = 1;","elseif (args[a] == \"to\")","if ((a == numargs) || (!(to = this:parse_number(who, args[a = a + 1], 1))))","return \"to ?\";","endif","saw_from_to = 1;","elseif (saw_from_to)","a = a - 1;","not_done = 0;","elseif (i = index(args[a], \"-\"))","from = this:parse_number(who, args[a][1..i - 1], 0);","to = this:parse_number(who, args[a][i + 1..$], 1);","not_done = 0;","elseif (f = this:parse_number(who, args[a], 0))","from = f;","if ((a == numargs) || (!(to = this:parse_number(who, args[a + 1], 1))))","to = from;","else","a = a + 1;","endif","not_done = 0;","else","a = a - 1;","not_done = 0;","endif","endwhile","if (from < 1)","return tostr(\"from \", from, \"?  (out of range)\");","elseif (to > last)","return tostr(\"to \", to, \"?  (out of range)\");","elseif (from > to)","return tostr(\"from \", from, \" to \", to, \"?  (backwards range)\");","else","return {from, to, $string_utils:from_list(args[a..numargs], \" \")};","endif"]},{"name":"parse_insert","owner":36,"perms":173,"preposition":-1,"code":["\"parse_ins(who,string)  interprets string as an insertion point, i.e., a position between lines and returns the number of the following line or 0 if bogus.\";","if (!(fuckup = this:ok(who = args[1])))","return fuckup;","endif","{who, string} = args;","last = length(this.texts[who]) + 1;","ins = this.inserting[who];","if (i = index(\"-+\", string[1]))","rest = string[2..$];","return ((n = toint(rest)) || (rest == \"0\")) ? {ins - n, ins + n}[i] | E_INVARG;","else","if (!(j = index(string, \"^\") || index(string, \"_\")))","offset = 0;","else","offset = (j == 1) || toint(string[1..j - 1]);","if (!offset)","return E_INVARG;","elseif (string[j] == \"^\")","offset = -offset;","endif","endif","rest = string[j + 1..$];","if (i = rest in {\".\", \"$\"})","return offset + {ins, last}[i];","elseif (!(n = toint(rest)))","return E_INVARG;","else","return (offset + (j && (string[j] == \"^\"))) + n;","endif","endif"]},{"name":"parse_subst","owner":36,"perms":173,"preposition":-1,"code":["{cmd, ?recognized_flags = \"gcr\", ?null_subst_msg = \"Null substitution?\"} = args;","if (!cmd)","return \"/xxx/yyy[/[g][c]] [<range>] expected..\";","endif","bchar = cmd[1];","cmd = cmd[2..$];","fromstr = cmd[1..(b2 = index(cmd + bchar, bchar, 1)) - 1];","cmd = cmd[b2 + 1..$];","tostr = cmd[1..(b2 = index(cmd + bchar, bchar, 1)) - 1];","cmd = cmd[b2 + 1..$];","cmdlen = length(cmd);","b2 = 0;","while (((b2 = b2 + 1) <= cmdlen) && index(recognized_flags, cmd[b2]))","endwhile","return ((fromstr == \"\") && (tostr == \"\")) ? null_subst_msg | {fromstr, tostr, cmd[1..b2 - 1], cmd[b2..$]};"]},{"name":"invoke","owner":36,"perms":173,"preposition":-1,"code":["\":invoke(...)\";","\"to find out what arguments this verb expects,\";","\"see this editor's parse_invoke verb.\";","new = args[1];","if ((!(caller in {this, player})) && (!$perm_utils:controls(caller_perms(), player)))","\"...non-editor/non-player verb trying to send someone to the editor...\";","return E_PERM;","endif","if ((who = this:loaded(player)) && this:changed(who))","if (!new)","if (this:suck_in(player))","player:tell(\"You are working on \", this:working_on(who));","endif","return;","elseif (player.location == this)","player:tell(\"You are still working on \", this:working_on(who));","if (msg = this:previous_session_msg())","player:tell(msg);","endif","return;","endif","\"... we're not in the editor and we're about to start something new,\";","\"... but there's still this pending session...\";","player:tell(\"You were working on \", this:working_on(who));","if (!$command_utils:yes_or_no(\"Do you wish to delete that session?\"))","if (this:suck_in(player))","player:tell(\"Continuing with \", this:working_on(player in this.active));","if (msg = this:previous_session_msg())","player:tell(msg);","endif","endif","return;","endif","\"... note session number may have changed => don't trust `who'\";","this:kill_session(player in this.active);","endif","spec = this:parse_invoke(@args);","if (typeof(spec) == LIST)","if ((player:edit_option(\"local\") && $object_utils:has_verb(this, \"local_editing_info\")) && (info = this:local_editing_info(@spec)))","this:invoke_local_editor(@info);","elseif (this:suck_in(player))","this:init_session(player in this.active, @spec);","endif","endif"]},{"name":"suck_in","owner":36,"perms":173,"preposition":-1,"code":["\"The correct way to move someone into the editor.\";","if (((loc = (who_obj = args[1]).location) != this) && (caller == this))","this.invoke_task = task_id();","who_obj:moveto(this);","if (who_obj.location == this)","try","\"...forked, just in case loc:announce is broken...\";","\"changed to a try-endtry. Lets reduce tasks..Ho_Yan 12/20/96\";","if (valid(loc) && (msg = this:depart_msg()))","loc:announce($string_utils:pronoun_sub(msg));","endif","except (ANY)","\"Just drop it and move on\";","endtry","else","who_obj:tell(\"For some reason, I can't move you.   (?)\");","this:exitfunc(who_obj);","endif","this.invoke_task = 0;","endif","return who_obj.location == this;"]},{"name":"new_session","owner":2,"perms":173,"preposition":-1,"code":["\"WIZARDLY\";","{who_obj, from} = args;","if ($object_utils:isa(from, $generic_editor))","\"... never put an editor in .original, ...\";","if (w = who_obj in from.active)","from = from.original[w];","else","from = #-1;","endif","endif","if (caller != this)","return E_PERM;","elseif (who = who_obj in this.active)","\"... edit in progress here...\";","if (valid(from))","this.original[who] = from;","endif","return -1;","else","for p in ({{\"active\", who_obj}, {\"original\", valid(from) ? from | $nothing}, {\"times\", time()}, @this.stateprops})","this.(p[1]) = {@this.(p[1]), p[2]};","endfor","return length(this.active);","endif"]},{"name":"kill_session","owner":2,"perms":173,"preposition":-1,"code":["\"WIZARDLY\";","if (!(fuckup = this:ok(who = args[1])))","return fuckup;","else","for p in ({@this.stateprops, {\"original\"}, {\"active\"}, {\"times\"}})","this.(p[1]) = listdelete(this.(p[1]), who);","endfor","return who;","endif"]},{"name":"reset_session","owner":2,"perms":173,"preposition":-1,"code":["\"WIZARDLY\";","if (!(fuckup = this:ok(who = args[1])))","return fuckup;","else","for p in (this.stateprops)","this.(p[1])[who] = p[2];","endfor","this.times[who] = time();","return who;","endif"]},{"name":"kill_all_sessions","owner":2,"perms":173,"preposition":-1,"code":["\"WIZARDLY\";","if ((caller != this) && (!caller_perms().wizard))","return E_PERM;","else","for victim in (this.contents)","victim:tell(\"Sorry, \", this.name, \" is going down.  Your editing session is hosed.\");","victim:moveto(((who = victim in this.active) && valid(origin = this.original[who])) ? origin | (valid(victim.home) ? victim.home | $player_start));","endfor","for p in ({@this.stateprops, {\"original\"}, {\"active\"}, {\"times\"}})","this.(p[1]) = {};","endfor","return 1;","endif"]},{"name":"acceptable","owner":36,"perms":173,"preposition":-1,"code":["return is_player(who_obj = args[1]) && (who_obj.wizard || pass(@args));"]},{"name":"enterfunc","owner":36,"perms":173,"preposition":-1,"code":["who_obj = args[1];","if (who_obj.wizard && (!(who_obj in this.active)))","this:accept(who_obj);","endif","pass(@args);","if (this.invoke_task == task_id())","\"Means we're about to load something, so be quiet.\";","this.invoke_task = 0;","elseif (who = this:loaded(who_obj))","who_obj:tell(\"You are working on \", this:working_on(who), \".\");","elseif (msg = this:nothing_loaded_msg())","who_obj:tell(msg);","endif"]},{"name":"exitfunc","owner":36,"perms":173,"preposition":-1,"code":["if (!(who = (who_obj = args[1]) in this.active))","elseif (this:retain_session_on_exit(who))","if (msg = this:no_littering_msg())","who_obj:tell_lines(msg);","endif","else","this:kill_session(who);","endif","pass(@args);"]},{"name":"@flush","owner":36,"perms":109,"preposition":-2,"code":["\"@flush <editor>\";","\"@flush <editor> at <month> <day>\";","\"@flush <editor> at <weekday>\";","\"The first form removes all sessions from the editor; the other two forms remove everything older than the given date.\";","if ((caller_perms() != #-1) && (caller_perms() != player))","raise(E_PERM);","elseif (!$perm_utils:controls(player, this))","player:tell(\"Only the owner of the editor can do a \", verb, \".\");","return;","endif","if (!prepstr)","player:tell(\"Trashing all sessions.\");","this:kill_all_sessions();","elseif (prepstr != \"at\")","player:tell(\"Usage:  \", verb, \" \", dobjstr, \" [at [mon day|weekday]]\");","else","p = prepstr in args;","if (t = $time_utils:from_day(iobjstr, -1))","elseif (t = $time_utils:from_month(args[p + 1], -1))","if (length(args) > (p + 1))","if (!(n = toint(args[p + 2])))","player:tell(args[p + 1], \" WHAT?\");","return;","endif","t = t + ((n - 1) * 86400);","endif","else","player:tell(\"couldn't parse date\");","return;","endif","this:do_flush(t, \"noisy\");","endif","player:tell(\"Done.\");"]},{"name":"@stateprop","owner":36,"perms":153,"preposition":11,"code":["if (!$perm_utils:controls(player, this))","player:tell(E_PERM);","return;","endif","if (i = index(dobjstr, \"=\"))","default = dobjstr[i + 1..$];","prop = dobjstr[1..i - 1];","if (argstr[1 + index(argstr, \"=\")] == \"\\\"\")","elseif (default[1] == \"#\")","default = toobj(default);","elseif (index(\"0123456789\", default[1]))","default = toint(default);","elseif (default == \"{}\")","default = {};","endif","else","default = 0;","prop = dobjstr;","endif","if (typeof(result = this:set_stateprops(prop, default)) == ERR)","player:tell((result == E_RANGE) ? tostr(\".\", prop, \" needs to hold a list of the same length as .active (\", length(this.active), \").\") | ((result != E_NACC) ? result | (prop + \" is already a property on an ancestral editor.\")));","else","player:tell(\"Property added.\");","endif"]},{"name":"@rmstateprop","owner":36,"perms":153,"preposition":5,"code":["if (!$perm_utils:controls(player, this))","player:tell(E_PERM);","elseif (typeof(result = this:set_stateprops(dobjstr)) == ERR)","player:tell((result != E_NACC) ? result | (dobjstr + \" is already a property on an ancestral editor.\"));","else","player:tell(\"Property removed.\");","endif"]},{"name":"initialize","owner":36,"perms":173,"preposition":-1,"code":["if ($perm_utils:controls(caller_perms(), this))","pass(@args);","this:kill_all_sessions();","endif"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","pass();","this:kill_all_sessions();","if (this == $generic_editor)","this.help = $editor_help;","endif","if ($object_utils:defines_verb(this, \"is_not_banned\"))","delete_verb(this, \"is_not_banned\");","endif","endif"]},{"name":"set_stateprops","owner":36,"perms":173,"preposition":-1,"code":["remove = length(args) < 2;","if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))","return E_PERM;","elseif (!(length(args) in {1, 2}))","return E_ARGS;","elseif (typeof(prop = args[1]) != STR)","return E_TYPE;","elseif (i = $list_utils:iassoc(prop, this.stateprops))","if (!remove)","this.stateprops[i] = {prop, args[2]};","elseif ($object_utils:has_property(parent(this), prop))","return E_NACC;","else","this.stateprops = listdelete(this.stateprops, i);","endif","elseif (remove)","elseif (prop in `properties(this) ! ANY => {}')","if (this:_stateprop_length(prop) != length(this.active))","return E_RANGE;","endif","this.stateprops = {{prop, args[2]}, @this.stateprops};","else","return $object_utils:has_property(this, prop) ? E_NACC | E_PROPNF;","endif","return 0;"]},{"name":"description","owner":36,"perms":173,"preposition":-1,"code":["is_look_self = 1;","for c in (callers())","if (is_look_self && (c[2] in {\"enterfunc\", \"confunc\"}))","return {\"\", \"Do a 'look' to get the list of commands, or 'help' for assistance.\", \"\", @this.description};","elseif ((c[2] != \"look_self\") && (c[2] != \"pass\"))","is_look_self = 0;","endif","endfor","d = {\"Commands:\", \"\"};","col = {{}, {}};","for c in [1..2]","for cmd in (this.commands2[c])","cmd = this:commands_info(cmd);","col[c] = {cmdargs = $string_utils:left(cmd[1] + \" \", 12) + cmd[2], @col[c]};","endfor","endfor","i1 = length(col[1]);","i2 = length(col[2]);","right = 0;","while (i1 || i2)","if (!((i1 && (length(col[1][i1]) > 35)) || (i2 && (length(col[2][i2]) > 35))))","d = {@d, $string_utils:left(i1 ? col[1][i1] | \"\", 40) + (i2 ? col[2][i2] | \"\")};","i1 && (i1 = i1 - 1);","i2 && (i2 = i2 - 1);","right = 0;","elseif (right && i2)","d = {@d, (length(col[2][i2]) > 35) ? $string_utils:right(col[2][i2], 75) | ($string_utils:space(40) + col[2][i2])};","i2 = i2 - 1;","right = 0;","elseif (i1)","d = {@d, col[1][i1]};","i1 = i1 - 1;","right = 1;","else","right = 1;","endif","endwhile","return {@d, \"\", \"----  Do `help <cmdname>' for help with a given command.  ----\", \"\", \"  <ins> ::= $ (the end) | [^]n (above line n) | _n (below line n) | . (current)\", \"<range> ::= <lin> | <lin>-<lin> | from <lin> | to <lin> | from <lin> to <lin>\", \"  <lin> ::= n | [n]$ (n from the end) | [n]_ (n before .) | [n]^ (n after .)\", \"`help insert' and `help ranges' describe these in detail.\", @this.description};"]},{"name":"commands_info","owner":36,"perms":173,"preposition":-1,"code":["cmd = args[1];","if (pc = $list_utils:assoc(cmd, this.commands))","return pc;","elseif (this == $generic_editor)","return {cmd, \"<<<<<======= Need to add this to .commands\"};","else","return parent(this):commands_info(cmd);","endif"]},{"name":"match_object","owner":36,"perms":173,"preposition":-1,"code":["{objstr, ?who = player} = args;","origin = this;","while ((where = player in origin.active) && ($recycler:valid(origin = origin.original[where]) && (origin != this)))","if (!$object_utils:isa(origin, $generic_editor))","return origin:match_object(objstr, who);","endif","endwhile","return who:my_match_object(objstr, #-1);"]},{"name":"who_location_msg","owner":36,"perms":173,"preposition":-1,"code":["who = args[1];","where = {#-1, @this.original}[1 + (who in this.active)];","wherestr = `where:who_location_msg(who) ! ANY => \"An Editor\"';","if (typeof(wherestr) != STR)","wherestr = \"broken who_location_msg\";","endif","return strsub(this.who_location_msg, \"%L\", wherestr);","return $string_utils:pronoun_sub(this.who_location_msg, who, this, where);"]},{"name":"nothing_loaded_msg no_text_msg change_msg no_change_msg no_littering_msg depart_msg return_msg previous_session_msg","owner":36,"perms":173,"preposition":-1,"code":["return this.(verb);"]},{"name":"announce announce_all announce_all_but tell_contents","owner":36,"perms":173,"preposition":-1,"code":["return;"]},{"name":"fill_string","owner":36,"perms":173,"preposition":-1,"code":["\"fill(string [, width [, prefix]])\";","\"tries to cut <string> into substrings of length < <width> along word boundaries.  Prefix, if supplied, will be prefixed to the 2nd..last substrings.\";","{string, ?width = 1 + player:linelen(), ?prefix = \"\"} = args;","width = width + 1;","if (width < (3 + length(prefix)))","return E_INVARG;","endif","string = (\"$\" + string) + \" $\";","len = length(string);","if (len <= width)","last = len - 1;","next = len;","else","last = rindex(string[1..width], \" \");","if (last < ((width + 1) / 2))","last = width + index(string[width + 1..len], \" \");","endif","next = last;","while (string[next = next + 1] == \" \")","endwhile","endif","while (string[last = last - 1] == \" \")","endwhile","ret = {string[2..last]};","width = width - length(prefix);","minlast = (width + 1) / 2;","while (next < len)","string = \"$\" + string[next..len];","len = (len - next) + 2;","if (len <= width)","last = len - 1;","next = len;","else","last = rindex(string[1..width], \" \");","if (last < minlast)","last = width + index(string[width + 1..len], \" \");","endif","next = last;","while (string[next = next + 1] == \" \")","endwhile","endif","while (string[last = last - 1] == \" \")","endwhile","if (last > 1)","ret = {@ret, prefix + string[2..last]};","endif","endwhile","return ret;"]},{"name":"here_huh","owner":36,"perms":173,"preposition":-1,"code":["\"This catches subst and find commands that don't fit into the usual model, e.g., s/.../.../ without the space after the s, and find commands without the verb `find'.  Still behaves in annoying ways (e.g., loses if the search string contains multiple whitespace), but better than before.\";","if ((caller != this) && (caller_perms() != player))","return E_PERM;","endif","{verb, args} = args;","v = 1;","vmax = min(length(verb), 5);","while ((v <= vmax) && (verb[v] == \"subst\"[v]))","v = v + 1;","endwhile","argstr = $code_utils:argstr(verb, args);","if ((v > 1) && ((v <= length(verb)) && (((vl = verb[v]) < \"A\") || (vl > \"Z\"))))","argstr = (verb[v..$] + (argstr && \" \")) + argstr;","this:subst();","return 1;","elseif (\"/\" == verb[1])","argstr = (verb + (argstr && \" \")) + argstr;","this:find();","return 1;","else","return 0;","endif"]},{"name":"match","owner":2,"perms":173,"preposition":-1,"code":["return $failed_match;"]},{"name":"get_room","owner":36,"perms":173,"preposition":-1,"code":["\":get_room([player])  => correct room to match in on invocation.\";","{?who = player} = args;","if (who.location != this)","return who.location;","else","origin = this;","while ((where = player in origin.active) && (valid(origin = origin.original[where]) && (origin != this)))","if (!$object_utils:isa(origin, $generic_editor))","return origin;","endif","endwhile","return this;","endif"]},{"name":"invoke_local_editor","owner":2,"perms":173,"preposition":-1,"code":["\":invoke_local_editor(name, text, upload)\";","\"Spits out the magic text that invokes the local editor in the player's client.\";","\"NAME is a good human-readable name for the local editor to use for this particular piece of text.\";","\"TEXT is a string or list of strings, the initial body of the text being edited.\";","\"UPLOAD, a string, is a MOO command that the local editor can use to save the text when the user is done editing.  The local editor is going to send that command on a line by itself, followed by the new text lines, followed by a line containing only `.'.  The UPLOAD command should therefore call $command_utils:read_lines() to get the new text as a list of strings.\";","if (caller != this)","return;","endif","{name, text, upload} = args;","if (typeof(text) == STR)","text = {text};","endif","notify(player, tostr(\"#$# edit name: \", name, \" upload: \", upload));","\":dump_lines() takes care of the final `.' ...\";","for line in ($command_utils:dump_lines(text))","notify(player, line);","endfor"]},{"name":"_stateprop_length","owner":2,"perms":173,"preposition":-1,"code":["\"+c properties on children cannot necessarily be read, so we need this silliness...\";","if (caller != this)","return E_PERM;","else","return length(this.(args[1]));","endif"]},{"name":"print","owner":2,"perms":9,"preposition":-1,"code":["txt = this:text(player in this.active);","if (typeof(txt) == LIST)","player:tell_lines(txt);","else","player:tell(\"Text unreadable:  \", txt);","endif","player:tell(\"--------------------------\");"]},{"name":"accept","owner":36,"perms":173,"preposition":-1,"code":["return this:acceptable(who_obj = args[1]) && this:new_session(who_obj, who_obj.location);"]},{"name":"y*ank","owner":2,"perms":89,"preposition":-2,"code":["\"Usage: yank from <note>\";","\"       yank <message-sequence> from <mail-recipient>\";","\"       yank from <object>:<verb>\";","\"       yank from <object>.<property>\";","\"Grabs the specified text and inserts it at the cursor.\";","set_task_perms(player);","if (dobjstr)","\"yank <message-sequence> from <mail-recipient>\";","if (!(p = player:parse_mailread_cmd(verb, args, \"\", \"from\")))","return;","elseif ($seq_utils:size(sequence = p[2]) != 1)","player:notify(tostr(\"You can only \", verb, \" one message at a time\"));","return;","else","m = (folder = p[1]):messages_in_seq(sequence);","msg = m[1];","header = tostr(\"Message \", msg[1]);","if (folder != player)","header = tostr(header, \" on \", $mail_agent:name(folder));","endif","header = tostr(header, \":\");","lines = {header, @player:msg_full_text(@msg[2])};","this:insert_line(this:loaded(player), lines, 0);","endif","elseif (pr = $code_utils:parse_propref(iobjstr))","o = player:my_match_object(pr[1]);","if ($command_utils:object_match_failed(o, pr[1]))","return;","elseif ((lines = `o.(pr[2]) ! ANY') == E_PROPNF)","player:notify(tostr(\"There is no `\", pr[2], \"' property on \", $string_utils:nn(o), \".\"));","return;","elseif (lines == E_PERM)","player:notify(tostr(\"Error: Permission denied reading \", iobjstr));","return;","elseif (typeof(lines) == ERR)","player:notify(tostr(\"Error: \", lines, \" reading \", iobjstr));","return;","elseif (typeof(lines) == STR)","this:insert_line(this:loaded(player), lines, 0);","return;","elseif (typeof(lines) == LIST)","for x in (lines)","if (typeof(x) != STR)","player:notify(tostr(\"Error: \", iobjstr, \" does not contain a \", verb, \"-able value.\"));","return;","endif","endfor","this:insert_line(this:loaded(player), lines, 0);","return;","else","player:notify(tostr(\"Error: \", iobjstr, \" does not contain a \", verb, \"-able value.\"));","return;","endif","elseif (pr = $code_utils:parse_verbref(iobjstr))","o = player:my_match_object(pr[1]);","if ($command_utils:object_match_failed(o, pr[1]))","return;","elseif (lines = `verb_code(o, pr[2], !player:edit_option(\"no_parens\")) ! ANY')","this:insert_line(this:loaded(player), lines, 0);","return;","elseif (lines == E_PERM)","player:notify(tostr(\"Error: Permission denied reading \", iobjstr));","return;","elseif (lines == E_VERBNF)","player:notify(tostr(\"There is no `\", pr[2], \"' verb on \", $string_utils:nn(o), \".\"));","else","player:notify(tostr(\"Error: \", lines, \" reading \", iobjstr));","return;","endif","elseif ($command_utils:object_match_failed(iobj = player:my_match_object(iobjstr), iobjstr))","return;","elseif ((lines = `iobj:text() ! ANY') == E_PERM)","player:notify(tostr(\"Error: Permission denied reading \", iobjstr));","return;","elseif (lines == E_VERBNF)","player:notify($string_utils:nn(iobj), \" doesn't seem to be a note.\");","elseif (typeof(lines) == ERR)","player:notify(tostr(\"Error: \", lines, \" reading \", iobjstr));","return;","else","this:insert_line(this:loaded(player), lines, 0);","endif"]},{"name":"do_flush","owner":36,"perms":173,"preposition":-1,"code":["\"Flushes editor sessions older than args[1].  If args[2] is true, prints status as it runs.  If args[2] is false, runs silently.\";","if (!$perm_utils:controls(caller_perms(), this))","return E_PERM;","else","{t, noisy} = args;","for i in [-length(this.active)..-1]","if (this.times[-i] < t)","if (noisy)","player:tell($string_utils:nn(this.active[-i]), ctime(this.times[-i]));","endif","this:kill_session(-i);","endif","endfor","endif"]},{"name":"s*ubst","owner":36,"perms":93,"preposition":-2,"code":["if (callers() && (caller != this))","return E_PERM;","elseif (!(who = this:loaded(player)))","player:tell(this:nothing_loaded_msg());","elseif (typeof(subst = this:parse_subst(argstr)) != LIST)","player:tell(tostr(subst));","elseif (typeof(range = this:parse_range(who, {\"_\", \"1\"}, @$string_utils:explode(subst[4]))) != LIST)","player:tell(range);","elseif (range[3])","player:tell(\"Junk at end of cmd:  \", range[3]);","else","{fromstr, tostr, specs, dummy} = subst;","global = index(specs, \"g\", 1);","regexp = index(specs, \"r\", 1);","case = !index(specs, \"c\", 1);","munged = {};","text = this.texts[who];","changed = {};","{from, to} = range[1..2];","for line in [from..to]","t = t0 = text[line];","if (!fromstr)","t = tostr + t;","elseif (global)","if (regexp)","while (new = this:subst_regexp(t, fromstr, tostr, case))","t = new;","endwhile","else","t = strsub(t, fromstr, tostr, case);","endif","else","if (regexp)","(new = this:subst_regexp(t, fromstr, tostr, case)) && (t = new);","else","(i = index(t, fromstr, case)) && (t = (t[1..i - 1] + tostr) + t[i + length(fromstr)..length(t)]);","endif","endif","if (strcmp(t0, t))","changed = {@changed, line};","endif","munged = {@munged, t};","endfor","if (!changed)","player:tell(\"No changes in line\", (from == to) ? tostr(\" \", from) | tostr(\"s \", from, \"-\", to), \".\");","else","this.texts[who] = {@text[1..from - 1], @munged, @text[to + 1..$]};","if (!this.changes[who])","this.changes[who] = 1;","this.times[who] = time();","endif","for line in (changed)","this:list_line(who, line);","endfor","endif","endif"]},{"name":"subst_regexp","owner":36,"perms":173,"preposition":-1,"code":["\"Copied from Domain (#8111):subst_regexp by Mooshie (#106469) Mon Jan  5 19:27:26 1998 PST\";","\"Usage: subst_regexp(STR text, STR from string, STR to string, INT case)\";","{text, from, to, case} = args;","if (m = match(text, from, case))","{start, end} = m[1..2];","text[start..end] = substitute(to, m);","return text;","else","return m;","endif"]},{"name":"match","owner":36,"perms":173,"preposition":-1,"code":["\":match(string, object-list)\";","\"Return object in 'object-list' aliased to 'string'.\";","\"Matches on a wide variety of syntax, including:\";","\" \\\"5th axe\\\" -- The fifth object matching \\\"axe\\\" in the object list.\";","\" \\\"where's sai\\\" -- The only object contained in 'where' matching \\\"sai\\\" (possible $ambiguous_match).\";","\" \\\"where's second staff\\\" -- The second object contained in 'where' matching \\\"staff\\\".\";","\" \\\"my third dagger\\\" -- The third object in your inventory matching \\\"dagger\\\".\";","\"Ordinal matches are determined according to the match's position in 'object-list' or, if a possessive (such as \\\"where\\\" above) is given, then the ordinal is the nth match in that object's inventory.\";","\"In the matching room (#3879@LambdaMOO), the 'object-list' consists of first the player's contents, then the room's, and finally all exits leading from the room.\";","{string, olist} = args;","if (!string)","return $nothing;","elseif (string == \"me\")","return player;","elseif (string == \"here\")","return player.location;","elseif (valid(object = $string_utils:literal_object(string)))","return object;","elseif (valid(object = $string_utils:match(string, olist, \"aliases\")))","return object;","elseif (parsed = this:parse_ordinal_reference(string))","return this:match_nth(parsed[2], olist, parsed[1]);","elseif (parsed = this:parse_possessive_reference(string))","{whostr, objstr} = parsed;","if (valid(whose = this:match(whostr, olist)))","return this:match(objstr, whose.contents);","else","return whose;","endif","else","return object;","endif","\"Profane (#30788) - Sat Jan  3, 1998 - Changed so literals get returned ONLY if in the passed object list.\";","\"Profane (#30788) - Sat Jan  3, 1998 - OK, that broke lots of stuff, so changed it back.\";"]},{"name":"match_nth","owner":36,"perms":173,"preposition":-1,"code":["\":match_nth(string, objlist, n)\";","\"Find the nth object in 'objlist' that matches 'string'.\";","{what, where, n} = args;","for v in (where)","z = 0;","for q in (v.aliases)","z = z || (index(q, what) == 1);","endfor","if (z && (!(n = n - 1)))","return v;","endif","endfor","return $failed_match;"]},{"name":"match_verb","owner":2,"perms":173,"preposition":-1,"code":["\"$match_utils:match_verb(verbname, object) => Looks for a command-line style verb named <verbname> on <object> with current values of prepstr, dobjstr, dobj, iobjstr, and iobj.  If a match is made, the verb is called with @args[3] as arguments and 1 is returned.  Otherwise, 0 is returned.\";","{vrb, what, rest} = args;","if (where = $object_utils:has_verb(what, vrb))","if ((vargs = verb_args(where[1], vrb)) != {\"this\", \"none\", \"this\"})","if (((((((vargs[2] == \"any\") || ((!prepstr) && (vargs[2] == \"none\"))) || index((\"/\" + vargs[2]) + \"/\", (\"/\" + prepstr) + \"/\")) && (((vargs[1] == \"any\") || ((!dobjstr) && (vargs[1] == \"none\"))) || ((dobj == what) && (vargs[1] == \"this\")))) && (((vargs[3] == \"any\") || ((!iobjstr) && (vargs[3] == \"none\"))) || ((iobj == what) && (vargs[3] == \"this\")))) && index(verb_info(where[1], vrb)[2], \"x\")) && verb_code(where[1], vrb))","set_task_perms(caller_perms());","what:(vrb)(@rest);","return 1;","endif","endif","endif"]},{"name":"match_list","owner":36,"perms":173,"preposition":-1,"code":["\":match_list(string, object_list) -> List of all matches.\";","{what, where} = args;","if (!what)","return {};","endif","r = {};","for v in (where)","if (!(v in r))","z = 0;","for q in (v.aliases)","z = z || (q && (index(q, what) == 1));","endfor","if (z)","r = listappend(r, v);","endif","endif","endfor","return r;"]},{"name":"parse_ordinal_reference parse_ordref","owner":36,"perms":173,"preposition":-1,"code":["\":parse_ordref(string)\";","\"Parses strings referring to an 'nth' object.\";","\"=> {INT n, STR object} Where 'n' is the number the ordinal represents, and 'object' is the rest of the string.\";","\"=> 0 If the given string is not an ordinal reference.\";","\"  Example:\";","\":parse_ordref(\\\"second broadsword\\\") => {2, \\\"broadsword\\\"}\";","\":parse_ordref(\\\"second\\\") => 0\";","\"  Note that there must be more to the string than the ordinal alone.\";","if (m = match(args[1], (\"^\" + this.ordinal_regexp) + \" +%([^ ].+%)$\"))","o = substitute(\"%1\", m);","n = (o in this.ordn) || (o in this.ordw);","return n && {n, substitute(\"%2\", m)};","else","return 0;","endif"]},{"name":"parse_possessive_reference","owner":36,"perms":173,"preposition":-1,"code":["\":parse_possessive_reference(string)\";","\"Parses strings in a possessive format.\";","\"=> {STR whose, STR object}  Where 'whose' is the possessor of 'object'.\";","\"If the string consists only of a possessive string (ie: \\\"my\\\", or \\\"yduJ's\\\"), then 'object' will be an empty string.\";","\"=> 0 If the given string is not a possessive reference.\";","\"  Example:\";","\":parse_possessive_reference(\\\"joe's cat\\\") => {\\\"joe\\\", \\\"cat\\\"}\";","\":parse_possessive_reference(\\\"sis' fish\\\") => {\\\"sis\\\", \\\"fish\\\"}\";","\"  Strings are returned as a value suitable for a :match routine, thus 'my' becoming 'me'.\";","\":parse_possessive_reference(\\\"my dog\\\") => {\\\"me\\\", \\\"dog\\\"}\";","string = args[1];","if (m = match(string, \"^my$%|^my +%(.+%)?\"))","return {\"me\", substitute(\"%1\", m)};","elseif (m = match(string, \"^%(.+s?%)'s? *%(.+%)?\"))","return {substitute(\"%1\", m), substitute(\"%2\", m)};","else","return 0;","endif","\"Profane (#30788) - Sun Jun 21, 1998 - changed first parenthetical match bit from %([^ ]+s?%) to %(.+s?%)\";"]},{"name":"object_match_failed","owner":36,"perms":165,"preposition":-1,"code":["\"Usage: object_match_failed(object, string[, ambigs])\";","\"Prints a message if string does not match object.  Generally used after object is derived from a :match_object(string).\";","\"ambigs is an optional list of the objects that were matched upon.  If given, the message printed will list the ambiguous among them as choices.\";","{match_result, string, ?ambigs = 0} = args;","tell = (0 && $perm_utils:controls(caller_perms(), player)) ? \"notify\" | \"tell\";","if ((index(string, \"#\") == 1) && ($code_utils:toobj(string) != E_TYPE))","\"...avoid the `I don't know which `#-2' you mean' message...\";","if (!valid(match_result))","player:(tell)(tostr(\"There is no \\\"\", string, \"\\\" that you can see.\"));","endif","return !valid(match_result);","elseif (match_result == $nothing)","player:(tell)(\"You must give the name of some object.\");","elseif (match_result == $failed_match)","player:(tell)(tostr(\"There is no \\\"\", string, \"\\\" that you can see.\"));","elseif (match_result == $ambiguous_match)","if (typeof(ambigs) != LIST)","player:(tell)(tostr(\"I don't know which \\\"\", string, \"\\\" you mean.\"));","return 1;","endif","ambigs = $match_utils:match_list(string, ambigs);","ambigs = $list_utils:map_property(ambigs, \"name\");","if ((length($list_utils:remove_duplicates(ambigs)) == 1) && $object_utils:isa(player.location, this.matching_room))","player:(tell)(tostr(\"I don't know which \\\"\", string, \"\\\" you mean.  Try using \\\"first \", string, \"\\\", \\\"second \", string, \"\\\", etc.\"));","else","player:(tell)(tostr(\"I don't know which \\\"\", string, \"\\\" you mean: \", $string_utils:english_list(ambigs, \"nothing\", \" or \"), \".\"));","endif","return 1;","elseif (!valid(match_result))","player:(tell)(tostr(\"The object you specified does not exist.  Seeing ghosts?\"));","else","return 0;","endif","return 1;"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","pass();","this.matching_room = $nothing;","endif"]},{"name":"has_property","owner":2,"perms":173,"preposition":-1,"code":["\"Syntax:  has_property(OBJ, STR) => INT 0|1\";","\"\";","\"Does object have the specified property? Returns true if it is defined on the object or a parent.\";","{object, prop} = args;","try","object.(prop);","return 1;","except (E_PROPNF, E_INVIND)","return 0;","endtry","\"Old code...Ho_Yan 10/22/96\";","if (prop in $code_utils.builtin_props)","return valid(object);","else","return !(!property_info(object, prop));","endif"]},{"name":"all_properties all_verbs","owner":2,"perms":173,"preposition":-1,"code":["\"Syntax:  all_properties (OBJ what)\";","\"         all_verbs      (OBJ what)\";","\"\";","\"Returns all properties or verbs defined on `what' and all of its ancestors. Uses wizperms to get properties or verbs if the caller of this verb owns what, otherwise, uses caller's perms.\";","what = args[1];","if (what.owner != caller_perms())","set_task_perms(caller_perms());","endif","bif = (verb == \"all_verbs\") ? \"verbs\" | \"properties\";","res = `call_function(bif, what) ! E_PERM => {}';","while (valid(what = parent(what)))","res = {@`call_function(bif, what) ! E_PERM => {}', @res};","endwhile","return res;"]},{"name":"has_verb","owner":2,"perms":173,"preposition":-1,"code":["\":has_verb(OBJ object, STR verbname)\";","\"Find out if an object has a verb matching the given verbname.\";","\"Returns {location} if so, 0 if not, where location is the object or the ancestor on which the verb is actually defined.\";","{object, verbname} = args;","while (valid(object))","try","if (verb_info(object, verbname))","return {object};","endif","except (E_VERBNF)","object = parent(object);","endtry","endwhile","return 0;","\"OLD CODE BELOW:\";","while (E_VERBNF == (vi = `verb_info(object, verbname) ! E_VERBNF, E_INVARG'))","object = parent(object);","endwhile","return vi ? {object} | 0;"]},{"name":"has_callable_verb","owner":2,"perms":173,"preposition":-1,"code":["\"Usage:  has_callable_verb(object, verb)\";","\"See if an object has a verb that can be called by another verb (i.e., that has its x permission bit set).\";","\"Return {location}, where location is the object that defines the verb, or 0 if the object doesn't have the verb.\";","{object, verbname} = args;","while (valid(object))","if (`index(verb_info(object, verbname)[2], \"x\") ! E_VERBNF => 0' && verb_code(object, verbname))","\"Don't need to catch E_VERBNF in verb_code(), since it will never get there with the 0 &&\";","return {object};","endif","object = parent(object);","endwhile","return 0;"]},{"name":"match_verb","owner":2,"perms":173,"preposition":-1,"code":["\":match_verb(OBJ object, STR verb)\";","\"Find out if an object has a given verb, and some information about it.\";","\"Returns {OBJ location, STR verb} if matched, 0 if not.\";","\"Location is the object on which it is actually defined, verb is a name\";","\"for the verb which can subsequently be used in verb_info (i.e., no\";","\"asterisks).\";","verbname = strsub(args[2], \"*\", \"\");","object = args[1];","while (E_VERBNF == (info = `verb_info(object, verbname) ! E_VERBNF, E_INVARG'))","object = parent(object);","endwhile","return info ? {object, verbname} | 0;"]},{"name":"isa","owner":36,"perms":173,"preposition":-1,"code":["\":isa(x,y) == valid(x) && (y==x || y in :ancestors(x))\";","{what, targ} = args;","while (valid(what))","if (what == targ)","return 1;","endif","what = parent(what);","endwhile","return 0;"]},{"name":"ancestors","owner":36,"perms":173,"preposition":-1,"code":["\"Usage:  ancestors(object[, object...])\";","\"Return a list of all ancestors of the object(s) in args, with no duplicates.\";","\"If called with a single object, the result will be in order ascending up the inheritance hierarchy.  If called with multiple objects, it probably won't.\";","ret = {};","for o in (args)","what = o;","while (valid(what = parent(what)))","ret = setadd(ret, what);","endwhile","endfor","return ret;"]},{"name":"ordered_descendants","owner":36,"perms":173,"preposition":-1,"code":["r = {what = args[1]};","for k in (children(what))","if (children(k))","r = {@r, @this:(verb)(k)};","else","r = {@r, k};","endif","endfor","return r;"]},{"name":"contains","owner":36,"perms":173,"preposition":-1,"code":["\"$object_utils:contains(obj1, obj2) -- does obj1 contain obj2?\";","\"\";","\"Return true iff obj2 is under obj1 in the containment hierarchy; that is, if obj1 is obj2's location, or its location's location, or ...\";","{loc, what} = args;","while (valid(what))","what = what.location;","if (what == loc)","return valid(loc);","endif","endwhile","return 0;"]},{"name":"all_contents","owner":36,"perms":173,"preposition":-1,"code":["\"all_contents(object)\";","\"Return a list of all objects contained (at some level) by object.\";","for y in (res = args[1].contents)","y.contents && (res = {@res, @this:all_contents(y)});","endfor","return res;"]},{"name":"findable_properties","owner":2,"perms":173,"preposition":-1,"code":["\"findable_properties(object)\";","\"Return a list of properties on those members of object's ancestor list that are readable or are owned by the caller (or all properties if the caller is a wizard).\";","what = args[1];","props = {};","who = caller_perms();","while (what != $nothing)","if ((what.r || (who == what.owner)) || who.wizard)","props = {@properties(what), @props};","endif","what = parent(what);","endwhile","return props;"]},{"name":"owned_properties","owner":2,"perms":173,"preposition":-1,"code":["\"owned_properties(what[, who])\";","\"Return a list of all properties on WHAT owned by WHO.\";","\"Only wizardly verbs can specify WHO; mortal verbs can only search for properties owned by their own owners.  For more information, talk to Gary_Severn.\";","what = anc = args[1];","who = ((c = caller_perms()).wizard && (length(args) > 1)) ? args[2] | c;","props = {};","while (anc != $nothing)","for k in (properties(anc))","if (property_info(what, k)[1] == who)","props = listappend(props, k);","endif","endfor","anc = parent(anc);","endwhile","return props;"]},{"name":"property_conflicts","owner":2,"perms":173,"preposition":-1,"code":["\":property_conflicts(object,newparent)\";","\"Looks for propertyname conflicts that would keep chparent(object,newparent)\";","\"  from working.\";","\"Returns a list of elements of the form {<propname>, @<objectlist>}\";","\"where <objectlist> is list of descendents of object defining <propname>.\";","if (!valid(object = args[1]))","return E_INVARG;","elseif (!valid(newparent = args[2]))","return (newparent == #-1) ? {} | E_INVARG;","elseif (!($perm_utils:controls(caller_perms(), object) && (newparent.f || $perm_utils:controls(caller_perms(), newparent))))","\"... if you couldn't chparent anyway, you don't need to know...\";","return E_PERM;","endif","\"... properties existing on newparent\";","\"... cannot be present on object or any descendent...\";","props = conflicts = {};","for o in ({object, @$object_utils:descendents_suspended(object)})","for p in (properties(o))","if (`property_info(newparent, p) ! E_PROPNF => 0')","if (i = p in props)","conflicts[i] = {@conflicts[i], o};","else","props = {@props, p};","conflicts = {@conflicts, {p, o}};","endif","endif","$command_utils:suspend_if_needed(0);","endfor","$command_utils:suspend_if_needed(0);","endfor","return conflicts;"]},{"name":"descendants_with_property_suspended","owner":2,"perms":173,"preposition":-1,"code":["\":descendants_with_property_suspended(object,property)\";","\" => list of descendants of object on which property is defined.\";","\"calls suspend(0) as needed\";","{object, prop} = args;","if ((caller == this) || (object.w || $perm_utils:controls(caller_perms(), object)))","$command_utils:suspend_if_needed(0);","if (`property_info(object, prop) ! E_PROPNF => 0')","return {object};","endif","r = {};","for c in (children(object))","r = {@r, @this:descendants_with_property_suspended(c, prop)};","endfor","return r;","else","return E_PERM;","endif"]},{"name":"locations","owner":2,"perms":173,"preposition":-1,"code":["\"Usage:  locations(object)\";","\"Return a listing of the location hierarchy above object.\";","ret = {};","what = args[1];","while (valid(what = what.location))","ret = {@ret, what};","endwhile","return ret;"]},{"name":"all_properties_suspended all_verbs_suspended","owner":2,"perms":173,"preposition":-1,"code":["\"Syntax:  all_properties_suspended (OBJ what)\";","\"         all_verbs_suspended      (OBJ what)\";","\"\";","\"Returns all properties or verbs defined on `what' and all of its ancestors. Uses wizperms to get properties or verbs if the caller of this verb owns what, otherwise, uses caller's perms. Suspends as necessary\";","what = args[1];","if (what.owner != caller_perms())","set_task_perms(caller_perms());","endif","bif = (verb == \"all_verbs\") ? \"verbs\" | \"properties\";","res = `call_function(bif, what) ! E_PERM => {}';","while (valid(what = parent(what)))","res = {@`call_function(bif, what) ! E_PERM => {}', @res};","$command_utils:suspend_if_needed(0);","endwhile","return res;"]},{"name":"connected","owner":36,"perms":173,"preposition":-1,"code":["\":connected(object) => true if object is a connected player.\";","\"equivalent to (object in connected_players()) for valid players, perhaps with less server overhead.\";","\"use object:is_listening() if you want to allow for puppets and other non-player objects that still 'care' about what's said.\";","return typeof(`connected_seconds(@args) ! E_INVARG') == INT;"]},{"name":"isoneof","owner":36,"perms":173,"preposition":-1,"code":["\":isoneof(x,y) = x isa z, for some z in list y\";","{what, targ} = args;","while (valid(what))","if (what in targ)","return 1;","endif","what = parent(what);","endwhile","return 0;"]},{"name":"defines_verb","owner":2,"perms":173,"preposition":-1,"code":["\"Returns 1 if the verb is actually *defined* on this object, 0 else.\";","\"Use this instead of :has_verb if your aim is to manipulate that verb code or whatever.\";","return `verb_info(@args) ! ANY => 0' && 1;","\"Old code below...Ho_Yan 10/22/96\";","info = verb_info(@args);","return typeof(info) != ERR;"]},{"name":"defines_property","owner":2,"perms":173,"preposition":-1,"code":["\":defines_property(OBJ object, STR property name) => Returns 1 if the property is actually *defined* on the object given\";","if (!valid(o = args[1]))","return 0;","elseif (!valid(p = parent(o)))","return this:has_property(o, args[2]);","else","return (!this:has_property(p, args[2])) && this:has_property(o, args[2]);","endif"]},{"name":"has_any_verb has_any_property","owner":2,"perms":173,"preposition":-1,"code":["\":has_any_verb(object) / :has_any_property(object)\";","\" -- does `object' have any verbs/properties?\";","return !(!`(verb == \"has_any_verb\") ? verbs(args[1]) | properties(args[1]) ! E_INVARG => 0');"]},{"name":"has_readable_prop*erty hrp","owner":2,"perms":173,"preposition":-1,"code":["\":has_readable_property(OBJ object, STR property name) => 1 if property exists and is publically readable (has the r flag set true).\";","{object, prop} = args;","try","pinfo = property_info(object, prop);","return index(pinfo[2], \"r\") != 0;","except (E_PROPNF)","return (prop in $code_utils.builtin_props) > 0;","endtry"]},{"name":"descendants descendents","owner":36,"perms":173,"preposition":-1,"code":["\":descendants (OBJ object) => {OBJs} all nested children of <object>\";","r = children(args[1]);","i = 1;","while (i <= length(r))","if (kids = children(r[i]))","r = {@r, @kids};","endif","i = i + 1;","endwhile","return r;"]},{"name":"leaves","owner":36,"perms":173,"preposition":-1,"code":["\":leaves (OBJ object) => {OBJs} descendants of <object> that have no children\";","r = {args[1]};","i = 1;","while (i <= length(r))","if (kids = children(r[i]))","r[i..i] = kids;","else","i = i + 1;","endif","endwhile","return r;"]},{"name":"branches","owner":36,"perms":173,"preposition":-1,"code":["\":branches (OBJ object) => {OBJs} descendants of <object> that have children\";","r = args[1..1];","i = 1;","while (i <= length(r))","if (kids = children(r[i]))","r[i + 1..i] = kids;","i = i + 1;","else","r[i..i] = {};","endif","endwhile","return r;"]},{"name":"descendants_suspended descendents_suspended","owner":2,"perms":173,"preposition":-1,"code":["\":descendants_suspended (OBJ object) => {OBJs} all nested children of <object>\";","set_task_perms(caller_perms());","r = children(args[1]);","i = 1;","while (i <= length(r))","if (kids = children(r[i]))","r = {@r, @kids};","endif","i = i + 1;","$command_utils:suspend_if_needed(0);","endwhile","return r;"]},{"name":"leaves_suspended","owner":2,"perms":173,"preposition":-1,"code":["\":leaves_suspended (OBJ object) => {OBJs} descendants of <object> that have\";","\"                                         no children\";","set_task_perms(caller_perms());","r = {args[1]};","i = 1;","while (i <= length(r))","if (kids = children(r[i]))","r[i..i] = kids;","else","i = i + 1;","endif","$command_utils:suspend_if_needed(0);","endwhile","return r;"]},{"name":"branches_suspended","owner":2,"perms":173,"preposition":-1,"code":["\":branches_suspended (OBJ object) => {OBJs} all descendants of <object> that\";","\"                                           have children.\";","set_task_perms(caller_perms());","r = args[1..1];","i = 1;","while (i <= length(r))","if (kids = children(r[i]))","r[i + 1..i] = kids;","i = i + 1;","else","r[i..i] = {};","endif","$command_utils:suspend_if_needed(0);","endwhile","return r;"]},{"name":"disown disinherit","owner":2,"perms":173,"preposition":-1,"code":["\":disown(object) / :disinherit(object)\";","\" => 1 (for a successful disinheritance)\";","\" raises E_PERM, E_INVARG, E_ARGS\";","cp = caller_perms();","\"     no set_task_perms() because we need to be able to\";","\"     chparent() an object we don't own\";","{victim} = args;","parent = parent(victim);","if ($perm_utils:controls(cp, victim))","raise(E_INVARG, tostr(victim.name, \" (\", victim, \") is yours.  Use @chparent.\"));","elseif (!valid(parent))","raise(E_INVARG, tostr(victim.name, \" (\", victim, \") is already an orphan.\"));","elseif (!$perm_utils:controls(cp, parent))","raise(E_PERM, tostr(parent.name, \" (\", parent, \"), the parent of \", victim.name, \" (\", victim, \"), is not yours.\"));","elseif (!valid(grandparent = parent(parent)))","\"... still not sure about this... do we care?  --Rog...\";","raise(E_INVARG, tostr(victim.name, \" (\", victim, \") has no grandparent to take custody.\"));","else","chparent(victim, grandparent);","return 1;","endif"]},{"name":"accessible_verbs","owner":2,"perms":173,"preposition":-1,"code":["\"  accessible_verbs(object)   => a list of verb names (or E_PERM) regardless of readability of object\";","set_task_perms(caller_perms());","thing = args[1];","verbs = {};","i = 1;","while ((info = `verb_info(thing, i) ! ANY') != E_VERBNF)","verbs = {@verbs, info ? info[3] | E_PERM};","i = i + 1;","endwhile","return verbs;"]},{"name":"init_scanner","owner":2,"perms":173,"preposition":-1,"code":["this.input_string = args[1];","this.input_length = length(args[1]);","this.input_index = 1;","this.index_incremented = 0;"]},{"name":"scan_token","owner":2,"perms":173,"preposition":-1,"code":["string = this.input_string;","len = this.input_length;","i = this.input_index;","while ((i <= len) && (string[i] == \" \"))","i = i + 1;","endwhile","if (i > len)","this.index_incremented = 0;","return \"\";","elseif ((ch = string[i]) in {\"(\", \")\", \"!\", \"?\"})","this.input_index = i + 1;","this.index_incremented = 1;","return ch;","elseif (ch in {\"&\", \"|\"})","this.input_index = i = i + 1;","this.index_incremented = 1;","if ((i <= len) && (string[i] == ch))","this.input_index = i + 1;","this.index_incremented = 2;","endif","return ch + ch;","else","start = i;","while ((i <= len) && (!((ch = string[i]) in {\"(\", \")\", \"!\", \"?\", \"&\", \"|\"})))","i = i + 1;","endwhile","this.input_index = i;","i = i - 1;","while (string[i] == \" \")","i = i - 1;","endwhile","this.index_incremented = (i - start) + 1;","return this:canonicalize_spaces(string[start..i]);","endif"]},{"name":"canonicalize_spaces","owner":2,"perms":173,"preposition":-1,"code":["name = args[1];","while (index(name, \"  \"))","name = strsub(name, \"  \", \" \");","endwhile","return name;"]},{"name":"parse_keyexp","owner":2,"perms":173,"preposition":-1,"code":["\"parse_keyexp(STRING keyexpression, OBJ player) => returns a list containing the coded key, or a string containing an error message if the attempt failed.\";","\"\";","\"Grammar for key expressions:\";","\"\";","\"    E ::= A       \";","\"       |  E || A  \";","\"       |  E && A  \";","\"    A ::= ( E )   \";","\"       |  ! A     \";","\"       |  object  \";","\"       |  ? object  \";","this:init_scanner(args[1]);","this.player = args[2];","return this:parse_E();"]},{"name":"parse_E","owner":2,"perms":173,"preposition":-1,"code":["exp = this:parse_A();","if (typeof(exp) != STR)","while ((token = this:scan_token()) in {\"&&\", \"||\"})","rhs = this:parse_A();","if (typeof(rhs) == STR)","return rhs;","endif","exp = {token, exp, rhs};","endwhile","\"The while loop above always eats a token. Reset it back so the iteration can find it again. Always losing `)'. Ho_Yan 3/9/95\";","this.input_index = this.input_index - this.index_incremented;","endif","return exp;"]},{"name":"parse_A","owner":2,"perms":173,"preposition":-1,"code":["token = this:scan_token();","if (token == \"(\")","exp = this:parse_E();","if ((typeof(exp) != STR) && (this:scan_token() != \")\"))","return \"Missing ')'\";","else","return exp;","endif","elseif (token == \"!\")","exp = this:parse_A();","if (typeof(exp) == STR)","return exp;","else","return {\"!\", exp};","endif","elseif (token == \"?\")","next = this:scan_token();","if (next in {\"(\", \")\", \"!\", \"&&\", \"||\", \"?\"})","return (\"Missing object-name before '\" + token) + \"'\";","elseif (next == \"\")","return \"Missing object-name at end of key expression\";","else","what = this:match_object(next);","if (typeof(what) == OBJ)","return {\"?\", this:match_object(next)};","else","return what;","endif","endif","elseif (token in {\"&&\", \"||\"})","return (\"Missing expression before '\" + token) + \"'\";","elseif (token == \"\")","return \"Missing expression at end of key expression\";","else","return this:match_object(token);","endif"]},{"name":"eval_key","owner":2,"perms":173,"preposition":-1,"code":["\"eval_key(LIST|OBJ coded key, OBJ testobject) => returns true if testobject will solve the provided key.\";","{key, who} = args;","type = typeof(key);","if (!(type in {LIST, OBJ}))","return 1;","elseif (typeof(key) == OBJ)","return (who == key) || $object_utils:contains(who, key);","endif","op = key[1];","if (op == \"!\")","return !this:eval_key(key[2], who);","elseif (op == \"?\")","return key[2]:is_unlocked_for(who);","elseif (op == \"&&\")","return this:eval_key(key[2], who) && this:eval_key(key[3], who);","elseif (op == \"||\")","return this:eval_key(key[2], who) || this:eval_key(key[3], who);","else","raise(E_DIV);","endif"]},{"name":"match_object","owner":2,"perms":173,"preposition":-1,"code":["\"used by $lock_utils to unparse a key expression so one can use `here' and `me' as well as doing the regular object matching.\";","token = args[1];","if (token == \"me\")","return this.player;","elseif (token == \"here\")","if (valid(this.player.location))","return this.player.location;","else","return (\"'here' has no meaning where \" + this.player.name) + \" is\";","endif","else","what = this.player.location:match_object(token);","if (what == $failed_match)","return (\"Can't find an object named '\" + token) + \"'\";","elseif (what == $ambiguous_match)","return (\"Multiple objects named '\" + token) + \"'\";","else","return what;","endif","endif"]},{"name":"unparse_key","owner":2,"perms":173,"preposition":-1,"code":["\":unparse_key(LIST|OBJ coded key) => returns a string describing the key in english/moo-code terms.\";","\"Example:\";","\"$lock_utils:unparse_key({\\\"||\\\", $hacker, $housekeeper}) => \\\"#18105[Hacker] || #36830[housekeeper]\\\"\";","key = args[1];","type = typeof(key);","if (!(type in {LIST, OBJ}))","return \"(None.)\";","elseif (type == OBJ)","if (valid(key))","return tostr(key, \"[\", key.name, \"]\");","else","return tostr(key);","endif","else","op = key[1];","arg1 = this:unparse_key(key[2]);","if (op == \"?\")","return \"?\" + arg1;","elseif (op == \"!\")","if (typeof(key[2]) == LIST)","return (\"!(\" + arg1) + \")\";","else","return \"!\" + arg1;","endif","elseif (op in {\"&&\", \"||\"})","other = (op == \"&&\") ? \"||\" | \"&&\";","lhs = arg1;","rhs = this:unparse_key(key[3]);","if ((typeof(key[2]) == OBJ) || (key[2][1] != other))","exp = lhs;","else","exp = (\"(\" + lhs) + \")\";","endif","exp = ((exp + \" \") + op) + \" \";","if ((typeof(key[3]) == OBJ) || (key[3][1] != other))","exp = exp + rhs;","else","exp = ((exp + \"(\") + rhs) + \")\";","endif","return exp;","else","raise(E_DIV);","endif","endif"]},{"name":"eval_key_new","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms($no_one);","{key, who} = args;","type = typeof(key);","if (!(type in {LIST, OBJ}))","return 1;","elseif (typeof(key) == OBJ)","return (who == key) || $object_utils:contains(who, key);","endif","op = key[1];","if (op == \"!\")","return !this:eval_key(key[2], who);","elseif (op == \"?\")","return key[2]:is_unlocked_for(who);","elseif (op == \"&&\")","return this:eval_key(key[2], who) && this:eval_key(key[3], who);","elseif (op == \"||\")","return this:eval_key(key[2], who) || this:eval_key(key[3], who);","elseif (op == \".\")","if ($object_utils:has_property(who, key[2]) && who.(key[2]))","return 1;","else","for thing in ($object_utils:all_contents(who))","if ($object_utils:has_property(thing, key[2]) && thing.(key[2]))","return 1;","endif","endfor","endif","return 0;","elseif (op == \":\")","if ($object_utils:has_verb(who, key[2]) && who:(key[2])())","return 1;","else","for thing in ($object_utils:all_contents(who))","if ($object_utils:has_verb(thing, key[2]) && thing:(key[2])())","return 1;","endif","endfor","endif","return 0;","else","raise(E_DIV);","endif"]},{"name":"parse_A_new","owner":2,"perms":173,"preposition":-1,"code":["token = this:scan_token();","if (token == \"(\")","exp = this:parse_E();","if ((typeof(exp) != STR) && (this:scan_token() != \")\"))","return \"Missing ')'\";","else","return exp;","endif","elseif (token == \"!\")","exp = this:parse_A();","if (typeof(exp) == STR)","return exp;","else","return {\"!\", exp};","endif","elseif (token == \"?\")","next = this:scan_token();","if (next in {\":\", \".\", \"(\", \")\", \"!\", \"&&\", \"||\", \"?\"})","return (\"Missing object-name before '\" + token) + \"'\";","elseif (next == \"\")","return \"Missing object-name at end of key expression\";","else","what = this:match_object(next);","if (typeof(what) == OBJ)","return {\"?\", this:match_object(next)};","else","return what;","endif","endif","elseif (token in {\":\", \".\"})","next = this:scan_token();","if (next in {\":\", \".\", \"(\", \")\", \"!\", \"&&\", \"||\", \"?\"})","return (\"Missing verb-or-property-name before '\" + token) + \"'\";","elseif (next == \"\")","return \"Missing verb-or-property-name at end of key expression\";","elseif (typeof(next) != STR)","return \"Non-string verb-or-property-name at end of key expression\";","else","return {token, next};","endif","elseif (token in {\"&&\", \"||\"})","return (\"Missing expression before '\" + token) + \"'\";","elseif (token == \"\")","return \"Missing expression at end of key expression\";","else","return this:match_object(token);","endif"]},{"name":"burn","owner":2,"perms":41,"preposition":-1,"code":["who = valid(caller_perms()) ? caller_perms() | player;","if ($perm_utils:controls(who, this) || this:is_readable_by(who))","result = this:do_burn();","else","result = 0;","endif","player:tell(result ? this:burn_succeeded_msg() | this:burn_failed_msg());","if (msg = result ? this:oburn_succeeded_msg() | this:oburn_failed_msg())","player.location:announce(player.name, \" \", msg);","endif"]},{"name":"burn_succeeded_msg oburn_succeeded_msg burn_failed_msg oburn_failed_msg","owner":2,"perms":173,"preposition":-1,"code":["return (msg = this.(verb)) ? $string_utils:pronoun_sub(msg) | \"\";"]},{"name":"do_burn","owner":2,"perms":173,"preposition":-1,"code":["if ((this != $letter) && ((caller == this) || $perm_utils:controls(caller_perms(), this)))","fork (0)","$recycler:_recycle(this);","endfork","return 1;","else","return E_PERM;","endif"]},{"name":"make","owner":36,"perms":173,"preposition":-1,"code":["\":make(n[,elt]) => a list of n elements, each of which == elt. elt defaults to 0.\";","{n, ?elt = 0} = args;","if (n < 0)","return E_INVARG;","endif","ret = {};","build = {elt};","while (1)","if (n % 2)","ret = {@ret, @build};","endif","if (n = n / 2)","build = {@build, @build};","else","return ret;","endif","endwhile"]},{"name":"range","owner":36,"perms":173,"preposition":-1,"code":["\":range([m,]n) => {m,m+1,...,n}\";","{?m = 1, n} = args;","ret = {};","for k in [m..n]","ret = {@ret, k};","endfor","return ret;"]},{"name":"map_prop*erty","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","{objs, prop} = args;","if (length(objs) > 50)","return {@this:map_prop(objs[1..$ / 2], prop), @this:map_prop(objs[($ / 2) + 1..$], prop)};","endif","strs = {};","for foo in (objs)","strs = {@strs, foo.(prop)};","endfor","return strs;"]},{"name":"map_verb","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","{objs, vrb, @rest} = args;","if (length(objs) > 50)","return {@this:map_verb(@listset(args, objs[1..$ / 2], 1)), @this:map_verb(@listset(args, objs[($ / 2) + 1..$], 1))};","endif","strs = {};","for o in (objs)","strs = {@strs, o:(vrb)(@rest)};","endfor","return strs;"]},{"name":"map_arg*s","owner":2,"perms":173,"preposition":-1,"code":["\"map_arg([n,]object,verb,@args) -- assumes the nth element of args is a list, calls object:verb(@args) with each element of the list substituted in turn, returns the list of results.  n defaults to 1.\";","\"map_verb_arg(o,v,{a...},a2,a3,a4,a5)={o:v(a,a2,a3,a4,a5),...}\";","\"map_verb_arg(4,o,v,a1,a2,a3,{a...},a5)={o:v(a1,a2,a3,a,a5),...}\";","set_task_perms(caller_perms());","if (n = args[1])","{object, verb, @rest} = args[2..$];","else","object = n;","n = 1;","{verb, @rest} = args[2..$];","endif","results = {};","for a in (rest[n])","results = listappend(results, object:(verb)(@listset(rest, a, n)));","endfor","return results;"]},{"name":"map_builtin","owner":2,"perms":173,"preposition":-1,"code":["\":map_builtin(objectlist,func) applies func to each of the objects in turn and returns the corresponding list of results.  This function is mainly here for completeness -- in the vast majority of situations, a simple for loop is better.\";","set_task_perms(caller_perms());","{objs, builtin} = args;","if (!`function_info(builtin) ! E_INVARG => 0')","return E_INVARG;","endif","if (length(objs) > 100)","return {@this:map_builtin(objs[1..$ / 2], builtin), @this:map_builtin(objs[($ / 2) + 1..$], builtin)};","endif","strs = {};","for foo in (objs)","strs = {@strs, call_function(builtin, foo)};","endfor","return strs;"]},{"name":"find_insert","owner":36,"perms":173,"preposition":-1,"code":["\"find_insert(sortedlist,key) => index of first element in sortedlist > key\";","\"  sortedlist is assumed to be sorted in increasing order and the number returned is anywhere from 1 to length(sortedlist)+1, inclusive.\";","{lst, key} = args;","if ((r = length(lst)) < 25)","for l in [1..r]","if (lst[l] > key)","return l;","endif","endfor","return r + 1;","else","l = 1;","while (r >= l)","if (key < lst[i = (r + l) / 2])","r = i - 1;","else","l = i + 1;","endif","endwhile","return l;","endif"]},{"name":"remove_duplicates","owner":36,"perms":173,"preposition":-1,"code":["\"remove_duplicates(list) => list as a set, i.e., all repeated elements removed.\";","out = {};","for x in (args[1])","out = setadd(out, x);","endfor","return out;"]},{"name":"arrayset","owner":36,"perms":173,"preposition":-1,"code":["\"arrayset(list,value,pos1,...,posn) -- returns list modified such that\";","\"  list[pos1][pos2][...][posn] == value\";","if (length(args) > 3)","return listset(@listset(args[1..3], this:arrayset(@listset(listdelete(args, 3), args[1][args[3]], 1)), 2));","\"... Rog's entry in the Obfuscated MOO-Code Contest...\";","else","return listset(@args);","endif"]},{"name":"setremove_all","owner":36,"perms":173,"preposition":-1,"code":["\":setremove_all(set,elt) => set with *all* occurences of elt removed\";","{set, what} = args;","while (w = what in set)","set[w..w] = {};","endwhile","return set;"]},{"name":"append","owner":36,"perms":173,"preposition":-1,"code":["\"append({a,b,c},{d,e},{},{f,g,h},...) =>  {a,b,c,d,e,f,g,h}\";","if (length(args) > 50)","return {@this:append(@args[1..$ / 2]), @this:append(@args[($ / 2) + 1..$])};","endif","l = {};","for a in (args)","l = {@l, @a};","endfor","return l;"]},{"name":"reverse","owner":36,"perms":173,"preposition":-1,"code":["\"reverse(list) => reversed list\";","return this:_reverse(@args[1]);"]},{"name":"_reverse","owner":36,"perms":173,"preposition":-1,"code":["\":_reverse(@list) => reversed list\";","if (length(args) > 50)","return {@this:_reverse(@args[($ / 2) + 1..$]), @this:_reverse(@args[1..$ / 2])};","endif","l = {};","for a in (args)","l = listinsert(l, a);","endfor","return l;"]},{"name":"compress","owner":36,"perms":173,"preposition":-1,"code":["\"compress(list) => list with consecutive repeated elements removed, e.g.,\";","\"compress({a,b,b,c,b,b,b,d,d,e}) => {a,b,c,b,d,e}\";","if (l = args[1])","out = {last = l[1]};","for x in (listdelete(l, 1))","if (x != last)","out = listappend(out, x);","last = x;","endif","endfor","return out;","else","return l;","endif"]},{"name":"sort","owner":36,"perms":173,"preposition":-1,"code":["\"sort(list[,keys]) => sorts keys (assumed to be all numbers or strings) and returns list with the corresponding permutation applied to it.  keys defaults to the list itself.\";","\"sort({x1,x3,x2},{1,3,2}) => {x1,x2,x3}\";","lst = args[1];","unsorted_keys = (use_sorted_lst = length(args) >= 2) ? args[2] | lst;","sorted_lst = sorted_keys = {};","for e in (unsorted_keys)","l = this:find_insert(sorted_keys, e);","sorted_keys = listinsert(sorted_keys, e, l);","if (use_sorted_lst)","sorted_lst = listinsert(sorted_lst, lst[length(sorted_keys)], l);","endif","endfor","return sorted_lst || sorted_keys;"]},{"name":"sort_suspended","owner":2,"perms":173,"preposition":-1,"code":["\":sort_suspended(interval,list[,keys]) => sorts keys (assumed to be all numbers or strings) and returns list with the corresponding permutation applied to it.  keys defaults to the list itself.\";","\"does suspend(interval) as needed.\";","set_task_perms(caller_perms());","interval = args[1];","if (typeof(interval) != INT)","return E_ARGS;","endif","lst = args[2];","unsorted_keys = (use_sorted_lst = length(args) >= 3) ? args[3] | lst;","sorted_lst = sorted_keys = {};","for e in (unsorted_keys)","l = this:find_insert(sorted_keys, e);","sorted_keys[l..l - 1] = {e};","if (use_sorted_lst)","sorted_lst[l..l - 1] = {lst[length(sorted_keys)]};","endif","$command_utils:suspend_if_needed(interval);","endfor","return sorted_lst || sorted_keys;"]},{"name":"slice","owner":36,"perms":173,"preposition":-1,"code":["\"slice(alist[,index]) returns a list of the index-th elements of the elements of alist, e.g., \";","\"    slice({{\\\"z\\\",1},{\\\"y\\\",2},{\\\"x\\\",5}},2) => {1,2,5}.\";","\"index defaults to 1 and may also be a nonempty list, e.g., \";","\"    slice({{\\\"z\\\",1,3},{\\\"y\\\",2,4}},{2,1}) => {{1,\\\"z\\\"},{2,\\\"y\\\"}}\";","{thelist, ?ind = 1} = args;","slice = {};","if (typeof(ind) == LIST)","for elt in (thelist)","s = {elt[ind[1]]};","for i in (listdelete(ind, 1))","s = {@s, elt[i]};","endfor","slice = {@slice, s};","endfor","else","for elt in (thelist)","slice = {@slice, elt[ind]};","endfor","endif","return slice;"]},{"name":"assoc","owner":36,"perms":173,"preposition":-1,"code":["\"assoc(target,list[,index]) returns the first element of `list' whose own index-th element is target.  Index defaults to 1.\";","\"returns {} if no such element is found\";","{target, thelist, ?indx = 1} = args;","for t in (thelist)","if ((typeof(t) == LIST) && `t[indx] == target ! E_RANGE => 0')","return t;","endif","endfor","return {};"]},{"name":"iassoc","owner":36,"perms":173,"preposition":-1,"code":["\"Copied from Moo_tilities (#332):iassoc by Mooshie (#106469) Wed Mar 18 19:27:51 1998 PST\";","\"Usage: iassoc(ANY target, LIST list [, INT index ]) => Returns the index of the first element of `list' whose own index-th element is target.  Index defaults to 1.\";","\"Returns 0 if no such element is found.\";","{target, thelist, ?indx = 1} = args;","for element in (thelist)","if (`element[indx] == target ! E_RANGE, E_TYPE => 0')","if (typeof(element) == LIST)","return element in thelist;","endif","endif","endfor","return 0;"]},{"name":"iassoc_suspended","owner":2,"perms":173,"preposition":-1,"code":["\"Copied from Moo_tilities (#332):iassoc_suspended by Mooshie (#106469) Wed Mar 18 19:27:53 1998 PST\";","\"Usage: iassoc_suspended(ANY target, LIST list [, INT index [, INT suspend-for ]]) => Returns the index of the first element of `list' whose own index-th element is target. Index defaults to 1.\";","\"Returns 0 if no such element is found.\";","\"Suspends as needed. Suspend length defaults to 0.\";","set_task_perms(caller_perms());","{target, thelist, ?indx = 1, ?suspend_for = 0} = args;","cu = $command_utils;","for element in (thelist)","if (`element[indx] == target ! E_RANGE, E_TYPE => 0' && (typeof(element) == LIST))","return element in thelist;","endif","cu:suspend_if_needed(suspend_for);","endfor","return 0;","\"Mooshie (#106469) - Tue Feb 10, PST - :assoc_suspended does a set_task_perms, why shouldn't this?\";"]},{"name":"assoc_prefix","owner":36,"perms":173,"preposition":-1,"code":["\"assoc_prefix(target,list[,index]) returns the first element of `list' whose own index-th element has target as a prefix.  Index defaults to 1.\";","{target, thelist, ?indx = 1} = args;","for t in (thelist)","if ((typeof(t) == LIST) && ((length(t) >= indx) && (index(t[indx], target) == 1)))","return t;","endif","endfor","return {};"]},{"name":"iassoc_prefix","owner":36,"perms":173,"preposition":-1,"code":["\"iassoc_prefix(target,list[,index]) returns the index of the first element of `list' whose own index-th element has target as a prefix.  Index defaults to 1.\";","{target, lst, ?indx = 1} = args;","for i in [1..length(lst)]","if ((typeof(lsti = lst[i]) == LIST) && ((length(lsti) >= indx) && (index(lsti[indx], target) == 1)))","return i;","endif","endfor","return 0;"]},{"name":"iassoc_sorted","owner":36,"perms":173,"preposition":-1,"code":["\"iassoc_sorted(target,sortedlist[,i]) => index of last element in sortedlist whose own i-th element is <= target.  i defaults to 1.\";","\"  sortedlist is assumed to be sorted in increasing order and the number returned is anywhere from 0 to length(sortedlist), inclusive.\";","{target, lst, ?indx = 1} = args;","if ((r = length(lst)) < 25)","for l in [1..r]","if (target < lst[l][indx])","return l - 1;","endif","endfor","return r;","else","l = 0;","r = r + 1;","while ((r - 1) > l)","if (target < lst[i = (r + l) / 2][indx])","r = i;","else","l = i;","endif","endwhile","return l;","endif"]},{"name":"sort_alist","owner":36,"perms":173,"preposition":-1,"code":["\":sort_alist(alist[,n]) sorts a list of tuples by n-th (1st) element.\";","{alist, ?sort_on = 1} = args;","if ((alist_length = length(alist)) < 25)","\"use insertion sort on short lists\";","return this:sort(alist, this:slice(@args));","endif","left_index = alist_length / 2;","right_index = (alist_length + 1) / 2;","left_sublist = this:sort_alist(alist[1..left_index], sort_on);","right_sublist = this:sort_alist(alist[left_index + 1..alist_length], sort_on);","\"...\";","\"... merge ...\";","\"...\";","left_key = left_sublist[left_index][sort_on];","right_key = right_sublist[right_index][sort_on];","if (left_key > right_key)","merged_list = {};","else","\"... alist_length >= 25 implies right_index >= 2...\";","\"... move right_index downward until left_key > right_key...\";","r = right_index - 1;","while (left_key <= (right_key = right_sublist[r][sort_on]))","if (r = r - 1)","else","return {@left_sublist, @right_sublist};","endif","endwhile","merged_list = right_sublist[r + 1..right_index];","right_index = r;","endif","while (l = left_index - 1)","\"... left_key > right_key ...\";","\"... move left_index downward until left_key <= right_key...\";","while ((left_key = left_sublist[l][sort_on]) > right_key)","if (l = l - 1)","else","return {@right_sublist[1..right_index], @left_sublist[1..left_index], @merged_list};","endif","endwhile","merged_list[1..0] = left_sublist[l + 1..left_index];","left_index = l;","\"... left_key <= right_key ...\";","if (r = right_index - 1)","\"... move right_index downward until left_key > right_key...\";","while (left_key <= (right_key = right_sublist[r][sort_on]))","if (r = r - 1)","else","return {@left_sublist[1..left_index], @right_sublist[1..right_index], @merged_list};","endif","endwhile","merged_list[1..0] = right_sublist[r + 1..right_index];","right_index = r;","else","return {@left_sublist[1..left_index], right_sublist[1], @merged_list};","endif","endwhile","return {@right_sublist[1..right_index], left_sublist[1], @merged_list};"]},{"name":"sort_alist_suspended","owner":2,"perms":173,"preposition":-1,"code":["\"sort_alist_suspended(interval,alist[,n]) sorts a list of tuples by n-th element.  n defaults to 1.  Calls suspend(interval) as necessary.\";","set_task_perms(caller_perms());","\"... so it can be killed...\";","{interval, alist, ?sort_on = 1} = args;","if ((alist_length = length(alist)) < 10)","\"insertion sort on short lists\";","$command_utils:suspend_if_needed(interval);","return this:sort(alist, this:slice(@listdelete(args, 1)));","endif","\"variables specially expanded for the anal-retentive\";","left_index = alist_length / 2;","right_index = (alist_length + 1) / 2;","left_sublist = this:sort_alist_suspended(interval, alist[1..left_index], sort_on);","right_sublist = this:sort_alist_suspended(interval, alist[left_index + 1..alist_length], sort_on);","left_element = left_sublist[left_index];","right_element = right_sublist[right_index];","merged_list = {};","while (1)","$command_utils:suspend_if_needed(interval);","if (left_element[sort_on] > right_element[sort_on])","merged_list = {left_element, @merged_list};","if (left_index = left_index - 1)","left_element = left_sublist[left_index];","else","return {@right_sublist[1..right_index], @merged_list};","endif","else","merged_list = {right_element, @merged_list};","if (right_index = right_index - 1)","right_element = right_sublist[right_index];","else","return {@left_sublist[1..left_index], @merged_list};","endif","endif","endwhile"]},{"name":"randomly_permute","owner":36,"perms":173,"preposition":-1,"code":["\":randomly_permute(list) => list with its elements randomly permuted\";","\"  each of the length(list)! possible permutations is equally likely\";","plist = {};","for i in [1..length(ulist = args[1])]","plist = listinsert(plist, ulist[i], random(i));","endfor","return plist;"]},{"name":"count","owner":2,"perms":173,"preposition":-1,"code":["\"$list_utils:count(item, list)\";","\"Returns the number of occurrences of item in list.\";","{x, xlist} = args;","if (typeof(xlist) != LIST)","return E_INVARG;","endif","counter = 0;","while (loc = x in xlist)","counter = counter + 1;","xlist = xlist[loc + 1..$];","endwhile","return counter;"]},{"name":"flatten","owner":36,"perms":173,"preposition":-1,"code":["\"Copied from $quinn_utils (#34283):unroll by Quinn (#19845) Mon Mar  8 09:29:03 1993 PST\";","\":flatten(LIST list_of_lists) => LIST of all lists in given list `flattened'\";","newlist = {};","for elm in (args[1])","if (typeof(elm) == LIST)","newlist = {@newlist, @this:flatten(elm)};","else","newlist = {@newlist, elm};","endif","endfor","return newlist;"]},{"name":"longest shortest","owner":36,"perms":173,"preposition":-1,"code":["\"Copied from APHiD (#33119):longest Sun May  9 21:00:18 1993 PDT\";","\"$list_utils:longest(<list>)\";","\"$list_utils:shortest(<list>)\";","\"             - Returns the shortest or longest element in the list.  Elements may be either strings or lists.  Returns E_TYPE if passed a non-list or a list containing non-string/list elements.  Returns E_RANGE if passed an empty list.\";","if (typeof(all = args[1]) != LIST)","return E_TYPE;","elseif (all == {})","return E_RANGE;","else","result = all[1];","for things in (all)","if ((typeof(things) != LIST) && (typeof(things) != STR))","return E_TYPE;","else","result = (((verb == \"longest\") && (length(result) < length(things))) || ((verb == \"shortest\") && (length(result) > length(things)))) ? things | result;","endif","endfor","endif","return result;"]},{"name":"check_nonstring_tell_lines","owner":36,"perms":173,"preposition":-1,"code":["\"check_nonstring_tell_lines(lines)\";","if (caller_perms().wizard)","\"don't let a nonwizard mess up our stats\";","for line in (args[1])","if (typeof(line) != STR)","this.nonstring_tell_lines = listappend(this.nonstring_tell_lines, callers());","return;","endif","endfor","endif"]},{"name":"reverse_suspended","owner":2,"perms":173,"preposition":-1,"code":["\"reverse(list) => reversed list.  Does suspend(0) as necessary.\";","set_task_perms(caller_perms());","\"^^^For suspend task.\";","return this:_reverse_suspended(@args[1]);"]},{"name":"_reverse_suspended","owner":2,"perms":173,"preposition":-1,"code":["\":_reverse(@list) => reversed list\";","set_task_perms(caller_perms());","$command_utils:suspend_if_needed(0);","if (length(args) > 50)","return {@this:_reverse_suspended(@args[($ / 2) + 1..$]), @this:_reverse_suspended(@args[1..$ / 2])};","endif","l = {};","for a in (args)","l = listinsert(l, a);","endfor","return l;"]},{"name":"randomly_permute_suspended","owner":2,"perms":173,"preposition":-1,"code":["\":randomly_permute_suspended(list) => list with its elements randomly permuted\";","\"  each of the length(list)! possible permutations is equally likely\";","set_task_perms(caller_perms());","plist = {};","for i in [1..length(ulist = args[1])]","plist = listinsert(plist, ulist[i], random(i));","$command_utils:suspend_if_needed(0);","endfor","return plist;"]},{"name":"swap_elements","owner":36,"perms":173,"preposition":-1,"code":["\"swap_elements -- exchange two elements in a list\";","\"Usage:  $list_utils:swap_elements(<list/LIST>,<index/INT>,<index/INT>)\";","\"        $list_utils:swap_elements({\\\"a\\\",\\\"b\\\"},1,2);\";","{l, i, j} = args;","if (((typeof(l) == LIST) && (typeof(i) == INT)) && (typeof(j) == INT))","ll = length(l);","if (((i > 0) && (i <= ll)) && ((j > 0) && (j <= ll)))","t = l[i];","l[i] = l[j];","l[j] = t;","return l;","else","return E_RANGE;","endif","else","return E_TYPE;","endif"]},{"name":"random_item random_element","owner":36,"perms":173,"preposition":-1,"code":["\"random_item -- returns a random element of the input list.\";","if (length(args) == 1)","if (typeof(l = args[1]) == LIST)","if (length(l) > 0)","return l[random($)];","else","return E_RANGE;","endif","else","return E_TYPE;","endif","else","return E_ARGS;","endif"]},{"name":"assoc_suspended","owner":2,"perms":173,"preposition":-1,"code":["\"Copied from Moo_tilities (#332):assoc_suspended by Mooshie (#106469) Wed Mar 18 19:27:54 1998 PST\";","\"Usage: assoc_suspended(ANY target, LIST list [, INT index [, INT suspend-for ])) => Returns the first element of `list' whose own index-th element is target.  Index defaults to 1.\";","\"Returns {} if no such element is found.\";","\"Suspends as necessary. Suspend length defaults to 0.\";","set_task_perms(caller_perms());","{target, thelist, ?indx = 1, ?suspend_for = 0} = args;","cu = $command_utils;","for t in (thelist)","if (`t[indx] == target ! E_TYPE => 0')","if ((typeof(t) == LIST) && (length(t) >= indx))","return t;","endif","endif","cu:suspend_if_needed(suspend_for);","endfor","return {};"]},{"name":"amerge","owner":36,"perms":173,"preposition":-1,"code":["\"Copied from Uther's_Ghost (#93141):amerge Tue May 27 20:28:18 1997 PDT\";","\"amerge(list[,tindex[,dindex]]) returns an associated list such that all the tuples in the original list with the same tindex-th element are merged. Useful for merging alists ( amerge({@alist1, @alist2, ...}) ) and for ensuring that each tuple has a unique index. Tindex defaults to 1. Dindex defaults to 1 and refers to the position in the tuple where the tindex-th element will land in the new tuple.\";","{alist, ?tidx = 1, ?didx = 1} = args;","if (alist)","alist = this:sort_alist(alist, tidx);","i = 1;","res = {{cur = alist[1][tidx]}};","for tuple in (alist)","if (tuple[tidx] == cur)","res[i] = {@res[i], @listdelete(tuple, tidx)};","else","if (didx != 1)","res[i] = this:swap_elements(res[i], 1, min(didx, length(res[i])));","endif","i = i + 1;","res = {@res, {cur = tuple[tidx], @listdelete(tuple, tidx)}};","endif","endfor","return res;","endif","return alist;"]},{"name":"passoc","owner":36,"perms":165,"preposition":-1,"code":["\"passoc -- essentially a hashtable lookup for parallel lists.  Parallel lists are an efficient way to store and access key/value pairs.\";","\"Usage:  $list_utils:passoc(<key>,<key-list>,<value-list>)\";","\"        avalue=$list_utils:passoc(\\\"akey\\\",keys,values)\";","return args[3][args[1] in args[2]];"]},{"name":"setmove","owner":36,"perms":173,"preposition":-1,"code":["\"Copied from Moo_tilities (#332):setmove by Mooshie (#106469) Mon Sep 22 21:07:25 1997 PDT\";","\"Usage: setmove(LIST elements, INT from, INT to)\";","\"Moves element in list from one position in list to another.\";","\"\";","\"Example: setmove({x, y, z}, 1, 3) => {y, z, x}\";","\"         setmove({x, y, z}, 2, 1} => {y, x, z}\";","{start, from, to} = args;","what = start[from];","return listinsert(listdelete(start, from), what, to);","\"  Written by Mooshie (#106469) @ Lambda - Mon Sep 22 21:03:26 1997 PDT -  \";"]},{"name":"iassoc_new","owner":36,"perms":173,"preposition":-1,"code":["\"Copied from Moo_tilities (#332):iassoc_new by Mooshie (#106469) Wed Mar 18 19:27:52 1998 PST\";","\"Usage: iassoc_new(ANY target, LIST list [, INT index ]) => Returns the index of the first element of `list' whose own index-th element is target.  Index defaults to 1.\";","\"Returns 0 if no such element is found.\";","\"NOTE: expects that each index in the given list will be a list with at least as many elements as the indicated `index' argument. Otherwise will return E_RANGE\";","{target, thelist, ?indx = 1} = args;","try","for element in (thelist)","if (element[indx] == target)","if (typeof(element) == LIST)","return element in thelist;","endif","endif","endfor","except e (ANY)","return e[1];","endtry","return 0;"]},{"name":"build_alist","owner":36,"perms":173,"preposition":-1,"code":["\"Syntax:  build_alist(list, N) =>\";","\"{list[1..N], list[N+1..N*2], list[N*2+1..N*3], ..., list[N*(N-1)+1..N*N]}\";","\"\";","\"Creates an associated list from a flat list at every Nth interval. If the list doesn't have a multiple of N elements, E_RANGE is returned.\";","\"Example:  build_alist({a,b,c,d,e,f,g,h,i},3)=>{{a,b,c},{d,e,f},{g,h,i}}\";","{olist, interval} = args;","if ((tot = length(olist)) % interval)","return E_RANGE;","endif","nlist = {};","d = 1;","while (d <= tot)","nlist = {@nlist, olist[1..interval]};","olist[1..interval] = {};","d = d + interval;","endwhile","return nlist;"]},{"name":"object_match_failed","owner":2,"perms":173,"preposition":-1,"code":["\"Usage: object_match_failed(object, string)\";","\"Prints a message if string does not match object.  Generally used after object is derived from a :match_object(string).\";","{match_result, string} = args;","tell = $perm_utils:controls(caller_perms(), player) ? \"notify\" | \"tell\";","if ((index(string, \"#\") == 1) && ($code_utils:toobj(string) != E_TYPE))","\"...avoid the `I don't know which `#-2' you mean' message...\";","if (!valid(match_result))","player:(tell)(tostr(string, \" does not exist.\"));","endif","return !valid(match_result);","elseif (match_result == $nothing)","player:(tell)(\"You must give the name of some object.\");","elseif (match_result == $failed_match)","player:(tell)(tostr(\"I see no \\\"\", string, \"\\\" here.\"));","elseif (match_result == $ambiguous_match)","player:(tell)(tostr(\"I don't know which \\\"\", string, \"\\\" you mean.\"));","elseif (!valid(match_result))","player:(tell)(tostr(match_result, \" does not exist.\"));","else","return 0;","endif","return 1;"]},{"name":"player_match_result player_match_failed","owner":2,"perms":173,"preposition":-1,"code":["\":player_match_failed(result,string)\";","\"  is exactly like :object_match_failed(result,string)\";","\"  except that its messages are more suitable for player searches.\";","\":player_match_result(results,strings)\";","\"  handles a list of results, also presumably from $string_utils:match_player(strings), printing messages to player for *each* of the nonmatching strings.  It returns a list, an overall result (true if some string didn't match --- just like player_match_failed), followed by the list players that matched.\";","\"\";","\"An optional 3rd arg gives an identifying string to prefix to each of the nasty messages.\";","if (valid(player))","tell = $perm_utils:controls(caller_perms(), player) ? \"notify\" | \"tell\";","plyr = player;","else","tell = \"notify\";","plyr = $login;","endif","\"...\";","{match_results, strings, ?cmdid = \"\"} = args;","pmf = verb == \"player_match_failed\";","if (typeof(match_results) == OBJ)","match_results = {match_results};","strings = {strings};","endif","pset = {};","bombed = 0;","for i in [1..length(match_results)]","if (valid(result = match_results[i]))","pset = setadd(pset, match_results[i]);","elseif (result == $nothing)","\"... player_match_result quietly skips over blank strings\";","if (pmf)","plyr:(tell)(\"You must give the name of some player.\");","bombed = 1;","endif","elseif (result == $failed_match)","plyr:(tell)(tostr(cmdid, \"\\\"\", strings[i], \"\\\" is not the name of any player.\"));","bombed = 1;","elseif (result == $ambiguous_match)","lst = $player_db:find_all(strings[i]);","plyr:(tell)(tostr(cmdid, \"\\\"\", strings[i], \"\\\" could refer to \", (length(lst) > 20) ? tostr(\"any of \", length(lst), \" players\") | $string_utils:english_list($list_utils:map_arg(2, $string_utils, \"pronoun_sub\", \"%n (%#)\", lst), \"no one\", \" or \"), \".\"));","bombed = 1;","else","plyr:(tell)(tostr(result, \" does not exist.\"));","bombed = 1;","endif","endfor","return pmf ? bombed | {bombed, @pset};"]},{"name":"read","owner":2,"perms":173,"preposition":-1,"code":["\"$command_utils:read() -- read a line of input from the player and return it\";","\"Optional argument is a prompt portion to replace `a line of input' in the prompt.\";","\"\";","\"Returns E_PERM if the current task is not a command task that has never called suspend().\";","{?prompt = \"a line of input\"} = args;","c = callers();","p = c[$][5];","p:notify(tostr(\"[Type \", prompt, \" or `@abort' to abort the command.]\"));","try","ans = read();","if ($string_utils:trim(ans) == \"@abort\")","p:notify(\">> Command Aborted <<\");","kill_task(task_id());","endif","return ans;","except error (ANY)","return error[1];","endtry"]},{"name":"read_lines","owner":2,"perms":173,"preposition":-1,"code":["\"$command_utils:read_lines([max]) -- read zero or more lines of input\";","\"\";","\"Returns a list of strings, the (up to MAX, if given) lines typed by the player.  Returns E_PERM if the current task is not a command task that has never called suspend().\";","\"In order that one may enter arbitrary lines, including \\\"@abort\\\" or \\\".\\\", if the first character in an input line is `.' and there is some nonwhitespace afterwords, the `.' is dropped and the rest of the line is taken verbatim, so that, e.g., \\\".@abort\\\" enters as \\\"@abort\\\" and \\\"..\\\" enters as \\\".\\\".\";","{?max = 0} = args;","c = callers();","p = c[$][5];","p:notify(tostr(\"[Type\", max ? tostr(\" up to \", max) | \"\", \" lines of input; use `.' to end or `@abort' to abort the command.]\"));","ans = {};","while (1)","try","line = read();","if ((line[1..min(6, $)] == \"@abort\") && ((tail = line[7..$]) == $string_utils:space(tail)))","p:notify(\">> Command Aborted <<\");","kill_task(task_id());","elseif ((!line) || (line[1] != \".\"))","ans = {@ans, line};","elseif ((tail = line[2..$]) == $string_utils:space(tail))","return ans;","else","ans = {@ans, tail};","endif","if (max && (length(ans) >= max))","return ans;","endif","except error (ANY)","return error[1];","endtry","endwhile"]},{"name":"yes_or_no","owner":2,"perms":173,"preposition":-1,"code":["\":yes-or-no([prompt]) -- prompts the player for a yes or no answer and returns a true value iff the player enters a line of input that is some prefix of \\\"yes\\\"\";","\"\";","\"Returns E_NONE if the player enters a blank line, E_INVARG, if the player enters something that isn't a prefix of \\\"yes\\\" or \\\"no\\\", and E_PERM if the current task is not a command task that has never called suspend().\";","c = callers();","p = c[$][5];","p:notify(tostr(args ? args[1] + \" \" | \"\", \"[Enter `yes' or `no']\"));","try","ans = read(@((caller == p) || $perm_utils:controls(caller_perms(), p)) ? {p} | {});","if (ans = $string_utils:trim(ans))","if (ans == \"@abort\")","p:notify(\">> Command Aborted <<\");","kill_task(task_id());","endif","return (index(\"yes\", ans) == 1) || ((index(\"no\", ans) != 1) && E_INVARG);","else","return E_NONE;","endif","except error (ANY)","return error[1];","endtry"]},{"name":"read_lines_escape","owner":2,"perms":173,"preposition":-1,"code":["\"$command_utils:read_lines_escape(escapes[,help]) -- read zero or more lines of input\";","\"\";","\"Similar to :read_lines() except that help is available and one may specify other escape sequences to terminate the read.\";","\"  escapes should be either a string or list of strings; this specifies which inputs other from `.' or `@abort' should terminate the read (... don't use anything beginning with a `.').\";","\"  help should be a string or list of strings to be printed in response to the player typing `?'; the first line of the help text should be a general comment about what the input text should be used for.  Successive lines should describe the effects of the alternative escapes.\";","\"Returns {end,list-of-strings-input} where end is the particular line that terminated this input or 0 if input terminated normally with `.'.  Returns E_PERM if the current task is not a command task that has never called suspend().  \";","\"@abort and lines beginning with `.' are treated exactly as with :read_lines()\";","{escapes, ?help = \"You are currently in a read loop.\"} = args;","c = callers();","p = c[$][5];","escapes = {\".\", \"@abort\", @(typeof(escapes) == LIST) ? escapes | {escapes}};","p:notify(tostr(\"[Type lines of input; `?' for help; end with `\", $string_utils:english_list(escapes, \"\", \"' or `\", \"', `\", \"\"), \"'.]\"));","ans = {};","escapes[1..0] = {\"?\"};","\"... set up the help text...\";","if (typeof(help) != LIST)","help = {help};","endif","help[2..1] = {\"Type `.' on a line by itself to finish.\", \"Anything else with a leading period is entered with the period removed.\", \"Type `@abort' to abort the command completely.\"};","while (1)","try","line = read();","if ((trimline = $string_utils:trimr(line)) in escapes)","if (trimline == \".\")","return {0, ans};","elseif (trimline == \"@abort\")","p:notify(\">> Command Aborted <<\");","kill_task(task_id());","elseif (trimline == \"?\")","p:notify_lines(help);","else","return {trimline, ans};","endif","else","if (line && (line[1] == \".\"))","line[1..1] = \"\";","endif","ans = {@ans, line};","endif","except error (ANY)","return error[1];","endtry","endwhile"]},{"name":"suspend","owner":2,"perms":173,"preposition":-1,"code":["\"Suspend, using output_delimiters() in case a client needs to keep track\";","\"of the output of the current command.\";","\"Args are TIME, amount of time to suspend, and optional (misnamed) OUTPUT.\";","\"If given no OUTPUT, just do a suspend.\";","\"If OUTPUT is neither list nor string, suspend and return output_delimiters\";","\"If OUTPUT is a list, it should be in the output_delimiters() format:\";","\"  {PREFIX, SUFFIX}.  Use these to handle that client stuff.\";","\"If OUTPUT is a string, it should be SUFFIX (output_delimiters[2])\";","\"\";","\"Proper usage:\";","\"The first time you want to suspend, use\";","\"  output_delimiters = $command_utils:suspend(time, x);\";","\"where x is some non-zero number.\";","\"Following, use\";","\"  $command_utils:suspend(time, output_delimiters);\";","\"To wrap things up, use\";","\"  $command_utils:suspend(time, output_delimiters[2]);\";","\"You'll probably want time == 0 most of the time.\";","\"Note: Using this from verbs called by other verbs could get pretty weird.\";","{time, ?output = 0} = args;","set_task_perms(caller_perms());","value = 0;","if (!output)","suspend(time);","else","if (typeof(output) == LIST)","PREFIX = output[1];","SUFFIX = output[2];","if (PREFIX)","player:tell(output[2]);","endif","suspend(time);","if (SUFFIX)","player:tell(output[1]);","endif","elseif (typeof(output) == STR)","if (output)","player:tell(output);","endif","else","output = output_delimiters(player);","suspend(time);","if (output != {\"\", \"\"})","player:tell(output[1]);","endif","value = output;","endif","endif","return output;"]},{"name":"running_out_of_time","owner":36,"perms":173,"preposition":-1,"code":["\"Return true if we're running out of ticks or seconds.\";","return (ticks_left() < 4000) || (seconds_left() < 2);","\"If this verb is changed make sure to change :suspend_if_needed as well.\";"]},{"name":"suspend_if_needed","owner":2,"perms":173,"preposition":-1,"code":["\"Usage:  $command_utils:suspend_if_needed(<time>[, @<announcement>])\";","\"See if we're running out of ticks or seconds, and if so suspend(<time>) and return true.  If more than one arg is given, print the remainder with player:tell.\";","if ((ticks_left() < 4000) || (seconds_left() < 2))","\"Note: above computation should be the same as :running_out_of_time.\";","{?time = 10, @ann} = args;","if (ann && valid(player))","player:tell(tostr(@ann));","endif","amount = max(time, min($login:current_lag(), 10));","set_task_perms(caller_perms());","\"this is trying to back off according to lag...\";","suspend(amount);","return 1;","endif"]},{"name":"dump_lines","owner":36,"perms":173,"preposition":-1,"code":["\":dump_lines(text) => text `.'-quoted for :read_lines()\";","\"  text is assumed to be a list of strings\";","\"Returns a corresponding list of strings which, when read via :read_lines, \";","\"produces the original list of strings (essentially, any strings beginning \";","\"with a period \\\".\\\" have the period doubled).\";","\"The list returned includes a final \\\".\\\"\";","text = args[1];","newtext = {};","i = lasti = 0;","for line in (text)","if (match(line, \"^%(%.%| *@abort *$%)\"))","newtext = {@newtext, @(i > lasti) ? text[lasti + 1..i] | {}, \".\" + line};","lasti = i = i + 1;","else","i = i + 1;","endif","endfor","return {@newtext, @(i > lasti) ? text[lasti + 1..i] | {}, \".\"};"]},{"name":"explain_syntax","owner":2,"perms":173,"preposition":-1,"code":["\":explain_syntax(here,verb,args)\";","verb = args[2];","for x in ({player, args[1], @valid(dobj) ? {dobj} | {}, @valid(iobj) ? {iobj} | {}})","what = x;","while (hv = $object_utils:has_verb(what, verb))","what = hv[1];","i = 1;","while (i = $code_utils:find_verb_named(what, verb, i))","if (evs = $code_utils:explain_verb_syntax(x, verb, @verb_args(what, i)))","player:tell(\"Try this instead:  \", evs);","return 1;","endif","i = i + 1;","endwhile","what = parent(what);","endwhile","endfor","return 0;"]},{"name":"do_huh","owner":2,"perms":165,"preposition":-1,"code":["\":do_huh(verb,args)  what :huh should do by default.\";","{verb, args} = args;","if ($perm_utils:controls(caller_perms(), player) || (caller_perms() == player))","this.feature_task = {task_id(), verb, args, argstr, dobj, dobjstr, prepstr, iobj, iobjstr};","endif","set_task_perms(cp = caller_perms());","notify = $perm_utils:controls(cp, player) ? \"notify\" | \"tell\";","if (verb == \"\")","\"should only happen if a player types backslash\";","player:(notify)(\"I don't understand that.\");","return;","endif","if (player:my_huh(verb, args))","\"... the player found something funky to do ...\";","elseif (caller:here_huh(verb, args))","\"... the room found something funky to do ...\";","elseif (player:last_huh(verb, args))","\"... player's second round found something to do ...\";","elseif (dobj == $ambiguous_match)","if (iobj == $ambiguous_match)","player:(notify)(tostr(\"I don't understand that (\\\"\", dobjstr, \"\\\" and \\\"\", iobjstr, \"\\\" are both ambiguous names).\"));","else","player:(notify)(tostr(\"I don't understand that (\\\"\", dobjstr, \"\\\" is an ambiguous name).\"));","endif","elseif (iobj == $ambiguous_match)","player:(notify)(tostr(\"I don't understand that (\\\"\", iobjstr, \"\\\" is an ambiguous name).\"));","else","player:(notify)(\"I don't understand that.\");","player:my_explain_syntax(caller, verb, args) || (caller:here_explain_syntax(caller, verb, args) || this:explain_syntax(caller, verb, args));","endif"]},{"name":"task_info","owner":2,"perms":173,"preposition":-1,"code":["\"task_info(task id)\";","\"Return info (the same info supplied by queued_tasks()) about a given task id, or E_INVARG if there's no such task queued.\";","\"WIZARDLY\";","set_task_perms(caller_perms());","tasks = queued_tasks();","task_id = args[1];","for task in (tasks)","if (task[1] == task_id)","return task;","endif","endfor","return E_INVARG;"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","this.lag_samples = {};","this.feature_task = \"hey, neat, no feature verbs have been run yet!\";","endif"]},{"name":"kill_if_laggy","owner":36,"perms":173,"preposition":-1,"code":["\"Kills this task if the current lag is greater than args[1].  Args[2..n] will be passed to player:tell.\";","cutoff = args[1];","if ($login:current_lag() > cutoff)","player:tell(@listdelete(args, 1));","kill_task(task_id());","endif"]},{"name":"validate_feature","owner":36,"perms":173,"preposition":-1,"code":["\":validate_feature(verb, args)\";","\"  (where `verb' and `args' are the arguments passed to :my_huh)\";","\"  returns true or false based on whether this is the same command typed by the user (comparing it against $command_utils.feature_task, set by $command_utils:do_huh).\";","\"  assumes that the :my_huh parsing has not suspended\";","return {task_id(), @args, argstr, dobj, dobjstr, prepstr, iobj, iobjstr} == this.feature_task;"]},{"name":"@chown*#","owner":2,"perms":89,"preposition":-2,"code":["if ((!player.wizard) || (player != this))","player:notify(\"Sorry.\");","return;","endif","set_task_perms(player);","args = setremove(args, \"to\");","if ((length(args) != 2) || (!args[2]))","player:notify(tostr(\"Usage:  \", verb, \" <object-or-property-or-verb> <owner>\"));","return;","endif","what = args[1];","owner = $string_utils:match_player(args[2]);","bynumber = verb == \"@chown#\";","if ($command_utils:player_match_result(owner, args[2])[1])","elseif (spec = $code_utils:parse_verbref(what))","object = this:my_match_object(spec[1]);","if (!$command_utils:object_match_failed(object, spec[1]))","vname = spec[2];","if (bynumber)","vname = $code_utils:toint(vname);","if (vname == E_TYPE)","return player:notify(\"Verb number expected.\");","elseif ((vname < 1) || (vname > length(verbs(object))))","return player:notify(\"Verb number out of range.\");","endif","endif","info = `verb_info(object, vname) ! ANY';","if (info == E_VERBNF)","player:notify(\"That object does not define that verb.\");","elseif (typeof(info) == ERR)","player:notify(tostr(info));","else","try","result = set_verb_info(object, vname, listset(info, owner, 1));","player:notify(\"Verb owner set.\");","except e (ANY)","player:notify(e[2]);","endtry","endif","endif","elseif (bynumber)","player:notify(\"@chown# can only be used with verbs.\");","elseif (index(what, \".\") && (spec = $code_utils:parse_propref(what)))","object = this:my_match_object(spec[1]);","if (!$command_utils:object_match_failed(object, spec[1]))","pname = spec[2];","e = $wiz_utils:set_property_owner(object, pname, owner);","if (e == E_NONE)","player:notify(\"+c Property owner set.  Did you really want to do that?\");","else","player:notify(tostr(e && \"Property owner set.\"));","endif","endif","else","object = this:my_match_object(what);","if (!$command_utils:object_match_failed(object, what))","player:notify(tostr($wiz_utils:set_owner(object, owner) && \"Object ownership changed.\"));","endif","endif"]},{"name":"@shout","owner":2,"perms":89,"preposition":-2,"code":["if (caller != this)","raise(E_PERM);","endif","set_task_perms(player);","if ((length(args) == 1) && (argstr[1] == \"\\\"\"))","argstr = args[1];","endif","shout = $gender_utils:get_conj(\"shouts\", player);","for person in (connected_players())","if (person != player)","person:notify(tostr(player.name, \" \", shout, \", \\\"\", argstr, \"\\\"\"));","endif","endfor","player:notify(tostr(\"You shout, \\\"\", argstr, \"\\\"\"));"]},{"name":"@grant @grants* @transfer","owner":2,"perms":89,"preposition":1,"code":["\"@grant <object> to <player>\";","\"@grants <object> to <player>   --- same as @grant but may suspend.\";","\"@transfer <expression> to <player> -- like 'grant', but evalutes a possible list of objects to transfer, and modifies quota.\";","\"Ownership of the object changes as in @chown and :set_owner (i.e., .owner and all c properties change).  In addition all verbs and !c properties owned by the original owner change ownership as well.  Finally, for !c properties, instances on descendant objects change ownership (as in :set_property_owner).\";","if ((!player.wizard) || (player != this))","player:notify(\"Sorry.\");","return;","endif","set_task_perms(player);","if ((!iobjstr) || (!dobjstr))","return player:notify(tostr(\"Usage:  \", verb, \" <object> to <player>\"));","endif","if ($command_utils:player_match_failed(newowner = $string_utils:match_player(iobjstr), iobjstr))","\"...newowner is bogus...\";","return;","endif","if (verb == \"@transfer\")","objlist = player:eval_cmd_string(dobjstr, 0);","if (!objlist[1])","player:notify(tostr(\"Had trouble reading `\", dobjstr, \"': \"));","player:notify_lines(@objlist[2]);","return;","elseif (typeof(objlist[2]) == OBJ)","objlist = objlist[2..2];","elseif (typeof(objlist[2]) != LIST)","player:notify(tostr(\"Value of `\", dobjstr, \"' is not an object or list:  \", toliteral(objlist[2])));","return;","else","objlist = objlist[2];","endif","elseif ($command_utils:object_match_failed(object = this:my_match_object(dobjstr), dobjstr))","\"...object is bogus...\";","return;","else","objlist = {object};","endif","\"Used to check for quota of newowner, but doesn't anymore, cuz the quota check doesn't work\";","suspendok = verb != \"@grant\";","player:tell(\"Transferring \", toliteral(objlist), \" to \", $string_utils:nn(newowner));","for object in (objlist)","$command_utils:suspend_if_needed(0);","same = object.owner == newowner;","for vnum in [1..length(verbs(object))]","info = verb_info(object, vnum);","if (!((info[1] != object.owner) && (valid(info[1]) && is_player(info[1]))))","same = same && (info[1] == newowner);","set_verb_info(object, vnum, listset(info, newowner, 1));","endif","endfor","for prop in (properties(object))","if (suspendok && ((ticks_left() < 5000) || (seconds_left() < 2)))","suspend(0);","endif","info = property_info(object, prop);","if (!(index(info[2], \"c\") || (((info[1] != object.owner) && valid(info[1])) && is_player(info[1]))))","same = same && (info[1] == newowner);","$wiz_utils:set_property_owner(object, prop, newowner, suspendok);","endif","endfor","if (suspendok)","suspend(0);","endif","$wiz_utils:set_owner(object, newowner, suspendok);","if (same)","player:notify(tostr(newowner.name, \" already owns everything \", newowner.ps, \" is entitled to on \", object.name, \".\"));","else","player:notify(tostr(\"Ownership changed on \", $string_utils:nn(object), \", verb, properties and descendants' properties.\"));","endif","endfor"]},{"name":"@programmer","owner":2,"perms":25,"preposition":-1,"code":["set_task_perms(player);","dobj = $string_utils:match_player(dobjstr);","if (dobj == $nothing)","player:notify(tostr(\"Usage:  \", verb, \" <playername>\"));","elseif ($command_utils:player_match_result(dobj, dobjstr)[1])","elseif ($wiz_utils:check_prog_restricted(dobj))","return player:notify(tostr(\"Sorry,\", dobj.name, \" is not allowed to be a programmer.\"));","elseif ((dobj.description == $player.description) && (!$command_utils:yes_or_no($string_utils:pronoun_sub(\"@Programmer %d despite %[dpp] lack of description?\"))))","player:notify(tostr(\"Okay, leaving \", dobj.name, \" !programmer.\"));","return;","elseif (result = $wiz_utils:set_programmer(dobj))","player:notify(tostr(dobj.name, \" (\", dobj, \") is now a programmer.  \", dobj.ppc, \" quota is currently \", $quota_utils:get_quota(dobj), \".\"));","player:notify(tostr(dobj.name, \" and the other wizards have been notified.\"));","if (msg = this:programmer_victim_msg())","dobj:notify(msg);","endif","if ($object_utils:isa(dobj.location, $room) && (msg = this:programmer_msg()))","dobj.location:announce_all_but({dobj}, msg);","endif","elseif (result == E_NONE)","player:notify(tostr(dobj.name, \" (\", dobj, \") is already a programmer...\"));","else","player:notify(tostr(result));","endif"]},{"name":"make-core-database","owner":2,"perms":25,"preposition":-1,"code":["if (!player.wizard)","player:notify(\"Nice try, but permission denied.\");","return;","elseif (args == {})","player:notify(tostr(\"Continuing with this command will destroy all but the central core of the database.  If you're really sure that you want to do this, type '\", verb, \" \", toint(o = $quota_utils:bi_create(#1)), \"' now.\"));","recycle(o);","return;","elseif (toobj(toint(args[1])) != max_object())","player:notify(tostr(\"Nice try, but you mistyped the self-destruct password.  Type '\", verb, \"' again to get a new password.\"));","return;","elseif (verb_info($wiz, verb)[1] != player)","player:notify(\"Sorry, but you must own this verb in order to use it.\");","return;","endif","\"----------------------------------------\";","player:notify(\"Blowing away $local...\");","$local = #-1;","\"----------------------------------------\";","player:notify(\"Identifying objects to be saved...\");","saved = {#0, player};","saved_props = {};","for p in (properties(#0))","v = #0.(p);","if ((typeof(v) == OBJ) && valid(v))","saved = setadd(saved, v);","saved_props = {@saved_props, p};","endif","endfor","for o in (saved)","\"Also save non-$ objects that are ancestors of $ objects\";","\"but leave out non-$ player classes and room classes\";","\"Come to think of it, what's the point of this? Can't we just give the generic gendered object a $-name? --Nosredna\";","if ((!$object_utils:isa(o, $player)) && (!$object_utils:isa(o, $room)))","p = parent(o);","while (valid(p))","saved = setadd(saved, p);","p = parent(p);","endwhile","endif","endfor","$player_class = $mail_recipient_class;","\"----------------------------------------\";","player:notify(\"Killing all queued tasks ...\");","for t in (queued_tasks())","kill_task(t[1]);","endfor","\"----------------------------------------\";","player:notify(\"Stripping you of any personal verbs and/or properties ...\");","suspend(0);","for i in [1..length(verbs(player))]","delete_verb(player, 1);","endfor","for p in (properties(player))","delete_property(player, p);","endfor","chparent(player, $wiz);","for p in ($object_utils:all_properties(player))","clear_property(player, p);","endfor","player.name = \"Wizard\";","player.aliases = {\"Wizard\"};","player.description = \"\";","player.key = 0;","player.ownership_quota = 100;","player.password = 0;","player.last_password_time = 0;","$gender_utils:set(player, \"neuter\");","\"----------------------------------------\";","suspend(0);","player:notify(\"Making you or $hacker the owner of every saved object, verb and property ...\");","for i in [1..length(saved)]","if ($command_utils:running_out_of_time())","suspend(0);","player:notify(tostr(\"... finished \", i - 1, \" out of \", length(saved), \" saved objects ...\"));","endif","o = saved[i];","if (valid(o.owner) && o.owner.wizard)","o.owner = player;","else","o.owner = $hacker;","endif","old_verbs = {};","for j in [1..length(verbs(o))]","if ((seconds_left() < 1) || (ticks_left() < 2000))","suspend(0);","player:notify(tostr(\"... finished \", i - 1, \" out of \", length(saved), \" saved objects ...\"));","endif","info = verb_info(o, j);","if (valid(info[1]) && info[1].wizard)","info = listset(info, player, 1);","else","info = listset(info, $hacker, 1);","endif","set_verb_info(o, j, info);","if (index(info[3], \"(old)\"))","old_verbs = {j, @old_verbs};","endif","endfor","for vname in (old_verbs)","delete_verb(o, vname);","endfor","for p in ($object_utils:all_properties(o))","if ((seconds_left() < 2) || (ticks_left() < 2000))","suspend(0);","player:notify(tostr(\"... finished \", i - 1, \" out of \", length(saved), \" saved objects ...\"));","endif","info = property_info(o, p);","if (valid(info[1]) && info[1].wizard)","info = listset(info, player, 1);","else","info = listset(info, $hacker, 1);","endif","set_property_info(o, p, info);","endfor","endfor","\"----------------------------------------\";","player:notify(\"Removing all unsaved :recycle and :exitfunc verbs ...\");","for o in [#0..max_object()]","i = toint(o);","if (i && ((i % 1000) == 0))","player:notify(tostr(\"... \", o));","endif","$command_utils:suspend_if_needed(0);","if (valid(o) && (!(o in saved)))","for v in ({\"recycle\", \"exitfunc\"})","while ($object_utils:defines_verb(o, v))","delete_verb(o, v);","endwhile","endfor","endif","endfor","\"----------------------------------------\";","player:notify(\"Recycling unsaved objects ...\");","add_property(this, \"mcd_pos\", toint(max_object()), {player, \"r\"});","add_property(this, \"mcd_save\", {saved, saved_props}, {player, \"r\"});","suspend(0);","this:mcd_2(saved, saved_props);"]},{"name":"@shutdown","owner":2,"perms":89,"preposition":-2,"code":["if (!player.wizard)","player:notify(\"Sorry.\");","return;","elseif ($code_utils:task_valid($shutdown_task))","player:notify(\"Shutdown already in progress.\");","return;","endif","if (s = match(argstr, \"^in +%([0-9]+%) +\"))","bounds = s[3][1];","delay = toint(argstr[bounds[1]..bounds[2]]);","argstr = argstr[s[2] + 1..$];","else","delay = 2;","endif","if (!$command_utils:yes_or_no(tostr(\"Do you really want to shut down the server in \", delay, \" minutes?\")))","player:notify(\"Aborted.\");","return;","endif","announce_times = {};","if (delay > 0)","while (delay > 0)","announce_times = {@announce_times, delay * 60};","delay = delay / 2;","endwhile","announce_times = {@announce_times, 30, 10};","$shutdown_time = time() + announce_times[1];","endif","$shutdown_message = tostr(player.name, \" (\", player, \"): \", argstr);","$shutdown_task = task_id();","for i in [1..length(announce_times)]","msg = $generic_editor:fill_string(tostr(\"*** The server will be shut down by \", player.name, \" (\", player, \") in \", $time_utils:english_time(announce_times[i]), \": \", argstr, \" ***\"));","\"...use raw notify() since :notify() verb could be broken...\";","for p in (connected_players())","for line in (msg)","notify(p, line);","endfor","$command_utils:suspend_if_needed(0);","endfor","suspend(announce_times[i] - {@announce_times, 0}[i + 1]);","endfor","for p in (connected_players())","notify(p, tostr(\"*** Server shutdown by \", player.name, \" (\", player, \"): \", argstr, \" ***\"));","boot_player(p);","endfor","suspend(0);","$shutdown_task = E_NONE;","set_task_perms(player);","shutdown(argstr);"]},{"name":"@dump-d*atabase","owner":2,"perms":9,"preposition":-1,"code":["set_task_perms(player);","dump_database();","player:notify(\"Dumping...\");"]},{"name":"@who-calls","owner":2,"perms":89,"preposition":-2,"code":["set_task_perms(player);","if (argstr[1] != \":\")","argstr = \":\" + argstr;","endif","player:notify(tostr(\"Searching for verbs that appear to call \", argstr, \" ...\"));","player:notify(\"\");","$code_utils:find_verbs_containing(argstr + \"(\");"]},{"name":"mcd_2","owner":2,"perms":13,"preposition":-1,"code":["if (!caller_perms().wizard)","return;","elseif (!(\"mcd_pos\" in properties(this)))","return;","endif","end = this.mcd_pos;","saved = args[1];","saved_props = args[2];","player:notify(tostr(\"*** Recycling from #\", end, \" ...\"));","suspend(0);","fork (0)","this:mcd_2(saved, saved_props);","endfork","for i in [0..end]","this.mcd_pos = end - i;","o = toobj(end - i);","if ($command_utils:running_out_of_time())","return;","endif","if (valid(o) && (!(o in saved)))","for x in (o.contents)","move(x, #-1);","endfor","if (is_player(o))","o.features = {};","set_player_flag(o, 0);","endif","recycle(o);","endif","endfor","delete_property(this, \"mcd_pos\");","\"----------------------------------------\";","suspend(0);","player:notify(\"Killing queued tasks ...\");","for t in (queued_tasks())","kill_task(t[1]);","endfor","\"----------------------------------------\";","player:notify(\"Compacting object numbers ...\");","alist = {};","for p in (saved_props)","$command_utils:suspend_if_needed(0);","if (pair = $list_utils:assoc(#0.(p), alist))","#0.(p) = pair[2];","elseif (#0.(p) != player)","old = #0.(p);","#0.(p) = renumber(#0.(p));","alist = {@alist, {old, #0.(p)}};","endif","endfor","for o in (saved)","if (valid(o) && (o != player))","renumber(o);","endif","endfor","reset_max_object();","\"----------------------------------------\";","player:notify(\"Performing miscellaneous cleanups ...\");","for o in [#0..max_object()]","$command_utils:suspend_if_needed(0);","try","if (o == player)","move(o, $player_start);","elseif ($object_utils:isa(o, $mail_recipient))","move(o, $mail_agent);","else","move(o, #-1);","endif","except e (ANY)","player:notify(tostr(\"Couldn't move \", o, \" => \", e[2]));","player:notify(toliteral(e[4]));","endtry","if ($object_utils:has_callable_verb(o, \"init_for_core\"))","try","o:init_for_core();","except e (ANY)","player:notify(tostr(\"Error from \", o, \":init_for_core => \", e[2]));","player:notify(toliteral(e[4]));","endtry","endif","endfor","player:notify(\"Re-measuring everything ...\");","for o in [#0..max_object()]","$command_utils:suspend_if_needed(0);","if (o != $spell)","$byte_quota_utils:object_bytes(o);","endif","endfor","$wiz_utils:initialize_owned();","$byte_quota_utils:summarize_one_user(player);","delete_property(this, \"mcd_save\");","player:notify(\"Core database extraction is complete.  Type @shutdown to save it.\");"]},{"name":"@toad @toad! @toad!!","owner":2,"perms":89,"preposition":-2,"code":["\"@toad[!][!] <player> [blacklist|redlist|graylist] [commentary]\";","whostr = args[1];","comment = $string_utils:first_word(argstr)[2];","if (verb == \"@toad!!\")","listname = \"redlist\";","elseif (verb == \"@toad!\")","listname = \"blacklist\";","elseif ((ln = {@args, \"\"}[2]) && (index(listname = $login:listname(ln), ln) == 1))","\"...first word of coment is one of the magic words...\";","comment = $string_utils:first_word(comment)[2];","else","listname = \"\";","endif","if ((!player.wizard) || (player != this))","player:notify(\"Yeah, right... you wish.\");","return;","elseif ($command_utils:player_match_failed(who = $string_utils:match_player(whostr), whostr))","return;","elseif (((whostr != who.name) && (!(whostr in who.aliases))) && (whostr != tostr(who)))","player:notify(tostr(\"Must be a full name or an object number:  \", who.name, \"(\", who, \")\"));","return;","elseif (who == player)","player:notify(\"If you want to toad yourself, you have to do it by hand.\");","return;","endif","dobj = who;","if (msg = player:toad_victim_msg())","notify(who, msg);","endif","if ($wiz_utils:rename_all_instances(who, \"disfunc\", \"toad_disfunc\"))","player:notify(tostr(who, \":disfunc renamed.\"));","endif","if ($wiz_utils:rename_all_instances(who, \"recycle\", \"toad_recycle\"))","player:notify(tostr(who, \":recycle renamed.\"));","endif","\"MOO-specific cleanup while still a player object.\";","this:toad_cleanup(who);","e = $wiz_utils:unset_player(who, $hacker);","player:notify(e ? tostr(who.name, \"(\", who, \") is now a toad.\") | tostr(e));","if (e && ($object_utils:isa(who.location, $room) && (msg = player:toad_msg())))","who.location:announce_all_but({who}, msg);","endif","if (listname && (!$login:(listname + \"ed\")(cname = $string_utils:connection_hostname(who.last_connect_place))))","$login:(listname + \"_add\")(cname);","player:notify(tostr(\"Site \", cname, \" \", listname, \"ed.\"));","else","cname = \"\";","endif","if (!comment)","player:notify(\"So why is this person being toaded?\");","comment = $command_utils:read();","endif","$mail_agent:send_message(player, $toad_log, tostr(\"@toad \", who.name, \" (\", who, \")\"), {$string_utils:from_list(who.all_connect_places, \" \"), @cname ? {$string_utils:capitalize(listname + \"ed:  \") + cname} | {}, @comment ? {comment} | {}});","player:notify(tostr(\"Mail sent to \", $mail_agent:name($toad_log), \".\"));"]},{"name":"@untoad @detoad","owner":2,"perms":89,"preposition":-2,"code":["\"@untoad <object> [as namespec]\";","\"Turns object into a player.  Anything that isn't a guest is chowned to itself.\";","if (!player.wizard)","player:notify(\"Yeah, right... you wish.\");","elseif (prepstr && (prepstr != \"as\"))","player:notify(tostr(\"Usage:  \", verb, \" <object> [as name,alias,alias...]\"));","elseif ($command_utils:object_match_failed(dobj, dobjstr))","elseif (prepstr && (!(e = $building_utils:set_names(dobj, iobjstr))))","player:notify(tostr(\"Initial rename failed:  \", e));","elseif (e = $wiz_utils:set_player(dobj, g = $object_utils:isa(dobj, $guest)))","player:notify(tostr(dobj.name, \"(\", dobj, \") is now a \", g ? \"usable guest.\" | \"player.\"));","elseif (e == E_INVARG)","player:notify(tostr(dobj.name, \"(\", dobj, \") is not of an appropriate player class.\"));","player:notify(\"@chparent it to $player or some descendant.\");","elseif (e == E_NONE)","player:notify(tostr(dobj.name, \"(\", dobj, \") is already a player.\"));","elseif (e == E_NACC)","player:notify(\"Wait until $player_db is finished updating...\");","elseif (e == E_RECMOVE)","player:notify(tostr(\"The name `\", dobj.name, \"' is currently unavailable.\"));","player:notify(tostr(\"Try again with   \", verb, \" \", dobj, \" as <newname>\"));","else","player:notify(tostr(e));","endif"]},{"name":"@quota","owner":2,"perms":89,"preposition":12,"code":["\"@quota <player> is [public] <number> [<reason>]\";","\"  changes a player's quota.  sends mail to the wizards.\";","if (player != this)","return player:notify(\"Permission denied.\");","endif","set_task_perms(player);","dobj = $string_utils:match_player(dobjstr);","if ($command_utils:player_match_result(dobj, dobjstr)[1])","return;","elseif (!valid(dobj))","player:notify(\"Set whose quota?\");","return;","endif","if (iobjstr[1..min(7, $)] == \"public \")","iobjstr[1..7] = \"\";","if ($object_utils:has_property($local, \"public_quota_log\"))","recipients = {$quota_log, $local.public_quota_log};","else","player:tell(\"No public quota log.\");","return E_INVARG;","endif","else","recipients = {$quota_log};","endif","old = $quota_utils:get_quota(dobj);","qstr = iobjstr[1..(n = index(iobjstr + \" \", \" \")) - 1];","new = $code_utils:toint((qstr[1] == \"+\") ? qstr[2..$] | qstr);","reason = iobjstr[n + 1..$] || \"(none)\";","if (typeof(new) != INT)","player:notify(tostr(\"Set \", dobj.name, \"'s quota to what?\"));","return;","elseif (qstr[1] == \"+\")","new = old + new;","endif","result = $quota_utils:set_quota(dobj, new);","if (typeof(result) == ERR)","player:notify(tostr(result));","else","player:notify(tostr(dobj.name, \"'s quota set to \", new, \".\"));","endif","$mail_agent:send_message(player, recipients, tostr(\"@quota \", dobj.name, \" (\", dobj, \") \", new, \" (from \", old, \")\"), tostr(\"Reason for quota \", ((new - old) < 0) ? \"decrease: \" | \"increase: \", reason, index(\"?.!\", reason[$]) ? \"\" | \".\"));"]},{"name":"@players","owner":2,"perms":89,"preposition":-2,"code":["set_task_perms(player);","\"The time below is Oct. 1, 1990, roughly the birthdate of the LambdaMOO server.\";","start = 654768000;","now = time();","day = (24 * 60) * 60;","week = 7 * day;","month = 30 * day;","days_objects = days_players = {0, 0, 0, 0, 0, 0, 0};","weeks_objects = weeks_players = {0, 0, 0, 0};","months_objects = months_players = {};","nonplayer_objects = invalid_objects = 0;","always_objects = always_players = 0;","never_objects = never_players = 0;","numo = 0;","if (argstr)","if (((!dobjstr) && (prepstr == \"with\")) && (index(\"objects\", iobjstr) == 1))","with_objects = 1;","else","player:notify(tostr(\"Usage:  \", verb, \" [with objects]\"));","return;","endif","else","with_objects = 0;","players = players();","endif","for i in [1..with_objects ? toint(max_object()) + 1 | length(players)]","if (with_objects)","o = toobj(i - 1);","else","o = players[i];","endif","if ($command_utils:running_out_of_time())","player:notify(tostr(\"... \", o));","suspend(0);","endif","if (valid(o))","numo = numo + 1;","p = is_player(o) ? o | o.owner;","if (!valid(p))","invalid_objects = invalid_objects + 1;","elseif (!$object_utils:isa(p, $player))","nonplayer_objects = nonplayer_objects + 1;","else","seconds = now - p.last_connect_time;","days = seconds / day;","weeks = seconds / week;","months = seconds / month;","if (seconds < 0)","if (is_player(o))","always_players = always_players + 1;","else","always_objects = always_objects + 1;","endif","elseif (seconds > (now - start))","if (is_player(o))","never_players = never_players + 1;","else","never_objects = never_objects + 1;","endif","elseif (months > 0)","while (months > length(months_players))","months_players = {@months_players, 0};","months_objects = {@months_objects, 0};","endwhile","if (is_player(o))","months_players[months] = months_players[months] + 1;","endif","months_objects[months] = months_objects[months] + 1;","elseif (weeks > 0)","if (is_player(o))","weeks_players[weeks] = weeks_players[weeks] + 1;","endif","weeks_objects[weeks] = weeks_objects[weeks] + 1;","else","if (is_player(o))","days_players[days + 1] = days_players[days + 1] + 1;","endif","days_objects[days + 1] = days_objects[days + 1] + 1;","endif","endif","endif","endfor","player:notify(\"\");","player:notify(tostr(\"Last connected\"));","player:notify(tostr(\"at least this     Num.     Cumul.   Cumul. %\", with_objects ? \"     Num.     Cumul.   Cumul. %\" | \"\"));","player:notify(tostr(\"long ago        players   players   players \", with_objects ? \"   objects   objects   objects\" | \"\"));","player:notify(tostr(\"---------------------------------------------\", with_objects ? \"--------------------------------\" | \"\"));","su = $string_utils;","col1 = 14;","col2 = 7;","col3 = 10;","col4 = 9;","col5 = 11;","col6 = 11;","col7 = 10;","nump = length(players());","totalp = totalo = 0;","for x in ({{days_players, days_objects, \"day\", 1}, {weeks_players, weeks_objects, \"week\", 0}, {months_players, months_objects, \"month\", 0}})","pcounts = x[1];","ocounts = x[2];","unit = x[3];","offset = x[4];","for i in [1..length(pcounts)]","$command_utils:suspend_if_needed(0);","j = i - offset;","player:notify(tostr(su:left(tostr(j, \" \", unit, (j == 1) ? \":\" | \"s:\"), col1), su:right(pcounts[i], col2), su:right(totalp = totalp + pcounts[i], col3), su:right((totalp * 100) / nump, col4), \"%\", with_objects ? tostr(su:right(ocounts[i], col5), su:right(totalo = totalo + ocounts[i], col6), su:right((totalo * 100) / numo, col7), \"%\") | \"\"));","endfor","player:notify(\"\");","endfor","player:notify(tostr(su:left(\"Never:\", col1), su:right(never_players, col2), su:right(totalp = totalp + never_players, col3), su:right((totalp * 100) / nump, col4), \"%\", with_objects ? tostr(su:right(never_objects, col5), su:right(totalo = totalo + never_objects, col6), su:right((totalo * 100) / numo, col7), \"%\") | \"\"));","player:notify(tostr(su:left(\"Always:\", col1), su:right(always_players, col2), su:right(totalp = totalp + always_players, col3), su:right((totalp * 100) / nump, col4), \"%\", with_objects ? tostr(su:right(always_objects, col5), su:right(totalo = totalo + always_objects, col6), su:right((totalo * 100) / numo, col7), \"%\") | \"\"));","with_objects && player:notify(tostr(su:left(\"Non-player owner:\", (((col1 + col2) + col3) + col4) + 1), su:right(nonplayer_objects, col5), su:right(totalo = totalo + nonplayer_objects, col6), su:right((totalo * 100) / numo, col7), \"%\"));","with_objects && player:notify(tostr(su:left(\"Invalid owner:\", (((col1 + col2) + col3) + col4) + 1), su:right(invalid_objects, col5), su:right(totalo = totalo + invalid_objects, col6), su:right((totalo * 100) / numo, col7), \"%\"));","player:notify(\"\");"]},{"name":"kill_aux_wizard_parse","owner":2,"perms":173,"preposition":-1,"code":["\"Auxiliary verb for parsing @kill soon [#-of-seconds] [player | everyone]\";","\"Args[1] is either # of seconds or player/everyone.\";","\"Args[2], if it exists, is player/everyone, and forces args[1] to have been # of seconds.\";","\"Return value: {# of seconds [default 60] , 1 for all, object for player.}\";","set_task_perms(caller_perms());","nargs = length(args);","soon = toint(args[1]);","if (nargs > 1)","everyone = args[2];","elseif (soon <= 0)","everyone = args[1];","else","everyone = 0;","endif","if (everyone == \"everyone\")","everyone = 1;","elseif (typeof(everyone) == STR)","result = $string_utils:match_player(everyone);","if ($command_utils:player_match_failed(result, everyone))","player:notify(tostr(\"Usage:  \", callers()[1][2], \" soon [number of seconds] [\\\"everyone\\\" | player name]\"));","return {-1, -1};","else","return {soon ? soon | 60, result};","endif","endif","return {soon ? soon | 60, everyone ? everyone | player};"]},{"name":"@grepcore @egrepcore","owner":2,"perms":89,"preposition":-2,"code":["set_task_perms(player);","if (!args)","player:notify(tostr(\"Usage:  \", verb, \" <pattern>\"));","return;","endif","pattern = argstr;","regexp = verb == \"@egrepcore\";","player:notify(tostr(\"Searching for core verbs \", regexp ? \"matching the regular expression \" | \"containing the string \", toliteral(pattern), \" ...\"));","player:notify(\"\");","$code_utils:(regexp ? \"find_verbs_matching\" | \"find_verbs_containing\")(pattern, $core_objects());"]},{"name":"@net-who @@who","owner":2,"perms":89,"preposition":-2,"code":["\"@net-who prints all connected users and hosts.\";","\"@net-who player player player prints specified users and current or most recent connected host.\";","\"@net-who from hoststring prints all players who have connected from that host or host substring.  Substring can include *'s, e.g. @net-who from *.foo.edu.\";","set_task_perms(player);","su = $string_utils;","if ((prepstr == \"from\") && dobjstr)","player:notify(tostr(\"Usage:  \", verb, \" from <host string>\"));","elseif (((prepstr != \"from\") || dobjstr) || (!iobjstr))","\"Not parsing 'from' here...  Instead printing connected/recent users.\";","if (!(pstrs = args))","unsorted = connected_players();","else","unsorted = listdelete($command_utils:player_match_result(su:match_player(pstrs), pstrs), 1);","endif","if (!unsorted)","return;","endif","$wiz_utils:show_netwho_listing(player, unsorted);","else","$wiz_utils:show_netwho_from_listing(player, iobjstr);","endif"]},{"name":"@make-player","owner":2,"perms":89,"preposition":-2,"code":["\"Creates a player.\";","\"Syntax:  @make-player name email-address comments....\";","\"Generates a random password for the player.\";","if ((!player.wizard) || callers())","return E_PERM;","elseif (!args)","player:tell(\"Syntax:  @make-player name email-address comments....\");","return;","elseif (args[2] == \"for\")","\"common mistake: @make-player <name> for <email-address> ...\";","args = listdelete(args, 2);","endif","return $wiz_utils:do_make_player(@args);"]},{"name":"@abort-sh*utdown","owner":2,"perms":89,"preposition":-2,"code":["if (!player.wizard)","player:notify(\"Sorry.\");","elseif (!$code_utils:task_valid($shutdown_task))","player:notify(\"No server shutdown in progress.\");","$shutdown_task = E_NONE;","else","\"... Reset time so that $login:check_for_shutdown shuts up...\";","kill_task($shutdown_task);","$shutdown_task = E_NONE;","$shutdown_time = time() - 1;","for p in (connected_players())","notify(p, tostr(\"*** Server shutdown ABORTED by \", player.name, \" (\", player, \")\", argstr && (\":  \" + argstr), \" ***\"));","endfor","endif"]},{"name":"toad_msg toad_victim_msg programmer_msg programmer_victim_msg newt_msg newt_victim_msg","owner":2,"perms":173,"preposition":-1,"code":["\"This is the canonical doing-something-to-somebody message.\";","\"The corresponding property can either be\";","\"   string             msg for all occasions\";","\"   list of 2 strings  {we-are-there-msg,we-are-elsewhere-msg}\";","m = this.(verb);","if (typeof(m) != LIST)","return $string_utils:pronoun_sub(m);","elseif ((this.location == dobj.location) || (length(m) < 2))","return $string_utils:pronoun_sub(m[1]);","else","return $string_utils:pronoun_sub(m[2]);","endif"]},{"name":"moveto","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms((caller in {this, $generic_editor, $verb_editor, $mail_editor, $note_editor}) ? this.owner | caller_perms());","return `move(this, args[1]) ! ANY';"]},{"name":"@newt","owner":2,"perms":89,"preposition":-2,"code":["\"@newt <player> [commentary]\";","\"turns a player into a newt.  It can get better...\";","\"adds player to $login.newted, they will not be allowed to log in.\";","\"Sends mail to $newt_log giving .all_connect_places and commentary.\";","whostr = args[1];","comment = $string_utils:first_word(argstr)[2];","if (!player.wizard)","player:notify(\"Yeah, right.\");","elseif ($command_utils:player_match_failed(who = $string_utils:match_player(whostr), whostr))","return;","elseif (((whostr != who.name) && (!(whostr in who.aliases))) && (whostr != tostr(who)))","player:notify(tostr(\"Must be a full name or an object number:  \", who.name, \"(\", who, \")\"));","return;","elseif (who == player)","player:notify(\"If you want to newt yourself, you have to do it by hand.\");","return;","elseif (who in $login.newted)","player:notify(tostr(who.name, \" appears to already be a newt.\"));","return;","else","$wiz_utils:newt_player(who, comment);","endif"]},{"name":"@unnewt @denewt @get-better","owner":2,"perms":89,"preposition":-2,"code":["\"@denewt <player> [commentary]\";","\"Remove the player from $Login.newted\";","\"Sends mail to $newt_log with commentary.\";","whostr = args[1];","comment = $string_utils:first_word(argstr)[2];","if (!player.wizard)","player:notify(\"Yeah, right.\");","elseif ($command_utils:player_match_failed(who = $string_utils:match_player(whostr), whostr))","return;","else","\"Should parse email address and register user in some clever way.  Ick.\";","if (!(who in $login.newted))","player:notify(tostr(who.name, \" does not appear to be a newt.\"));","else","$login.newted = setremove($login.newted, who);","if (entry = $list_utils:assoc(who, $login.temporary_newts))","$login.temporary_newts = setremove($login.temporary_newts, entry);","endif","player:notify(tostr(who.name, \" (\", who, \") got better.\"));","$mail_agent:send_message(player, $newt_log, tostr(\"@denewt \", who.name, \" (\", who, \")\"), comment ? {comment} | {});","endif","endif"]},{"name":"@register","owner":2,"perms":89,"preposition":-2,"code":["\"Registers a player.\";","\"Syntax:  @register name email-address [additional commentary]\";","\"Email-address is stored in $registration_db and on the player object.\";","if (!player.wizard)","return player:tell(E_PERM);","endif","$wiz_utils:do_register(@args);"]},{"name":"@new-password @newpassword","owner":2,"perms":89,"preposition":12,"code":["\"@newpassword player is [string]\";","\"Set's a player's password; omit string to have one randomly generated.\";","\"Offer to email the password.\";","if (!player.wizard)","return E_PERM;","elseif ($command_utils:player_match_failed(dobj = $string_utils:match_player(dobjstr), dobjstr))","return;","elseif (!(dobjstr in {@dobj.aliases, tostr(dobj)}))","player:notify(tostr(\"Must be a full name or an object number: \", dobj.name, \" (\", dobj, \")\"));","else","$wiz_utils:do_new_password(dobj, iobjstr);","endif"]},{"name":"@log","owner":2,"perms":89,"preposition":-2,"code":["\"@log [<string>]    enters a comment in the server log.\";","\"If no string is given, you are prompted to enter one or more lines for an extended comment.\";","set_task_perms(player);","whostr = tostr(\"from \", player.name, \" (\", player, \")\");","if ((!player.wizard) || (player != caller))","player:notify(\"Yeah, right.\");","elseif (argstr)","server_log(tostr(\"COMMENT: [\", whostr, \"]  \", argstr));","player:notify(\"One-line comment logged.\");","elseif (lines = $command_utils:read_lines())","server_log(tostr(\"COMMENT: [\", whostr, \"]\"));","for l in (lines)","server_log(l);","endfor","server_log(tostr(\"END_COMMENT.\"));","player:notify(tostr(length(lines), \" lines logged as extended comment.\"));","endif"]},{"name":"@guests","owner":2,"perms":25,"preposition":-1,"code":["set_task_perms(player);","n = (dobjstr == \"all\") ? 0 | $code_utils:toint(dobjstr || \"20\");","if (caller != this)","player:notify(\"You lose.\");","elseif ((n == E_TYPE) && (index(\"now\", dobjstr) != 1))","player:notify(tostr(\"Usage:  \", verb, \" <number>  (where <number> indicates how many entries to look at in the guest log)\"));","player:notify(tostr(\"Usage:  \", verb, \" now (to see information about currently connected guests only)\"));","elseif ((!dobjstr) || (index(\"now\", dobjstr) != 1))","$guest_log:last(n);","else","\"*way* too much copied code in here from @who...  Sorry.  --yduJ\";","su = $string_utils;","conn = connected_players();","unsorted = {};","for g in ($object_utils:leaves($guest))","if (g in conn)","unsorted = {@unsorted, g};","endif","endfor","if (!unsorted)","player:tell(\"No guests found.\");","return;","endif","footnotes = {};","alist = {};","nwidth = length(\"Player name\");","for u in (unsorted)","pref = u.programmer ? \"% \" | \"  \";","u.programmer && (footnotes = setadd(footnotes, \"prog\"));","u3 = {tostr(pref, u.name, \" (\", u, \")\"), su:from_seconds(connected_seconds(u)), su:from_seconds(idle_seconds(u)), where = $string_utils:connection_hostname(connection_name(u))};","nwidth = max(length(u3[1]), nwidth);","if ($login:blacklisted(where))","where = \"(*) \" + where;","footnotes = setadd(footnotes, \"black\");","elseif ($login:graylisted(where))","where = \"(+) \" + where;","footnotes = setadd(footnotes, \"gray\");","endif","alist = {@alist, u3};","$command_utils:suspend_if_needed(0);","endfor","alist = $list_utils:sort_alist_suspended(0, alist, 3);","$command_utils:suspend_if_needed(0);","headers = {\"Player name\", \"Connected\", \"Idle Time\", \"From Where\"};","time_width = length(\"59 minutes\") + 2;","before = {0, w1 = nwidth + 3, w2 = w1 + time_width, w3 = w2 + time_width};","tell1 = \"  \" + headers[1];","tell2 = \"  \" + su:space(headers[1], \"-\");","for j in [2..4]","tell1 = su:left(tell1, before[j]) + headers[j];","tell2 = su:left(tell2, before[j]) + su:space(headers[j], \"-\");","endfor","player:notify(tell1);","player:notify(tell2);","active = 0;","for a in (alist)","$command_utils:suspend_if_needed(0);","tell1 = a[1];","for j in [2..4]","tell1 = su:left(tell1, before[j]) + tostr(a[j]);","endfor","player:notify(tell1[1..min($, 79)]);","endfor","if (footnotes)","player:notify(\"\");","if (\"prog\" in footnotes)","player:notify(\" %  == programmer.\");","endif","if (\"black\" in footnotes)","player:notify(\"(*) == blacklisted site.\");","endif","if (\"gray\" in footnotes)","player:notify(\"(+) == graylisted site.\");","endif","endif","player:tell(\"@guests display complete.\");","endif"]},{"name":"@rn mail_catch_up check_mail_lists current_message set_current_message get_current_message make_current_message kill_current_message @nn","owner":2,"perms":13,"preposition":-1,"code":["if (caller != this)","set_task_perms(valid(caller_perms()) ? caller_perms() | player);","endif","use = this.mail_identity;","if (valid(use) && (use != this))","return use:(verb)(@args);","else","return pass(@args);","endif"]},{"name":"@blacklist @graylist @redlist @unblacklist @ungraylist @unredlist @spooflist @unspooflist","owner":2,"perms":89,"preposition":-2,"code":["\"@[un]blacklist [<site or subnet>  [for <duration>] [commentary]]\";","\"@[un]graylist  [<site or subnet>  [for <duration>] [commentary]]\";","\"@[un]redlist   [<site or subnet>  [for <duration>] [commentary]]\";","\"@[un]spooflist [<site of subnet>  [for <duration>] [commentary]]\";","\"The `for <duration>' is for temporary colorlisting a site only. The duration should be in english time units:  for 1 hour, for 1 day 2 hours 15 minutes, etc. The commentary should be after all durations. Note, if you are -not- using a duration, do not start your commentary with the word `for'.\";","set_task_perms(player);","if ((player != this) || (!player.wizard))","player:notify(\"Ummm.  no.\");","return;","endif","undo = verb[2..3] == \"un\";","which = $login:listname(verb[undo ? 4 | 2]);","downgrade = {\"\", \"graylist\", \"blacklist\"}[1 + index(\"br\", which[1])];","if (!(fw = $string_utils:first_word(argstr)))","\"... Just print the list...\";","this:display_list(which);","return;","endif","target = fw[1];","if (fw[2] && (parse = this:parse_templist_duration(fw[2]))[1])","if ((typeof(parse[3]) == ERR) || (!parse[3]))","player:notify(tostr(\"Could not parse the duration for @\", which, \"ing site \\\"\", target, \"\\\"\"));","return;","endif","start = parse[2];","duration = parse[3];","comment = parse[4] ? {parse[4]} | {};","comment = {tostr(\"for \", $time_utils:english_time(duration)), @comment};","elseif (fw[2])","comment = fw[2];","else","\"Get the right vars set up as though parse had been called\";","parse = {0, \"\"};","comment = {};","endif","if (is_literal = $site_db:domain_literal(target))","if (target[$] == \".\")","target = target[1..$ - 1];","endif","fullname = \"subnet \" + target;","else","if (target[1] == \".\")","target[1..1] = \"\";","endif","fullname = (\"domain `\" + target) + \"'\";","endif","entrylist = $login.(which)[1 + (!is_literal)];","if ((!undo) && (target in entrylist))","player:notify(tostr(fullname, \" is already \", which, \"ed.\"));","return;","endif","entrylist = setremove(entrylist, target);","if (!(result = this:check_site_entries(undo, which, target, is_literal, entrylist))[1])","return;","endif","rm = result[2];","namelist = $string_utils:english_list(rm);","downgraded = {};","if (rm)","ntries = (length(rm) == 1) ? \"ntry\" | \"ntries\";","if ($command_utils:yes_or_no(tostr(\"Remove e\", ntries, \" for \", namelist, \"?\")))","dg = undo && (downgrade && $command_utils:yes_or_no(downgrade + \" them?\"));","for s in (rm)","$login:(which + \"_remove\")(s);","dg && ($login:(downgrade + \"_add\")(s) && (downgraded = {@downgraded, s}));","endfor","player:notify(tostr(\"E\", ntries, \" removed\", @dg ? {\" and \", downgrade, \"ed.\"} | {\".\"}));","else","player:notify(tostr(namelist, \" will continue to be \", which, \"ed.\"));","rm = {};","endif","endif","if (downgraded)","comment[1..0] = {tostr(downgrade, \"ed \", $string_utils:english_list(downgraded), \".\")};","endif","tempentrylist = $login.(\"temporary_\" + which)[1 + (!is_literal)];","if ((!undo) && (target in $list_utils:slice(tempentrylist)))","player:notify(tostr(fullname, \" is already temporarily \", which, \"ed.\"));","return;","endif","if (en = $list_utils:assoc(target, tempentrylist))","tempentrylist = setremove(tempentrylist, en);","endif","if (!(result = this:check_site_entries(undo, which, target, is_literal, $list_utils:slice(tempentrylist)))[1])","return;","endif","rmtemp = result[2];","tempnamelist = $string_utils:english_list(rmtemp);","tempdowngraded = {};","if (rmtemp)","ntries = (length(rmtemp) == 1) ? \"ntry\" | \"ntries\";","if ($command_utils:yes_or_no(tostr(\"Remove e\", ntries, \" for \", tempnamelist, \"?\")))","dg = undo && (downgrade && $command_utils:yes_or_no(downgrade + \" them?\"));","for s in (rmtemp)","old = $list_utils:assoc(s, tempentrylist);","$login:(which + \"_remove_temp\")(s);","dg && ($login:(downgrade + \"_add_temp\")(s, old[2], old[3]) && (tempdowngraded = {@tempdowngraded, s}));","endfor","player:notify(tostr(\"E\", ntries, \" removed\", @dg ? {\" and \", downgrade, \"ed with durations transferred.\"} | {\".\"}));","else","player:notify(tostr(tempnamelist, \" will continue to be temporarily \", which, \"ed.\"));","rmtemp = {};","endif","endif","if (tempdowngraded)","comment[1..0] = {tostr(downgrade, \"ed \", $string_utils:english_list(tempdowngraded), \".\")};","endif","if (!undo)","if (parse[1])","$login:(which + \"_add_temp\")(target, start, duration);","player:notify(tostr(fullname, \" \", which, \"ed for \", $time_utils:english_time(duration)));","else","$login:(which + \"_add\")(target);","player:notify(tostr(fullname, \" \", which, \"ed.\"));","endif","if (rm)","comment[1..0] = {tostr(\"Subsumes \", which, \"ing for \", namelist, \".\")};","endif","if (rmtemp)","comment[1..0] = {tostr(\"Subsumes temporary \", which, \"ing for \", tempnamelist, \".\")};","endif","elseif ($login:(which + \"_remove\")(target))","player:notify(tostr(fullname, \" un\", which, \"ed.\"));","if (!downgrade)","elseif ($command_utils:yes_or_no(downgrade + \" it?\"))","$login:(downgrade + \"_add\")(target) && (downgraded = {target, @downgraded});","player:notify(tostr(fullname, \" \", downgrade, \"ed.\"));","else","player:notify(tostr(fullname, \" not \", downgrade, \"ed.\"));","endif","if (downgraded)","comment[1..0] = {tostr(downgrade, \"ed \", $string_utils:english_list(downgraded), \".\")};","endif","if (rm)","comment[1..0] = {tostr(\"Also removed \", namelist, \".\")};","endif","elseif ((old = $list_utils:assoc(target, $login.(\"temporary_\" + which)[1 + (!is_literal)])) && $login:(which + \"_remove_temp\")(target))","player:notify(tostr(fullname, \" un\", which, \"ed.\"));","if (!downgrade)","elseif ($command_utils:yes_or_no(downgrade + \" it?\"))","$login:(downgrade + \"_add_temp\")(target, old[2], old[3]) && (tempdowngraded = {target, @tempdowngraded});","player:notify(tostr(fullname, \" \", downgrade, \"ed, currently for \", $time_utils:english_time(old[3]), \" from \", $time_utils:time_sub(\"$1/$3\", old[2])));","else","player:notify(tostr(fullname, \" not \", downgrade, \"ed.\"));","endif","if (tempdowngraded)","comment[1..0] = {tostr(downgrade, \"ed \", $string_utils:english_list(tempdowngraded), \"with durations transferred.\")};","endif","if (rmtemp)","comment[1..0] = {tostr(\"Also removed \", tempnamelist, \".\")};","endif","elseif (rm || rmtemp)","player:notify(tostr(fullname, \" itself was never actually \", which, \"ed.\"));","comment[1..0] = {tostr(\"Removed \", namelist, \" from regular and \", tempnamelist, \" from temporary.\")};","else","player:notify(tostr(fullname, \" was not \", which, \"ed before.\"));","return;","endif","subject = tostr(undo ? \"@un\" | \"@\", which, \" \", fullname);","$mail_agent:send_message(player, $site_log, subject, comment);","\"...\";","\"... make sure we haven't screwed ourselves...\";","uhoh = {};","for site in (player.all_connect_places)","if (index(site, target) && $login:(which + \"ed\")(site))","uhoh = {@uhoh, site};","endif","endfor","if (uhoh)","player:notify(tostr(\"WARNING:  \", $string_utils:english_list(uhoh), \" are now \", which, \"ed!\"));","endif"]},{"name":"@corify","owner":2,"perms":89,"preposition":13,"code":["\"Usage:  @corify <object> as <propname>\";","\"Adds <object> to the core, as $<propname>\";","\"Reminds the wizard to write an :init_for_core verb, if there isn't one already.\";","if (!player.wizard)","player:tell(\"Sorry, the core is wizardly territory.\");","return;","endif","if (dobj == $failed_match)","dobj = player:my_match_object(dobjstr);","endif","if ($command_utils:object_match_failed(dobj, dobjstr))","return;","endif","if (!iobjstr)","player:tell(\"Usage:  @corify <object> as <propname>\");","return;","elseif (iobjstr[1] == \"$\")","iobjstr = iobjstr[2..$];","endif","try","add_property(#0, iobjstr, dobj, {player, \"r\"});","except e (ANY)","return player:tell(e[1], \":\", e[2]);","endtry","if (!(\"init_for_core\" in verbs(dobj)))","player:tell(dobj:titlec(), \" has no :init_for_core verb.  Strongly consider adding one before doing anything else.\");","else","player:tell(\"Corified \", $string_utils:nn(dobj), \" as $\", iobjstr, \".\");","endif"]},{"name":"@make-guest","owner":2,"perms":25,"preposition":-1,"code":["\"Usage:  @make-guest <guestname>\";","\"Creates a player called <guestname>_Guest owned by $hacker and a child of $guest. Or, if $local.guest exists, make a child of that, assuming that all other guests are children of it too.\";","if (!player.wizard)","player:tell(\"If you think this MOO needs more guests, you should contact a wizard.\");","return E_PERM;","endif","if (length(args) != 1)","player:tell(\"Usage: \", verb, \" <guest name>\");","return;","endif","guest_parent = (($object_utils:has_property($local, \"guest\") && valid($local.guest)) && $object_utils:isa($local.guest, $guest)) ? $local.guest | $guest;","i = length(children(guest_parent));","while (!$player_db:available(guestnum = tostr(\"Guest\", i = i + 1)))","endwhile","guestname = args[1] + \"_Guest\";","guestaliases = {guestname, adj = args[1], guestnum};","if (!player.wizard)","return;","elseif ($player_db.frozen)","player:tell(\"Sorry, the player db is frozen, so no players can be made right now.  Please try again in a few minutes.\");","return;","elseif (!$player_db:available(guestname))","player:tell(\"\\\"\", guestname, \"\\\" is not an available name.\");","return;","elseif (!$player_db:available(adj))","player:Tell(\"\\\"\", adj, \"\\\" is not an available name.\");","return;","else","new = $quota_utils:bi_create(guest_parent, $hacker);","new:set_name(guestname);","new:set_aliases(guestaliases);","if (!(e = $wiz_utils:set_player(new, 1)))","player:Tell(\"Unable to make \", new.name, \" (\", new, \") a player.\");","player:Tell(tostr(e));","else","player:Tell(\"Guest: \", new.name, \" (\", new, \") made.\");","new.default_description = {\"By definition, guests appear nondescript.\"};","new.description = new.default_description;","new.last_connect_time = $maxint;","new.last_disconnect_time = time();","new.password = 0;","new.size_quota = new.size_quota;","new:set_gender(new.default_gender);","move(new, $player_start);","player:tell(\"Now don't forget to @describe \", new, \" as something.\");","endif","endif"]},{"name":"@temp-newt","owner":2,"perms":89,"preposition":11,"code":["if (!player.wizard)","return player:tell(\"Permission denied.\");","elseif (!valid(who = $string_utils:match_player(dobjstr)))","return $command_utils:player_match_failed(who, dobjstr);","elseif (((dobjstr != who.name) && (!(dobjstr in who.aliases))) && (dobjstr != tostr(who)))","return player:tell(tostr(\"Must be a full name or an object number:  \", who.name, \"(\", who, \")\"));","elseif (who == player)","player:notify(\"If you want to newt yourself, you have to do it by hand.\");","return;","elseif (!(howlong = $time_utils:parse_english_time_interval(iobjstr)))","return player:tell(\"Can't parse time: \", howlong);","else","if (who in $login.newted)","player:notify(tostr(who.name, \" appears to already be a newt.\"));","else","$wiz_utils:newt_player(who, \"\", (\"For \" + iobjstr) + \".  \");","endif","if (index = $list_utils:iassoc(who, $login.temporary_newts))","$login.temporary_newts[index][2] = time();","$login.temporary_newts[index][3] = howlong;","else","$login.temporary_newts = {@$login.temporary_newts, {who, time(), howlong}};","endif","player:tell(who.name, \" (\", who, \") will be a newt until \", ctime(time() + howlong));","endif"]},{"name":"@deprog*rammer","owner":2,"perms":89,"preposition":-2,"code":["\"@deprogrammer victim [for <duration>] [reason]\";","\"\";","\"Removes the prog-bit from victim.  If a duration is specified (see help $time_utils:parse_english_time_interval), then the victim is put into the temporary list. He will be automatically removed the first time he asks for a progbit after the duration expires.  Either with or without the duration you can specify a reason, or you will be prompted for one. However, if you don't have a duration, don't start the reason with the word `For'.\";","set_task_perms(player);","if ((player != this) || (!player.wizard))","player:notify(\"No go.\");","return;","endif","if (!args)","player:notify(tostr(\"Usage:  \", verb, \" <playername> [for <duration>] [reason]\"));","endif","fw = $string_utils:first_word(argstr);","if (fw[2] && (parse = this:parse_templist_duration(fw[2]))[1])","if ((typeof(parse[3]) == ERR) || (!parse[3]))","player:notify(tostr(\"Could not parse the duration for restricting programming for \", fw[1], \".\"));","return;","endif","start = parse[2];","duration = parse[3];","reason = parse[4] ? {parse[4]} | {};","else","start = duration = 0;","reason = fw[2] ? {fw[2]} | {};","endif","if (!reason)","reason = {$command_utils:read(\"reason for resetting programmer flag\")};","endif","if (duration)","reason = {tostr(\"for \", $time_utils:english_time(duration)), @reason};","endif","if ($command_utils:player_match_failed(victim = $string_utils:match_player(fw[1]), fw[1]))","\"...done...\";","elseif (result = $wiz_utils:unset_programmer(victim, reason, @start ? {start, duration} | {}))","player:notify(tostr(victim.name, \" (\", victim, \") is no longer a programmer.\", duration ? tostr(\"  This restriction will be lifted in \", $string_utils:from_seconds(duration), \".\") | \"\"));","elseif (result == E_NONE)","player:notify(tostr(victim.name, \" (\", victim, \") was already a nonprogrammer...\"));","else","player:notify(tostr(result));","endif"]},{"name":"display_list","owner":2,"perms":173,"preposition":-1,"code":["if ((caller != this) && (!caller_perms().wizard))","return E_PERM;","endif","which = args[1];","slist = {};","if (s = $login.(which)[1])","slist = {@slist, \"--- Subnets ---\", @s};","endif","if (s = $login.(which)[2])","slist = {@slist, \"--- Domains ---\", @s};","endif","if (s = $login.(\"temporary_\" + which)[1])","slist = {@slist, \"--- Temporary Subnets ---\"};","for d in (s)","slist = {@slist, tostr(d[1], \" until \", $time_utils:time_sub(\"$1/$3 $H:$M\", d[2] + d[3]))};","$command_utils:suspend_if_needed(2);","endfor","endif","if (s = $login.(\"temporary_\" + which)[2])","slist = {@slist, \"--- Temporary Domains ---\"};","for d in (s)","slist = {@slist, tostr(d[1], \" until \", $time_utils:time_sub(\"$1/$3 $H:$M\", d[2] + d[3]))};","$command_utils:suspend_if_needed(2);","endfor","endif","if (slist)","player:notify_lines($string_utils:columnize(slist, 2));","else","player:notify(tostr(\"The \", which, \" is empty.\"));","endif"]},{"name":"parse_templist_duration","owner":36,"perms":173,"preposition":-1,"code":["\"parses out the time interval at the beginning of the args[1], assumes rest is commentary.\";","if ((fw = $string_utils:first_word(args[1]))[1] == \"for\")","words = $string_utils:words(fw[2]);","try_ = {};","ind = cont = 1;","while (cont)","word = words[ind];","cont = ind;","if (toint(word))","try_ = {@try_, word};","ind = ind + 1;","else","for set in ($time_utils.time_units)","if (word in set)","try_ = {@try_, word};","ind = ind + 1;","endif","endfor","endif","if ((cont == ind) || (ind > length(words)))","cont = 0;","endif","endwhile","dur = $time_utils:parse_english_time_interval(@try_);","rest = $string_utils:from_list(words[ind..$], \" \");","return {1, time(), dur, rest};","else","return {0, argstr};","endif"]},{"name":"check_site_entries","owner":2,"perms":173,"preposition":-1,"code":["\"Called by @[un]<color>list to check existence of the target site.\";","\"=> {done okay, LIST of sites to remove}\";","if (caller != this)","return E_PERM;","endif","{undo, which, target, is_literal, entrylist} = args;","rm = {};","confirm = 0;","if (is_literal)","for s in (entrylist)","if ((i = index(s, target + \".\")) == 1)","\"... target is a prefix of s, s should probably go...\";","rm = {@rm, s};","elseif (index(target + \".\", s + \".\") != 1)","\"... s is not a prefix of target...\";","elseif (undo)","player:notify(tostr(\"You will need to un\", which, \" subnet \", s, \" as well.\"));","elseif (confirm)","player:notify(tostr(\"...Subnet \", s, \" already \", which, \"ed...\"));","else","player:notify(tostr(\"Subnet \", s, \" already \", which, \"ed.\"));","if (!(confirm = $command_utils:yes_or_no(tostr(which, \" \", target, \" anyway?\"))))","return {0, {}};","endif","endif","endfor","else","for s in (entrylist)","if ((i = rindex(s, \".\" + target)) && (i == (length(s) - length(target))))","\"... target is a suffix of s, s should probably go...\";","rm = {@rm, s};","elseif ((!(i = rindex(\".\" + target, \".\" + s))) || (i < ((length(target) - length(s)) + 1)))","\"... s is not a suffix of target...\";","elseif (undo)","player:notify(tostr(\"You will need to un\", which, \" domain `\", s, \"' as well.\"));","elseif (confirm)","player:notify(tostr(\"...Domain `\", s, \"' already \", which, \"ed...\"));","else","player:notify(tostr(\"Domain `\", s, \"' already \", which, \"ed.\"));","if (!(confirm = $command_utils:yes_or_no(tostr(which, \" \", target, \" anyway?\"))))","return {0, {}};","endif","endif","endfor","endif","return {1, rm};"]},{"name":"@lock-login @unlock-login @lock-login!","owner":2,"perms":89,"preposition":-2,"code":["\"Syntax:  @lock-login <message>\";","\"         @lock-login! <message>\";","\"         @unlock-login\";","\"\";","\"The @lock-login calls prevent all non-wizard users from logging in, displaying <message> to them when they try.  (The second syntax, with @lock-login!, additionally boots any nonwizards who are already connected.)  @unlock-login turns this off.\";","if (caller != this)","raise(E_PERM);","elseif (verb[2] == \"u\")","$no_connect_message = 0;","player:notify(\"Login restrictions removed.\");","elseif (!argstr)","player:notify(\"You must provide some message to display to users who attempt to login:  @lock-login <message>\");","else","$no_connect_message = argstr;","player:notify(tostr(\"Logins are now blocked for non-wizard players.  Message displayed when attempted:  \", $no_connect_message));","if (verb == \"@lock-login!\")","wizards = $wiz_utils:all_wizards_unadvertised();","for x in (connected_players())","if (!(x in wizards))","boot_player(x);","endif","endfor","player:notify(\"All nonwizards have been booted.\");","endif","endif"]},{"name":"__fix","owner":2,"perms":173,"preposition":-1,"code":["\"...was on $player, now archived here for posterity...\";","\"Runs the old->new format conversion on every message in this.messages.\";","\" => 1 if successful\";","\" => 0 if anything toward happened during a suspension\";","\"      (e.g., new message received, someone deleted stuff) \";","\"      in which case this.messages is left as if this routine were never run.\";","if (!$perm_utils:controls(caller_perms(), this))","return E_PERM;","endif","msgs = {};","i = 1;","for m in (oldmsgs = this.messages)","msgs = {@msgs, {m[1], $mail_agent:__convert_new(@m[2])}};","if ($command_utils:running_out_of_time())","player:notify(tostr(\"...\", i, \" \", this));","suspend(0);","if (oldmsgs != this.messages)","return 0;","endif","endif","i = i + 1;","endfor","this.messages = msgs;","return 1;"]},{"name":"toad_cleanup","owner":2,"perms":173,"preposition":-1,"code":["if ((!player.wizard) || (caller != this))","raise(E_PERM);","endif","\"Noop. Placeholder verb for MOO-specific cleanups.\";"]},{"name":"@prop*erty","owner":2,"perms":89,"preposition":-2,"code":["set_task_perms(player);","if (!player.programmer)","player:notify(\"You need to be a programmer to do this.\");","player:notify(\"If you want to become a programmer, talk to a wizard.\");","return;","elseif (!$quota_utils:property_addition_permitted(player))","player:tell(\"Property addition not permitted because quota exceeded.\");","return;","endif","nargs = length(args);","usage = tostr(\"Usage:  \", verb, \" <object>.<prop-name> [<init_value> [<perms> [<owner>]]]\");","if ((nargs < 1) || (!(spec = $code_utils:parse_propref(args[1]))))","player:notify(usage);","return;","endif","object = player:my_match_object(spec[1]);","name = spec[2];","if ($command_utils:object_match_failed(object, spec[1]))","return;","endif","if (nargs < 2)","value = 0;","else","q = $string_utils:prefix_to_value(argstr[$string_utils:word_start(argstr)[2][1]..$]);","if (q[1] == 0)","player:notify(tostr(\"Syntax error in initial value:  \", q[2]));","return;","endif","value = q[2];","args = {args[1], value, @$string_utils:words(q[1])};","nargs = length(args);","endif","default = player:prog_option(\"@prop_flags\");","if (!default)","default = \"rc\";","endif","perms = (nargs < 3) ? default | $perm_utils:apply(default, args[3]);","if (nargs < 4)","owner = player;","else","owner = $string_utils:match_player(args[4]);","if ($command_utils:player_match_result(owner, args[4])[1])","return;","endif","endif","if (nargs > 4)","player:notify(usage);","return;","endif","try","add_property(object, name, value, {owner, perms});","player:notify(tostr(\"Property added with value \", toliteral(object.(name)), \".\"));","except (E_INVARG)","if ($object_utils:has_property(object, name))","player:notify(tostr(\"Property \", object, \".\", name, \" already exists.\"));","else","for i in [1..length(perms)]","if (!index(\"rcw\", perms[i]))","player:notify(tostr(\"Unknown permission bit:  \", perms[i]));","return;","endif","endfor","\"...the only other possibility...\";","player:notify(\"Property is already defined on one or more descendents.\");","player:notify(tostr(\"Try @check-prop \", args[1]));","endif","except e (ANY)","player:notify(e[2]);","endtry"]},{"name":"@chmod*#","owner":2,"perms":89,"preposition":-2,"code":["set_task_perms(player);","bynumber = verb == \"@chmod#\";","if (length(args) != 2)","player:notify(tostr(\"Usage:  \", verb, \" <object-or-property-or-verb> <permissions>\"));","return;","endif","{what, perms} = args;","if (spec = $code_utils:parse_verbref(what))","if (!player.programmer)","player:notify(\"You need to be a programmer to do this.\");","player:notify(\"If you want to become a programmer, talk to a wizard.\");","return;","endif","if (valid(object = player:my_match_object(spec[1])))","vname = spec[2];","if (bynumber)","vname = $code_utils:toint(vname);","if (vname == E_TYPE)","return player:notify(\"Verb number expected.\");","elseif ((vname < 1) || `vname > length(verbs(object)) ! E_PERM => 0')","return player:notify(\"Verb number out of range.\");","endif","endif","try","info = verb_info(object, vname);","if (!valid(owner = info[1]))","player:notify(tostr(\"That verb is owned by an invalid object (\", owner, \"); it needs to be @chowned.\"));","elseif (!is_player(owner))","player:notify(tostr(\"That verb is owned by a non-player object (\", owner.name, \", \", owner, \"); it needs to be @chowned.\"));","else","info[2] = perms = $perm_utils:apply(info[2], perms);","try","result = set_verb_info(object, vname, info);","player:notify(tostr(\"Verb permissions set to \\\"\", perms, \"\\\".\"));","except (E_INVARG)","player:notify(tostr(\"\\\"\", perms, \"\\\" is not a valid permissions string for a verb.\"));","except e (ANY)","player:notify(e[2]);","endtry","endif","except (E_VERBNF)","player:notify(\"That object does not define that verb.\");","except error (ANY)","player:notify(error[2]);","endtry","return;","endif","elseif (bynumber)","return player:notify(\"@chmod# can only be used for verbs.\");","elseif (index(what, \".\") && (spec = $code_utils:parse_propref(what)))","if (valid(object = player:my_match_object(spec[1])))","pname = spec[2];","try","info = property_info(object, pname);","info[2] = perms = $perm_utils:apply(info[2], perms);","try","result = set_property_info(object, pname, info);","player:notify(tostr(\"Property permissions set to \\\"\", perms, \"\\\".\"));","except (E_INVARG)","player:notify(tostr(\"\\\"\", perms, \"\\\" is not a valid permissions string for a property.\"));","except error (ANY)","player:notify(error[2]);","endtry","except (E_PROPNF)","player:notify(\"That object does not have that property.\");","except error (ANY)","player:notify(error[2]);","endtry","return;","endif","elseif (valid(object = player:my_match_object(what)))","perms = $perm_utils:apply(((object.r ? \"r\" | \"\") + (object.w ? \"w\" | \"\")) + (object.f ? \"f\" | \"\"), perms);","r = w = f = 0;","for i in [1..length(perms)]","if (perms[i] == \"r\")","r = 1;","elseif (perms[i] == \"w\")","w = 1;","elseif (perms[i] == \"f\")","f = 1;","else","player:notify(tostr(\"\\\"\", perms, \"\\\" is not a valid permissions string for an object.\"));","return;","endif","endfor","try","object.r = r;","object.w = w;","object.f = f;","player:notify(tostr(\"Object permissions set to \\\"\", perms, \"\\\".\"));","except (E_PERM)","player:notify(\"Permission denied.\");","endtry","return;","endif","$command_utils:object_match_failed(object, what);"]},{"name":"@args*#","owner":2,"perms":89,"preposition":-2,"code":["if (player != caller)","return;","endif","set_task_perms(player);","if (!player.programmer)","player:notify(\"You need to be a programmer to do this.\");","player:notify(\"If you want to become a programmer, talk to a wizard.\");","return;","endif","if (!(args && (spec = $code_utils:parse_verbref(args[1]))))","player:notify(tostr(args ? (\"\\\"\" + args[1]) + \"\\\"?  \" | \"\", \"<object>:<verb>  expected.\"));","elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))","\"...can't find object...\";","else","if (verb == \"@args#\")","name = $code_utils:toint(spec[2]);","if (name == E_TYPE)","return player:notify(\"Verb number expected.\");","elseif ((name < 1) || `name > length(verbs(object)) ! E_PERM => 0')","return player:notify(\"Verb number out of range.\");","endif","endif","try","info = verb_args(object, name = spec[2]);","if (typeof(pas = $code_utils:parse_argspec(@listdelete(args, 1))) != LIST)","\"...arg spec is bogus...\";","player:notify(tostr(pas));","elseif (!(newargs = pas[1]))","player:notify($string_utils:from_list(info, \" \"));","elseif (pas[2])","player:notify(tostr(\"\\\"\", pas[2][1], \"\\\" unexpected.\"));","else","info[2] = info[2][1..index(info[2] + \"/\", \"/\") - 1];","info = {@newargs, @info[length(newargs) + 1..$]};","try","result = set_verb_args(object, name, info);","player:notify(\"Verb arguments changed.\");","except (E_INVARG)","player:notify(tostr(\"\\\"\", info[2], \"\\\" is not a valid preposition (?)\"));","except error (ANY)","player:notify(error[2]);","endtry","endif","except (E_VERBNF)","player:notify(\"That object does not have a verb with that name.\");","except error (ANY)","player:notify(error[2]);","endtry","endif"]},{"name":"eval*-d","owner":2,"perms":89,"preposition":-2,"code":["\"A MOO-code evaluator.  Type `;CODE' or `eval CODE'.\";","\"Calls player:eval_cmd_string to first transform CODE in any way appropriate (e.g., prefixing .eval_env) and then do the actual evaluation.  See documentation for this:eval_cmd_string\";","\"If you set your .eval_time property to 1, you find out how many ticks and seconds you used.\";","\"If eval-d is used, the evaluation is performed as if the debug flag were unset.\";","if (player != this)","player:tell(\"I don't understand that.\");","return;","elseif (!player.programmer)","player:tell(\"You need to be a programmer to eval code.\");","return;","endif","set_task_perms(player);","result = player:eval_cmd_string(argstr, verb != \"eval-d\");","if (result[1])","player:notify(this:eval_value_to_string(result[2]));","if (player:prog_option(\"eval_time\") && (!`output_delimiters(player)[2] ! ANY'))","player:notify(tostr(\"[used \", result[3], \" tick\", (result[3] != 1) ? \"s, \" | \", \", result[4], \" second\", (result[4] != 1) ? \"s\" | \"\", \".]\"));","endif","else","player:notify_lines(result[2]);","nerrors = length(result[2]);","player:notify(tostr(nerrors, \" error\", (nerrors == 1) ? \".\" | \"s.\"));","endif"]},{"name":"@rmprop*erty","owner":2,"perms":89,"preposition":-2,"code":["set_task_perms(player);","if ((length(args) != 1) || (!(spec = $code_utils:parse_propref(args[1]))))","player:notify(tostr(\"Usage:  \", verb, \" <object>.<property>\"));","return;","endif","object = player:my_match_object(spec[1]);","pname = spec[2];","if ($command_utils:object_match_failed(object, spec[1]))","return;","endif","try","result = delete_property(object, pname);","player:notify(\"Property removed.\");","except (E_PROPNF)","player:notify(\"That object does not define that property.\");","except res (ANY)","player:notify(res[2]);","endtry"]},{"name":"@verb","owner":2,"perms":89,"preposition":-2,"code":["set_task_perms(player);","if (!player.programmer)","player:notify(\"You need to be a programmer to do this.\");","player:notify(\"If you want to become a programmer, talk to a wizard.\");","return;","elseif (!$quota_utils:verb_addition_permitted(player))","player:tell(\"Verb addition not permitted because quota exceeded.\");","return;","endif","if (!(args && (spec = $code_utils:parse_verbref(args[1]))))","player:notify(tostr(\"Usage:  \", verb, \" <object>:<verb-name(s)> [<dobj> [<prep> [<iobj> [<permissions> [<owner>]]]]]\"));","return;","elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))","return;","endif","name = spec[2];","\"...Adding another verb of the same name is often a mistake...\";","namelist = $string_utils:explode(name);","for n in (namelist)","if (i = index(n, \"*\"))","n = n[1..i - 1] + n[i + 1..$];","endif","if ((hv = $object_utils:has_verb(object, n)) && (hv[1] == object))","player:notify(tostr(\"Warning:  Verb `\", n, \"' already defined on that object.\"));","endif","endfor","if (typeof(pas = $code_utils:parse_argspec(@listdelete(args, 1))) != LIST)","player:notify(tostr(pas));","return;","endif","verbargs = pas[1] || (player:prog_option(\"verb_args\") || {});","verbargs = {@verbargs, \"none\", \"none\", \"none\"}[1..3];","rest = pas[2];","if (verbargs == {\"this\", \"none\", \"this\"})","perms = \"rxd\";","else","perms = \"rd\";","endif","if (rest)","perms = $perm_utils:apply(perms, rest[1]);","endif","if (length(rest) < 2)","owner = player;","elseif (length(rest) > 2)","player:notify(tostr(\"\\\"\", rest[3], \"\\\" unexpected.\"));","return;","elseif ($command_utils:player_match_result(owner = $string_utils:match_player(rest[2]), rest[2])[1])","return;","elseif (owner == $nothing)","player:notify(\"Verb can't be owned by no one!\");","return;","endif","try","x = add_verb(object, {owner, perms, name}, verbargs);","player:notify(tostr(\"Verb added (\", length(verbs(object)), \").\"));","except (E_INVARG)","player:notify(tostr(rest ? tostr(\"\\\"\", perms, \"\\\" is not a valid set of permissions.\") | tostr(\"\\\"\", verbargs[2], \"\\\" is not a valid preposition (?)\")));","except e (ANY)","player:notify(e[2]);","endtry"]},{"name":"@rmverb*#","owner":2,"perms":25,"preposition":-1,"code":["set_task_perms(player);","if (!(args && (spec = $code_utils:parse_verbref(args[1]))))","player:notify(tostr(\"Usage:  \", verb, \" <object>:<verb>\"));","elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))","\"...bogus object...\";","elseif (typeof(argspec = $code_utils:parse_argspec(@listdelete(args, 1))) != LIST)","player:notify(tostr(argspec));","elseif (argspec[2])","player:notify($string_utils:from_list(argspec[2], \" \") + \"??\");","elseif (length(argspec = argspec[1]) in {1, 2})","player:notify({\"Missing preposition\", \"Missing iobj specification\"}[length(argspec)]);","else","verbname = spec[2];","if (verb == \"@rmverb#\")","loc = $code_utils:toint(verbname);","if (loc == E_TYPE)","return player:notify(\"Verb number expected.\");","elseif ((loc < 1) || (loc > `length(verbs(object)) ! E_PERM => 0'))","return player:notify(\"Verb number out of range.\");","endif","else","if (index(verbname, \"*\") > 1)","verbname = strsub(verbname, \"*\", \"\");","endif","loc = $code_utils:find_last_verb_named(object, verbname);","if (argspec)","argspec[2] = $code_utils:full_prep(argspec[2]) || argspec[2];","while (loc && (`verb_args(object, loc) ! ANY' != argspec))","loc = $code_utils:find_last_verb_named(object, verbname, loc - 1);","endwhile","endif","if (!loc)","player:notify(tostr(\"That object does not define that verb\", argspec ? \" with those args.\" | \".\"));","return;","endif","endif","info = `verb_info(object, loc) ! ANY';","vargs = `verb_args(object, loc) ! ANY';","try","delete_verb(object, loc);","if (info)","player:notify(tostr(\"Verb \", object, \":\", info[3], \" (\", loc, \") {\", $string_utils:from_list(vargs, \" \"), \"} removed.\"));","else","player:notify(tostr(\"Unreadable verb \", object, \":\", loc, \" removed.\"));","endif","except e (ANY)","player:notify(e[2]);","endtry","endif"]},{"name":"@forked","owner":2,"perms":25,"preposition":-1,"code":["\"Syntax:  @forked [player]\";","\"         @forked all wizards\";","\"\";","\"For a normal player, shows all the tasks you have waiting in your queue, especially those forked or suspended. A wizard will see all the tasks of all the players unless the optional argument is provided.\";","\"The second form is only usable by wizards and provides an output of all tasks owned by characters who are .wizard=1. Useful to find a task that may get put in a random queue due to $wiz_utils:random_wizard. Or even finding verbs that run with wizard permissions that shouldn't be.\";","set_task_perms(player);","if (!dobjstr)","tasks = queued_tasks();","elseif ((dobjstr == \"all wizards\") && player.wizard)","tasks = {};","for t in (queued_tasks())","if (valid(t[5]) && t[5].wizard)","tasks = {@tasks, t};","endif","$command_utils:suspend_if_needed(1);","endfor","elseif ($command_utils:player_match_result(dobj = $string_utils:match_player(dobjstr), dobjstr)[1])","return;","elseif (typeof(tasks = $wiz_utils:queued_tasks(dobj)) != LIST)","player:notify(tostr(verb, \" \", dobj.name, \"(\", dobj, \"):  \", tasks));","return;","endif","if (tasks)","su = $string_utils;","player:notify(\"Queue ID    Start Time            Owner         Verb (Line) [This]\");","player:notify(\"--------    ----------            -----         -----------------\");","now = time();","for task in (tasks)","$command_utils:suspend_if_needed(0);","{q_id, start, nu, nu2, owner, vloc, vname, lineno, this} = task;","time = (start >= now) ? ctime(start)[5..24] | su:left((start == -1) ? \"Reading input ...\" | tostr(now - start, \" seconds ago...\"), 20);","owner_name = valid(owner) ? owner.name | tostr(\"Dead \", owner);","player:notify(tostr(su:left(tostr(q_id), 10), \"  \", time, \"  \", su:left(owner_name, 12), \"  \", vloc, \":\", vname, \" (\", lineno, \")\", (this != vloc) ? tostr(\" [\", this, \"]\") | \"\"));","if (index(vname, \"suspend\") && (vloc == $command_utils))","\"Find out the first line of the callers() list from task_stack()\";","{sthis, svname, sprogger, svloc, splayer, slineno} = task_stack(q_id, 1)[2];","player:notify(tostr(\"                    Called By...  \", su:left(valid(sprogger) ? sprogger.name | tostr(\"Dead \", sprogger), 12), \"  \", svloc, \":\", svname, (sthis != svloc) ? tostr(\" [\", sthis, \"]\") | \"\", \" (\", slineno, \")\"));","endif","endfor","player:notify(\"-----------------------------------------------------------------\");","else","player:notify(\"No tasks.\");","endif"]},{"name":"@kill @killq*uiet","owner":2,"perms":25,"preposition":-1,"code":["\"Kills one or more tasks.\";","\"Arguments:\";","\"   object:verb -- kills all tasks which were started from that object and verb.\";","\"   all -- kills all tasks owned by invoker\";","\"   all player-name -- wizard variant:  kills all tasks owned by player.\";","\"   all everyone -- wizard variant:  really kills all tasks.\";","\"   Integer taskid -- kills the specifically named task.\";","\"   soon [integer] -- kills all tasks scheduled to run in the next [integer] seconds, which defaults to 60.\";","\"   %integer -- kills all tasks which end in the digits contained in integer.\";","\"   The @killquiet alias kills tasks without the pretty printout if more than one task is being killed.\";","set_task_perms(player);","quiet = index(verb, \"q\");","if (length(args) == 0)","player:notify_lines({tostr(\"Usage:  \", verb, \" [object]:[verb]\"), tostr(\"        \", verb, \" task_id\"), tostr(\"        \", verb, \" soon [number-of-seconds]\", player.wizard ? \" [everyone|<player name>]\" | \"\"), tostr(\"        \", verb, \" all\", player.wizard ? \" [everyone|<player name>]\" | \"\")});","return;","elseif (taskid = toint(args[1]))","elseif (all = args[1] == \"all\")","everyone = 0;","realplayer = player;","if (player.wizard && (length(args) > 1))","realplayer = $string_utils:match_player(args[2]);","everyone = args[2] == \"everyone\";","if ((!valid(realplayer)) && (!everyone))","$command_utils:player_match_result(realplayer, args[2]);","return;","elseif (!everyone)","set_task_perms(realplayer);","endif","endif","elseif (soon = args[1] == \"soon\")","realplayer = player;","if (length(args) > 1)","soon = toint(args[2]);","if ((soon <= 0) && (!player.wizard))","player:notify(tostr(\"Usage:  \", verb, \" soon [positive-number-of-seconds]\"));","return;","elseif (player.wizard)","result = this:kill_aux_wizard_parse(@args[2..$]);","soon = result[1];","if (result[1] < 0)","\"already gave them an error message\";","return;","elseif (result[2] == 1)","everyone = 1;","else","everyone = 0;","set_task_perms(result[2]);","realplayer = result[2];","endif","endif","else","soon = 60;","everyone = 0;","endif","elseif (percent = args[1][1] == \"%\")","l = length(args[1]);","digits = toint(args[1][2..l]);","percent = toint(\"1\" + \"0000000000\"[1..l - 1]);","elseif (colon = index(argstr, \":\"))","whatstr = argstr[1..colon - 1];","vrb = argstr[colon + 1..$];","if (whatstr)","what = player:my_match_object(whatstr);","endif","else","player:notify_lines({tostr(\"Usage:  \", verb, \" [object]:[verb]\"), tostr(\"        \", verb, \" task_id\"), tostr(\"        \", verb, \" soon [number-of-seconds]\", player.wizard ? \" [everyone|<player name>]\" | \"\"), tostr(\"        \", verb, \" all\", player.wizard ? \" [\\\"everyone\\\"|<player name>]\" | \"\")});","return;","endif","\"OK, parsed the line, and punted them if it was bogus.  This verb could have been a bit shorter at the expense of readability.  I think it's getting towards unreadable as is.  At this point we've set_task_perms'd, and set up an enormous number of local variables.  Evaluate them in the order we set them, and we should never get var not found.\";","queued_tasks = queued_tasks();","killed = 0;","if (taskid)","try","kill_task(taskid);","player:notify(tostr(\"Killed task \", taskid, \".\"));","killed = 1;","except error (ANY)","player:notify(tostr(\"Can't kill task \", taskid, \": \", error[2]));","endtry","elseif (all)","for task in (queued_tasks)","if (everyone || (realplayer == task[5]))","`kill_task(task[1]) ! ANY';","killed = killed + 1;","if (!quiet)","this:_kill_task_message(task);","endif","endif","$command_utils:suspend_if_needed(3, \"... killing tasks\");","endfor","elseif (soon)","now = time();","for task in (queued_tasks)","if (((task[2] - now) < soon) && ((!player.wizard) || (everyone || (realplayer == task[5]))))","`kill_task(task[1]) ! ANY';","killed = killed + 1;","if (!quiet)","this:_kill_task_message(task);","endif","endif","$command_utils:suspend_if_needed(3, \"... killing tasks\");","endfor","elseif (percent)","for task in (queued_tasks)","if (digits == (task[1] % percent))","`kill_task(task[1]) ! ANY';","killed = killed + 1;","if (!quiet)","this:_kill_task_message(task);","endif","endif","$command_utils:suspend_if_needed(3, \"... killing tasks\");","endfor","elseif ((colon || vrb) || whatstr)","for task in (queued_tasks)","if ((((((whatstr == \"\") || (valid(task[6]) && (index(task[6].name, whatstr) == 1))) || (valid(task[9]) && (index(task[9].name, whatstr) == 1))) || (task[9] == what)) || (task[6] == what)) && ((vrb == \"\") || (index(\" \" + strsub(task[7], \"*\", \"\"), \" \" + vrb) == 1)))","`kill_task(task[1]) ! ANY';","killed = killed + 1;","if (!quiet)","this:_kill_task_message(task);","endif","endif","$command_utils:suspend_if_needed(3, \"... killing tasks\");","endfor","else","player:notify(\"Something is funny; I didn't understand your @kill command.  You shouldn't have gotten here.  Please send yduJ mail saying you got this message from @kill, and what you had typed to @kill.\");","endif","if (!killed)","player:notify(\"No tasks killed.\");","elseif (quiet)","player:notify(tostr(\"Killed \", killed, \" tasks.\"));","endif"]},{"name":"@copy @copy-x @copy-move","owner":2,"perms":89,"preposition":1,"code":["\"Usage:  @copy source:verbname to target[:verbname]\";","\"  the target verbname, if not given, defaults to that of the source.  If the target verb doesn't already exist, a new verb is installed with the same args, names, code, and permission flags as the source.  Otherwise, the existing target's verb code is overwritten and no other changes are made.\";","\"This the poor man's version of multiple inheritance... the main problem is that someone may update the verb you're copying and you'd never know.\";","\"  if @copy-x is used, makes an unusable copy (!x, this none this).  If @copy-move is used, deletes the source verb as well.\";","set_task_perms(player);","if (!player.programmer)","player:notify(\"You need to be a programmer to do this.\");","player:notify(\"If you want to become a programmer, talk to a wizard.\");","return;","elseif ((verb != \"@copy-move\") && (!$quota_utils:verb_addition_permitted(player)))","player:notify(\"Verb addition not permitted because quota exceeded.\");","return;","elseif ((!(from = $code_utils:parse_verbref(dobjstr))) || (!iobjstr))","player:notify(tostr(\"Usage:  \", verb, \" obj:verb to obj:verb\"));","player:notify(tostr(\"        \", verb, \" obj:verb to obj\"));","player:notify(tostr(\"        \", verb, \" obj:verb to :verb\"));","return;","elseif ($command_utils:object_match_failed(fobj = player:my_match_object(from[1]), from[1]))","return;","elseif (iobjstr[1] == \":\")","to = {fobj, iobjstr[2..$]};","elseif (!(to = $code_utils:parse_verbref(iobjstr)))","iobj = player:my_match_object(iobjstr);","if ($command_utils:object_match_failed(iobj, iobjstr))","return;","endif","to = {iobj, from[2]};","elseif ($command_utils:object_match_failed(tobj = player:my_match_object(to[1]), to[1]))","return;","else","to[1] = tobj;","endif","from[1] = fobj;","if (verb == \"@copy-move\")","if ((!$perm_utils:controls(player, fobj)) && (!$quota_utils:verb_addition_permitted(player)))","player:notify(\"Won't be able to delete old verb.  Quota exceeded, so unable to continue.  Aborted.\");","return;","elseif ($perm_utils:controls(player, fobj))","\"only try to move if the player controls the verb. Otherwise, skip and treat as regular @copy\";","if (typeof(result = $code_utils:move_verb(@from, @to)) == ERR)","player:notify(tostr(\"Unable to move verb from \", from[1], \":\", from[2], \" to \", to[1], \":\", to[2], \" --> \", result));","else","player:notify(tostr(\"Moved verb from \", from[1], \":\", from[2], \" to \", result[1], \":\", result[2]));","endif","return;","else","player:notify(\"Won't be able to delete old verb.  Treating this as regular @copy.\");","endif","endif","to_firstname = strsub(to[2][1..index(to[2] + \" \", \" \") - 1], \"*\", \"\") || \"*\";","if ((!(hv = $object_utils:has_verb(to[1], to_firstname))) || (hv[1] != to[1]))","if ((!(info = `verb_info(@from) ! ANY')) || (!(vargs = `verb_args(@from) ! ANY')))","player:notify(tostr(\"Retrieving \", from[1], \":\", from[2], \" --> \", info && vargs));","return;","endif","if (!player.wizard)","info[1] = player;","endif","if (verb == \"@copy-x\")","\"... make sure this is an unusable copy...\";","info[2] = strsub(info[2], \"x\", \"\");","vargs = {\"this\", \"none\", \"this\"};","endif","if (from[2] != to[2])","info[3] = to[2];","endif","if (ERR == typeof(e = `add_verb(to[1], info, vargs) ! ANY'))","player:notify(tostr(\"Adding \", to[1], \":\", to[2], \" --> \", e));","return;","endif","endif","code = `verb_code(@from) ! ANY';","owner = `verb_info(@from)[1] ! ANY';","if (typeof(code) == ERR)","player:notify(tostr(\"Couldn't retrieve code from \", from[1].name, \" (\", from[1], \"):\", from[2], \" => \", code));","return;","endif","if (owner != player)","code = {tostr(\"\\\"Copied from \", from[1].name, \" (\", from[1], \"):\", from[2], (from[1] == owner) ? \" \" | tostr(\" by \", owner.name, \" (\", owner, \") \"), ctime(), \"\\\";\"), @code};","if (!player:prog_option(\"copy_expert\"))","player:notify(\"Use of @copy is discouraged.  Please do not use @copy if you can use inheritance or features instead.  Use @copy carefully, and only when absolutely necessary, as it is wasteful of database space.\");","endif","endif","if (ERR == typeof(e = `set_verb_code(to[1], to_firstname, code) ! ANY'))","player:notify(tostr(\"Copying \", from[1], \":\", from[2], \" to \", to[1], \":\", to[2], \" --> \", e));","else","player:notify(tostr(to[1], \":\", to[2], \" code set.\"));","endif"]},{"name":"_kill_task_message","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","task = args[1];","player:notify(tostr(\"Killed: \", $string_utils:right(tostr(\"task \", task[1]), 17), \", verb \", task[6], \":\", task[7], \", line \", task[8], (task[9] != task[6]) ? \", this==\" + tostr(task[9]) | \"\"));"]},{"name":"@prog*ram @program#","owner":2,"perms":89,"preposition":-2,"code":["\"This version of @program deals with multiple verbs having the same name.\";","\"... @program <object>:<verbname> <dobj> <prep> <iobj>  picks the right one.\";","if (player != caller)","return;","endif","set_task_perms(player);","\"...\";","\"...catch usage errors first...\";","\"...\";","punt = \"...set punt to 0 only if everything works out...\";","if (!(args && (spec = $code_utils:parse_verbref(args[1]))))","player:notify(tostr(\"Usage: \", verb, \" <object>:<verb> [<dobj> <prep> <iobj>]\"));","elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))","\"...bogus object...\";","elseif (typeof(argspec = $code_utils:parse_argspec(@listdelete(args, 1))) != LIST)","player:notify(tostr(argspec));","elseif (verb == \"@program#\")","verbname = $code_utils:toint(spec[2]);","if (verbname == E_TYPE)","player:notify(\"Verb number expected.\");","elseif (length(args) > 1)","player:notify(\"Don't give args for @program#.\");","elseif ((verbname < 1) || `verbname > length(verbs(object)) ! E_PERM')","player:notify(\"Verb number out of range.\");","else","argspec = 0;","punt = 0;","endif","elseif (argspec[2])","player:notify($string_utils:from_list(argspec[2], \" \") + \"??\");","elseif (length(argspec = argspec[1]) in {1, 2})","player:notify({\"Missing preposition\", \"Missing iobj specification\"}[length(argspec)]);","else","punt = 0;","verbname = spec[2];","if (index(verbname, \"*\") > 1)","verbname = strsub(verbname, \"*\", \"\");","endif","endif","\"...\";","\"...if we have an argspec, we'll need to reset verbname...\";","\"...\";","if (punt)","elseif (argspec)","if (!(argspec[2] in {\"none\", \"any\"}))","argspec[2] = $code_utils:full_prep(argspec[2]);","endif","loc = $code_utils:find_verb_named(object, verbname);","while ((loc > 0) && (`verb_args(object, loc) ! ANY' != argspec))","loc = $code_utils:find_verb_named(object, verbname, loc + 1);","endwhile","if (!loc)","punt = \"...can't find it....\";","player:notify(\"That object has no verb matching that name + args.\");","else","verbname = loc;","endif","else","loc = 0;","endif","\"...\";","\"...get verb info...\";","\"...\";","if (punt || (!(punt = \"...reset punt to TRUE...\")))","else","try","info = verb_info(object, verbname);","punt = 0;","aliases = info[3];","if (!loc)","loc = aliases in (verbs(object) || {});","endif","except (E_VERBNF)","player:notify(\"That object does not have that verb definition.\");","except error (ANY)","player:notify(error[2]);","endtry","endif","\"...\";","\"...read the code...\";","\"...\";","if (punt)","player:notify(tostr(\"Now ignoring code for \", args ? args[1] | \"nothing in particular\", \".\"));","$command_utils:read_lines();","player:notify(\"Verb code ignored.\");","else","player:notify(tostr(\"Now programming \", object.name, \":\", aliases, \"(\", (!loc) ? \"??\" | loc, \").\"));","lines = $command_utils:read_lines_escape((active = player in $verb_editor.active) ? {} | {\"@edit\"}, {tostr(\"You are editing \", $string_utils:nn(object), \":\", verbname, \".\"), @active ? {} | {\"Type `@edit' to take this into the verb editor.\"}});","if (lines[1] == \"@edit\")","player:tell(toliteral(lines));","$verb_editor:invoke(args[1], \"@program\", lines[2]);","return;","endif","try","if (result = set_verb_code(object, verbname, lines[2]))","player:notify_lines(result);","player:notify(tostr(length(result), \" error(s).\"));","player:notify(\"Verb not programmed.\");","else","player:notify(\"0 errors.\");","player:notify(\"Verb programmed.\");","endif","except error (ANY)","player:notify(error[2]);","player:notify(\"Verb not programmed.\");","endtry","endif"]},{"name":"@setenv","owner":2,"perms":89,"preposition":-2,"code":["\"Usage: @setenv <environment string>\";","\"Set your .eval_env property.\";","set_task_perms(player);","if (!argstr)","player:notify(tostr(\"Usage:  \", verb, \" <environment string>\"));","return;","endif","player:notify(tostr(\"Current eval environment is: \", player.eval_env));","result = player:set_eval_env(argstr);","if (typeof(result) == ERR)","player:notify(tostr(result));","return;","endif","player:notify(tostr(\".eval_env set to \\\"\", player.eval_env, \"\\\" (\", player.eval_ticks, \" ticks).\"));"]},{"name":"@pros*pectus pros*pectus","owner":2,"perms":93,"preposition":-2,"code":["\"Usage: @prospectus <player> [from <start>] [to <end>]\";","set_task_perms((caller_perms() == $nothing) ? player | caller_perms());","dobj = dobjstr ? $string_utils:match_player(dobjstr) | player;","if ($command_utils:player_match_result(dobj, dobjstr)[1])","return;","endif","dobjwords = $string_utils:words(dobjstr);","if (args[1..length(dobjwords)] == dobjwords)","args = args[length(dobjwords) + 1..$];","endif","if (!(parse_result = $code_utils:_parse_audit_args(@args)))","player:notify(tostr(\"Usage:  \", verb, \" player [from <start>] [to <end>]\"));","return;","endif","return $building_utils:do_prospectus(dobj, @parse_result);"]},{"name":"@d*isplay","owner":2,"perms":25,"preposition":-1,"code":["\"@display <object>[.[property]]*[,[inherited_property]]*[:[verb]]*[;[inherited_verb]]*\";","if (player != this)","player:notify(tostr(\"Sorry, you can't use \", this:title(), \"'s `\", verb, \"' command.\"));","return E_PERM;","endif","\"null names for properties and verbs are interpreted as meaning all of them.\";","opivu = {{}, {}, {}, {}, {}};","string = \"\";","punc = 1;","literal = 0;","set_task_perms(player);","for jj in [1..length(argstr)]","j = argstr[jj];","if (literal)","string = string + j;","literal = 0;","elseif (j == \"\\\\\")","literal = 1;","elseif (y = index(\".,:;\", j))","opivu[punc] = {@opivu[punc], string};","punc = 1 + y;","string = \"\";","else","string = string + j;","endif","endfor","opivu[punc] = {@opivu[punc], string};","objname = opivu[1][1];","it = this:my_match_object(objname);","if ($command_utils:object_match_failed(it, objname))","return;","endif","readable = (it.owner == this) || (it.r || this.wizard);","cant = {};","if (\"\" in opivu[2])","if (readable)","prop = properties(it);","else","prop = {};","cant = setadd(cant, it);","endif","if (!this:display_option(\"thisonly\"))","what = it;","while ((!prop) && valid(what = parent(what)))","if ((what.owner == this) || (what.r || this.wizard))","prop = properties(what);","else","cant = setadd(cant, what);","endif","endwhile","endif","else","prop = opivu[2];","endif","if (\"\" in opivu[3])","inh = {};","for what in ({it, @$object_utils:ancestors(it)})","if (((what.owner == this) || what.r) || this.wizard)","inh = {@inh, @properties(what)};","else","cant = setadd(cant, what);","endif","endfor","else","inh = opivu[3];","endif","for q in (inh)","if (q in `properties(it) ! ANY => {}')","prop = setadd(prop, q);","inh = setremove(inh, q);","endif","endfor","vrb = {};","if (\"\" in opivu[4])","if (readable)","vrbs = verbs(it);","else","vrbs = $object_utils:accessible_verbs(it);","cant = setadd(cant, it);","endif","what = it;","if (!this:display_option(\"thisonly\"))","while ((!vrbs) && valid(what = parent(what)))","if ((what.owner == this) || (what.r || this.wizard))","vrbs = verbs(what);","else","cant = setadd(cant, what);","endif","endwhile","endif","for n in [1..length(vrbs)]","vrb = setadd(vrb, {what, n});","endfor","else","for w in (opivu[4])","if (y = $object_utils:has_verb(it, w))","vrb = setadd(vrb, {y[1], w});","else","this:notify(tostr(\"No such verb, \\\"\", w, \"\\\"\"));","endif","endfor","endif","if (\"\" in opivu[5])","for z in ({it, @$object_utils:ancestors(it)})","if (((this == z.owner) || z.r) || this.wizard)","for n in [1..length(verbs(z))]","vrb = setadd(vrb, {z, n});","endfor","else","cant = setadd(cant, z);","endif","endfor","else","for w in (opivu[5])","if (typeof(y = $object_utils:has_verb(it, w)) == LIST)","vrb = setadd(vrb, {y[1], w});","else","this:notify(tostr(\"No such verb, \\\"\", w, \"\\\"\"));","endif","endfor","endif","if (({\"\"} in opivu) || (opivu[2..5] == {{}, {}, {}, {}}))","this:notify(tostr(it.name, \" (\", it, \") [ \", it.r ? \"readable \" | \"\", it.w ? \"writeable \" | \"\", it.f ? \"fertile \" | \"\", is_player(it) ? \"(player) \" | \"\", it.programmer ? \"programmer \" | \"\", it.wizard ? \"wizard \" | \"\", \"]\"));","if (it.owner != (is_player(it) ? it | this))","this:notify(tostr(\"  Owned by \", valid(p = it.owner) ? p.name | \"** extinct **\", \" (\", p, \").\"));","endif","this:notify(tostr(\"  Child of \", valid(p = parent(it)) ? p.name | \"** none **\", \" (\", p, \").\"));","if (it.location != $nothing)","this:notify(tostr(\"  Location \", valid(p = it.location) ? p.name | \"** unplace (tell a wizard, fast!) **\", \" (\", p, \").\"));","endif","if ($quota_utils.byte_based && $object_utils:has_property(it, \"object_size\"))","this:notify(tostr(\"  Size: \", $string_utils:group_number(it.object_size[1]), \" bytes at \", this:ctime(it.object_size[2])));","endif","endif","blankargs = this:display_option(\"blank_tnt\") ? {\"this\", \"none\", \"this\"} | #-1;","for b in (vrb)","$command_utils:suspend_if_needed(0);","where = b[1];","q = b[2];","short = (typeof(q) == INT) ? q | strsub(y = index(q, \" \") ? q[1..y - 1] | q, \"*\", \"\");","inf = `verb_info(where, short) ! ANY';","if ((typeof(inf) == LIST) || (inf == E_PERM))","name = (typeof(inf) == LIST) ? index(inf[3], \" \") ? (\"\\\"\" + inf[3]) + \"\\\"\" | inf[3] | q;","line = $string_utils:left(tostr($string_utils:right(tostr(where), 6), \":\", name, \" \"), 32);","if (inf == E_PERM)","line = line + \"   ** unreadable **\";","else","line = $string_utils:left(tostr(line, inf[1].name, \" (\", inf[1], \") \"), 53) + ((i = inf[2] in {\"x\", \"xd\", \"d\", \"rd\"}) ? {\" x\", \" xd\", \"  d\", \"r d\"}[i] | inf[2]);","vargs = `verb_args(where, short) ! ANY';","if (vargs != blankargs)","if (this:display_option(\"shortprep\") && (!(vargs[2] in {\"any\", \"none\"})))","vargs[2] = $code_utils:short_prep(vargs[2]);","endif","line = $string_utils:left(line + \" \", 60) + $string_utils:from_list(vargs, \" \");","endif","endif","this:notify(line);","elseif (inf == E_VERBNF)","this:notify(tostr(inf));","this:notify(tostr(\"  ** no such verb, \\\"\", short, \"\\\" **\"));","else","this:notify(\"This shouldn't ever happen. @display is buggy.\");","endif","endfor","all = {@prop, @inh};","max = (length(all) < 4) ? 999 | (this:linelen() - 56);","depth = (length(all) < 4) ? -1 | 1;","truncate_owner_names = length(all) > 1;","for q in (all)","$command_utils:suspend_if_needed(0);","inf = `property_info(it, q) ! ANY';","if (inf == E_PROPNF)","if (q in $code_utils.builtin_props)","this:notify(tostr($string_utils:left(\",\" + q, 25), \"Built in property            \", $string_utils:abbreviated_value(it.(q), max, depth)));","else","this:notify(tostr(\"  ** property not found, \\\"\", q, \"\\\" **\"));","endif","else","pname = $string_utils:left(tostr((q in `properties(it) ! ANY => {}') ? \".\" | (`is_clear_property(it, q) ! ANY' ? \" \" | \",\"), q, \" \"), 25);","if (inf == E_PERM)","this:notify(pname + \"   ** unreadable **\");","else","oname = inf[1].name;","truncate_owner_names && ((length(oname) > 12) && (oname = oname[1..12]));","`inf[2][1] != \"r\" ! E_RANGE => 1' && (inf[2][1..0] = \" \");","`inf[2][2] != \"w\" ! E_RANGE => 1' && (inf[2][2..1] = \" \");","this:notify($string_utils:left(tostr($string_utils:left(tostr(pname, oname, \" (\", inf[1], \") \"), 47), inf[2], \" \"), 54) + $string_utils:abbreviated_value(it.(q), max, depth));","endif","endif","endfor","if (cant)","failed = {};","for k in (cant)","failed = listappend(failed, tostr(k.name, \" (\", k, \")\"));","endfor","this:notify($string_utils:centre(tostr(\" no permission to read \", $string_utils:english_list(failed, \", \", \" or \", \" or \"), \". \"), 75, \"-\"));","else","this:notify($string_utils:centre(\" finished \", 75, \"-\"));","endif"]},{"name":"@db*size","owner":2,"perms":9,"preposition":-1,"code":["set_task_perms(player);","\"Let 'em @kill it.\";","count = 0;","for i in [#0..max_object()]","if ($command_utils:running_out_of_time())","player:notify(tostr(\"Counting... [\", count, \"/\", i, \"]\"));","suspend(0);","endif","if (valid(i))","count = count + 1;","endif","endfor","player:notify(tostr(\"There are \", count, \" valid objects out of \", toint(max_object()) + 1, \" allocated object numbers.\"));"]},{"name":"@gethelp","owner":2,"perms":93,"preposition":-2,"code":["\"@gethelp [<topic>] [from <db or dblist>]\";","\"  Prints the raw text of topic from the appropriate help db.\";","\"  With no argument, gets the blank (\\\"\\\") topic from wherever it lives\";","\"  Text is printed as a script for changing this help topic \";","\"  (somewhat like @dump...)\";","if (!prepstr)","topic = argstr;","dblist = $code_utils:help_db_list();","elseif (prepstr != \"from\")","player:notify(\"Usage:  \", verb, \" [<topic>] [from <db>]\");","return;","elseif (!(e = $no_one:eval_d(iobjstr = argstr[$string_utils:word_start(argstr)[(prepstr in args) + 1][1]..$])))","player:notify(tostr(e));","return;","elseif (!e[1])","player:notify_lines(e[2]);","return;","elseif (!(typeof(dblist = e[2]) in {OBJ, LIST}))","player:notify(tostr(iobjstr, \" => \", dblist, \" -- not an object or a list\"));","return;","else","topic = dobjstr;","if (typeof(dblist) == OBJ)","dblist = {dblist};","endif","endif","search = $code_utils:help_db_search(topic, dblist);","if (!search)","player:notify(\"Topic not found.\");","elseif (search[1] == $ambiguous_match)","player:notify(tostr(\"Topic `\", topic, \"' ambiguous:  \", $string_utils:english_list(search[2], \"none\", \" or \")));","elseif (typeof(text = (db = search[1]):dump_topic(fulltopic = search[2])) == ERR)","\"...ok...shoot me.  This is a -d verb...\";","player:notify(tostr(\"Cannot retrieve `\", fulltopic, \"' on \", $code_utils:corify_object(db), \":  \", text));","else","player:notify_lines(text);","endif"]},{"name":"@grep @egrep","owner":2,"perms":89,"preposition":-2,"code":["set_task_perms(player);","if (prepstr == \"in\")","pattern = dobjstr;","objlist = player:eval_cmd_string(iobjstr, 0);","if (!objlist[1])","player:notify(tostr(\"Had trouble reading `\", iobjstr, \"':  \"));","player:notify_lines(@objlist[2]);","return;","elseif (typeof(objlist[2]) == OBJ)","objlist = {objlist[2..2]};","elseif (typeof(objlist[2]) != LIST)","player:notify(tostr(\"Value of `\", iobjstr, \"' is not an object or list:  \", toliteral(objlist[2])));","return;","else","objlist = objlist[2..2];","endif","elseif ((prepstr == \"from\") && (player.wizard && (n = toint(toobj(iobjstr)))))","pattern = dobjstr;","objlist = {n};","elseif (args && player.wizard)","pattern = argstr;","objlist = {};","else","player:notify(tostr(\"Usage:  \", verb, \" <pattern> \", player.wizard ? \"[in {<objectlist>} | from <number>]\" | \"in {<objectlist>}\"));","return;","endif","player:notify(tostr(\"Searching for verbs \", @prepstr ? {prepstr, \" \", iobjstr, \" \"} | {}, (verb == \"@egrep\") ? \"matching the pattern \" | \"containing the string \", toliteral(pattern), \" ...\"));","player:notify(\"\");","$code_utils:((verb == \"@egrep\") ? \"find_verbs_matching\" | \"find_verbs_containing\")(pattern, @objlist);"]},{"name":"@s*how","owner":2,"perms":89,"preposition":-2,"code":["set_task_perms(player);","if (dobjstr == \"\")","player:notify(tostr(\"Usage:  \", verb, \" <object-or-property-or-verb>\"));","return;","endif","if (index(dobjstr, \".\") && (spec = $code_utils:parse_propref(dobjstr)))","if (valid(object = player:my_match_object(spec[1])))","return $code_utils:show_property(object, spec[2]);","endif","elseif (spec = $code_utils:parse_verbref(dobjstr))","if (valid(object = player:my_match_object(spec[1])))","return $code_utils:show_verbdef(object, spec[2]);","endif","elseif (((dobjstr[1] == \"$\") && ((pname = dobjstr[2..$]) in properties(#0))) && (typeof(#0.(pname)) == OBJ))","if (valid(object = #0.(pname)))","return $code_utils:show_object(object);","endif","elseif ((dobjstr[1] == \"$\") && (spec = $code_utils:parse_propref(dobjstr)))","return $code_utils:show_property(#0, spec[2]);","else","if (valid(object = player:my_match_object(dobjstr)))","return $code_utils:show_object(object);","endif","endif","$command_utils:object_match_failed(object, dobjstr);"]},{"name":"@check-p*roperty","owner":2,"perms":25,"preposition":-1,"code":["\"@check-prop object.property\";","\"  checks for descendents defining the given property.\";","set_task_perms(player);","if (!(spec = $code_utils:parse_propref(dobjstr)))","player:notify(tostr(\"Usage:  \", verb, \" <object>.<prop-name>\"));","elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))","\"...bogus object...\";","elseif (!($perm_utils:controls(player, object) || object.w))","player:notify(\"You can't create a property on that object anyway.\");","elseif ($object_utils:has_property(object, prop = spec[2]))","player:notify(\"That object already has that property.\");","elseif (olist = $object_utils:descendants_with_property_suspended(object, prop))","player:notify(\"The following descendents have this property defined:\");","player:notify(\"  \" + $string_utils:from_list(olist, \" \"));","else","player:notify(\"No property name conflicts found.\");","endif"]},{"name":"set_eval_env","owner":36,"perms":173,"preposition":-1,"code":["\"set_eval_env(string);\";","\"Run <string> through eval.  If it doesn't compile, return E_INVARG.  If it crashes, well, it crashes.  If it works okay, set .eval_env to it and set .eval_ticks to the amount of time it took.\";","if (is_player(this) && $perm_utils:controls(caller_perms(), this))","program = args[1];","value = $no_one:eval_d((\";ticks = ticks_left();\" + program) + \";return ticks - ticks_left() - 2;\");","if (!value[1])","return E_INVARG;","elseif (typeof(value[2]) == ERR)","return value[2];","endif","try","ok = this.eval_env = program;","this.eval_ticks = value[2];","return 1;","except error (ANY)","return error[1];","endtry","endif"]},{"name":"@clearp*roperty @clprop*erty","owner":2,"perms":25,"preposition":-1,"code":["\"@clearproperty <obj>.<prop>\";","\"Set the value of <obj>.<prop> to `clear', making it appear to be the same as the property on its parent.\";","set_task_perms(player);","if (!(l = $code_utils:parse_propref(dobjstr)))","player:notify(tostr(\"Usage:  \", verb, \" <object>.<property>\"));","elseif ($command_utils:object_match_failed(dobj = player:my_match_object(l[1]), l[1]))","\"... bogus object...\";","endif","try","if (is_clear_property(dobj, prop = l[2]))","player:notify(tostr(\"Property \", dobj, \".\", prop, \" is already clear!\"));","return;","endif","clear_property(dobj, prop);","player:notify(tostr(\"Property \", dobj, \".\", prop, \" cleared; value is now \", toliteral(dobj.(prop)), \".\"));","except (E_INVARG)","player:notify(tostr(\"You can't clear \", dobj, \".\", prop, \"; none of the ancestors define that property.\"));","except error (ANY)","player:notify(error[2]);","endtry"]},{"name":"@disown @disinherit","owner":2,"perms":89,"preposition":-2,"code":["\"Syntax: @disown <object> [from <object>]\";","\"This command is used to remove unwanted children of objects you control. If you control an object, and there is a child of that object you do not want, this command will chparent() the object to its grandparent.\";","set_task_perms(player);","if (prepstr)","if (prepstr != \"from\")","player:notify(\"Usage:  \", verb, \" <object> [from <object>]\");","return;","elseif ($command_utils:object_match_failed(iobj = player:my_match_object(iobjstr), iobjstr))","\"... from WHAT?..\";","return;","elseif (valid(dobj = $string_utils:literal_object(dobjstr)))","\"... literal object number...\";","if (parent(dobj) != iobj)","player:notify(tostr(dobj, \" is not a child of \", iobj.name, \" (\", iobj, \")\"));","return;","endif","elseif ($command_utils:object_match_failed(dobj = $string_utils:match(dobjstr, children(iobj), \"name\", children(iobj), \"aliases\"), dobjstr))","\"... can't match dobjstr against any children of iobj\";","return;","endif","elseif ($command_utils:object_match_failed(dobj = player:my_match_object(dobjstr), dobjstr))","\"... can't match dobjstr...\";","return;","endif","try","if ($object_utils:disown(dobj))","player:notify(tostr(dobj.name, \" (\", dobj, \")'s parent is now \", (grandparent = parent(dobj)).name, \" (\", grandparent, \").\"));","else","\"this should never happen\";","endif","except e (E_PERM, E_INVARG)","{code, message, value, traceback} = e;","player:notify(message);","endtry"]},{"name":"eval_cmd_string","owner":2,"perms":173,"preposition":-1,"code":["\":eval_cmd_string(string[,debug])\";","\"Evaluates the string the way this player would normally expect to see it evaluated if it were typed on the command line.  debug (defaults to 1) indicates how the debug flag should be set during the evaluation.\";","\" => {@eval_result, ticks, seconds}\";","\"where eval_result is the result of the actual eval() call.\";","\"\";","\"For the case where string is an expression, we need to prefix `return ' and append `;' to string before passing it to eval().  However this is not appropriate for statements, where it is assumed an explicit return will be provided somewhere or that the return value is irrelevant.  The code below assumes that string is an expression unless it either begins with a semicolon `;' or one of the MOO language statement keywords.\";","\"Next, the substitutions described by this.eval_subs, which should be a list of pairs {string, sub}, are performed on string\";","\"Finally, this.eval_env is prefixed to the beginning while this.eval_ticks is subtracted from the eventual tick count.  This allows string to refer to predefined variables like `here' and `me'.\";","set_task_perms(caller_perms());","{program, ?debug = 1} = args;","program = program + \";\";","debug = debug ? 33 | 0;","if (!match(program, \"^ *%(;%|%(if%|fork?%|return%|while%|try%)[^a-z0-9A-Z_]%)\"))","program = \"return \" + program;","endif","program = tostr(this.eval_env, \";\", $code_utils:substitute(program, this.eval_subs));","ticks = ((ticks_left() - 48) - this.eval_ticks) + debug;","seconds = seconds_left();","value = debug ? eval(program) | $code_utils:eval_d(program);","seconds = seconds - seconds_left();","ticks = ticks - ticks_left();","return {@value, ticks, seconds};"]},{"name":"@dump","owner":2,"perms":89,"preposition":-2,"code":["\"@dump something [with [id=...] [noprops] [noverbs] [create]]\";","\"This spills out all properties and verbs on an object, calling suspend at appropriate intervals.\";","\"   id=#nnn -- specifies an idnumber to use in place of the object's actual id (for porting to another MOO)\";","\"   noprops -- don't show properties.\";","\"   noverbs -- don't show verbs.\";","\"   create  -- indicates that a @create command should be generated and all of the verbs be introduced with @verb rather than @args; the default assumption is that the object already exists and you're just doing this to have a look at it.\";","set_task_perms(player);","dobj = player:my_match_object(dobjstr);","if ($command_utils:object_match_failed(dobj, dobjstr))","return;","endif","if (prepstr && (prepstr != \"with\"))","player:notify(tostr(\"Usage:  \", verb, \" something [with [id=...] [noprops] [noverbs] [create]]\"));","return;","endif","targname = tostr(dobj);","options = {\"props\", \"verbs\"};","create = 0;","if (iobjstr)","for o in ($string_utils:explode(iobjstr))","if (index(o, \"id=\") == 1)","targname = o[4..$];","elseif (o in {\"noprops\", \"noverbs\"})","options = setremove(options, o[3..$]);","elseif (o in {\"create\"})","create = 1;","else","player:notify(tostr(\"`\", o, \"' not understood as valid option.\"));","player:notify(tostr(\"Usage:  \", verb, \" something [with [id=...] [noprops] [noverbs] [create]]\"));","return;","endif","endfor","endif","if (create)","player:notify($code_utils:dump_preamble(dobj));","endif","if (\"props\" in options)","player:notify_lines_suspended($code_utils:dump_properties(dobj, create));","endif","if (!(\"verbs\" in options))","player:notify(\"\\\"***finished***\");","return;","endif","player:notify(\"\");","player:notify_lines_suspended($code_utils:dump_verbs(dobj, create));","player:notify(\"\\\"***finished***\");"]},{"name":"#*","owner":2,"perms":89,"preposition":-2,"code":["\"Copied from Player Class hacked with eval that does substitutions and assorted stuff (#8855):# by Geust (#24442) Sun May  9 20:19:05 1993 PDT\";","\"#<string>[.<property>|.parent] [exit|player|inventory] [for <code>] returns information about the object (we'll call it <thing>) named by string.  String is matched in the current room unless one of exit|player|inventory is given.\";","\"If neither .<property>|.parent nor <code> is specified, just return <thing>.\";","\"If .<property> is named, return <thing>.<property>.  .parent returns parent(<thing>).\";","\"If <code> is given, it is evaluated, with the value returned by the first part being substituted for %# in <code>.\";","\"For example, the command\";","\"  #JoeFeedback.parent player for toint(%#)\";","\"will return 26026 (unless Joe has chparented since writing this).\";","set_task_perms(player);","if (!(whatstr = verb[2..dot = min(index(verb + \".\", \".\"), index(verb + \":\", \":\")) - 1]))","player:notify(\"Usage:  #string [exit|player|inventory]\");","return;","elseif (!args)","what = player:my_match_object(whatstr);","elseif (index(\"exits\", args[1]) == 1)","what = player.location:match_exit(whatstr);","elseif (index(\"inventory\", args[1]) == 1)","what = player:match(whatstr);","elseif (index(\"players\", args[1]) == 1)","what = $string_utils:match_player(whatstr);","if ($command_utils:player_match_failed(what, whatstr))","return;","endif","else","what = player:my_match_object(whatstr);","endif","if ((!valid(what)) && match(whatstr, \"^[0-9]+$\"))","what = toobj(whatstr);","endif","if ($command_utils:object_match_failed(what, whatstr))","return;","endif","while (index(verb, \".parent\") == (dot + 1))","what = parent(what);","dot = dot + 7;","endwhile","if (dot >= length(verb))","val = what;","elseif ((value = $code_utils:eval_d(tostr(\"return \", what, verb[dot + 1..$], \";\")))[1])","val = value[2];","else","player:notify_lines(value[2]);","return;","endif","if (prepstr)","program = strsub(iobjstr + \";\", \"%#\", toliteral(val));","end = 1;","\"while (\\\"A\\\" <= (l = argstr[end]) && l <= \\\"Z\\\")\";","while ((\"A\" <= (l = program[end])) && (l <= \"Z\"))","end = end + 1;","endwhile","if ((program[1] == \";\") || (program[1..end - 1] in {\"if\", \"for\", \"fork\", \"return\", \"while\", \"try\"}))","program = $code_utils:substitute(program, this.eval_subs);","else","program = $code_utils:substitute(\"return \" + program, this.eval_subs);","endif","if ((value = eval(program))[1])","player:notify(this:eval_value_to_string(value[2]));","else","player:notify_lines(value[2]);","nerrors = length(value[2]);","player:notify(tostr(nerrors, \" error\", (nerrors == 1) ? \".\" | \"s.\"));","endif","else","player:notify(this:eval_value_to_string(val));","endif"]},{"name":"eval_value_to_string","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","if (typeof(val = args[1]) == OBJ)","return tostr(\"=> \", val, \"  \", valid(val) ? (\"(\" + val.name) + \")\" | ((a = $list_utils:assoc(val, {{#-1, \"<$nothing>\"}, {#-2, \"<$ambiguous_match>\"}, {#-3, \"<$failed_match>\"}})) ? a[2] | \"<invalid>\"));","elseif (typeof(val) == ERR)","return tostr(\"=> \", toliteral(val), \"  (\", val, \")\");","else","return tostr(\"=> \", toliteral(val));","endif"]},{"name":"@progo*ptions @prog-o*ptions @programmero*ptions @programmer-o*ptions","owner":2,"perms":89,"preposition":-2,"code":["\"@<what>-option <option> [is] <value>   sets <option> to <value>\";","\"@<what>-option <option>=<value>        sets <option> to <value>\";","\"@<what>-option +<option>     sets <option>   (usually equiv. to <option>=1\";","\"@<what>-option -<option>     resets <option> (equiv. to <option>=0)\";","\"@<what>-option !<option>     resets <option> (equiv. to <option>=0)\";","\"@<what>-option <option>      displays value of <option>\";","set_task_perms(player);","what = \"prog\";","options = what + \"_options\";","option_pkg = #0.(options);","set_option = (\"set_\" + what) + \"_option\";","if (!args)","player:notify_lines({(\"Current \" + what) + \" options:\", \"\", @option_pkg:show(this.(options), option_pkg.names)});","return;","elseif (typeof(presult = option_pkg:parse(args)) == STR)","player:notify(presult);","return;","else","if (length(presult) > 1)","if (typeof(sresult = this:(set_option)(@presult)) == STR)","player:notify(sresult);","return;","elseif (!sresult)","player:notify(\"No change.\");","return;","endif","endif","player:notify_lines(option_pkg:show(this.(options), presult[1]));","endif"]},{"name":"prog_option","owner":2,"perms":173,"preposition":-1,"code":["\":prog_option(name)\";","\"Returns the value of the specified prog option\";","if ((caller == this) || $perm_utils:controls(caller_perms(), this))","return $prog_options:get(this.prog_options, args[1]);","else","return E_PERM;","endif"]},{"name":"set_prog_option","owner":2,"perms":173,"preposition":-1,"code":["\":set_prog_option(oname,value)\";","\"Changes the value of the named option.\";","\"Returns a string error if something goes wrong.\";","if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))","return tostr(E_PERM);","endif","\"...this is kludgy, but it saves me from writing the same verb 3 times.\";","\"...there's got to be a better way to do this...\";","verb[1..4] = \"\";","foo_options = verb + \"s\";","\"...\";","if (typeof(s = #0.(foo_options):set(this.(foo_options), @args)) == STR)","return s;","elseif (s == this.(foo_options))","return 0;","else","this.(foo_options) = s;","return 1;","endif"]},{"name":"@list*#","owner":2,"perms":89,"preposition":-2,"code":["\"@list <obj>:<verb> [<dobj> <prep> <iobj>] [with[out] paren|num] [all] [ranges]\";","set_task_perms(player);","bynumber = verb == \"@list#\";","pflag = player:prog_option(\"list_all_parens\");","nflag = !player:prog_option(\"list_no_numbers\");","permflag = player:prog_option(\"list_show_permissions\");","aflag = 0;","argspec = {};","range = {};","spec = args ? $code_utils:parse_verbref(args[1]) | E_INVARG;","args = spec ? listdelete(args, 1) | E_INVARG;","while (args)","if (args[1] && ((index(\"without\", args[1]) == 1) || (args[1] == \"wo\")))","\"...w,wi,wit,with => 1; wo,witho,withou,without => 0...\";","fval = !index(args[1], \"o\");","if (`index(\"parentheses\", args[2]) ! ANY' == 1)","pflag = fval;","args[1..2] = {};","elseif (`index(\"numbers\", args[2]) ! ANY' == 1)","nflag = fval;","args[1..2] = {};","else","player:notify(tostr(args[1], \" WHAT?\"));","args = E_INVARG;","endif","elseif (index(\"all\", args[1]) == 1)","if (bynumber)","player:notify(\"Don't use `all' with @list#.\");","args = E_INVARG;","else","aflag = 1;","args[1..1] = {};","endif","elseif (index(\"0123456789\", args[1][1]) || (index(args[1], \"..\") == 1))","if (E_INVARG == (s = $seq_utils:from_string(args[1])))","player:notify(tostr(\"Garbled range:  \", args[1]));","args = E_INVARG;","else","range = $seq_utils:union(range, s);","args = listdelete(args, 1);","endif","elseif (bynumber)","player:notify(\"Don't give args with @list#.\");","args = E_INVARG;","elseif (argspec)","\"... second argspec?  Not likely ...\";","player:notify(tostr(args[1], \" unexpected.\"));","args = E_INVARG;","elseif (typeof(pas = $code_utils:parse_argspec(@args)) == LIST)","argspec = pas[1];","if (length(argspec) < 2)","player:notify(tostr(\"Argument `\", @argspec, \"' malformed.\"));","args = E_INVARG;","else","argspec[2] = $code_utils:full_prep(argspec[2]) || argspec[2];","args = pas[2];","endif","else","\"... argspec is bogus ...\";","player:notify(tostr(pas));","args = E_INVARG;","endif","endwhile","if (args == E_INVARG)","if (bynumber)","player:notify(tostr(\"Usage:  \", verb, \" <object>:<verbnumber> [with|without parentheses|numbers] [ranges]\"));","else","player:notify(tostr(\"Usage:  \", verb, \" <object>:<verb> [<dobj> <prep> <iobj>] [with|without parentheses|numbers] [all] [ranges]\"));","endif","return;","elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))","return;","endif","shown_one = 0;","for what in ({object, @$object_utils:ancestors(object)})","if (bynumber)","vname = $code_utils:toint(spec[2]);","if (vname == E_TYPE)","return player:notify(\"Verb number expected.\");","elseif ((vname < 1) || `vname > length(verbs(what)) ! E_PERM => 0')","return player:notify(\"Verb number out of range.\");","endif","code = `verb_code(what, vname, pflag) ! ANY';","elseif (argspec)","vnum = $code_utils:find_verb_named(what, spec[2]);","while (vnum && (`verb_args(what, vnum) ! ANY' != argspec))","vnum = $code_utils:find_verb_named(what, spec[2], vnum + 1);","endwhile","vname = vnum;","code = (!vnum) ? E_VERBNF | `verb_code(what, vnum, pflag) ! ANY';","else","vname = spec[2];","code = `verb_code(what, vname, pflag) ! ANY';","endif","if (code != E_VERBNF)","if (shown_one)","player:notify(\"\");","elseif (what != object)","player:notify(tostr(\"Object \", object, \" does not define that verb\", argspec ? \" with those args\" | \"\", \", but its ancestor \", what, \" does.\"));","endif","if (typeof(code) == ERR)","player:notify(tostr(what, \":\", vname, \" -- \", code));","else","info = verb_info(what, vname);","vargs = verb_args(what, vname);","fullname = info[3];","if (index(fullname, \" \"))","fullname = toliteral(fullname);","endif","if (index(vargs[2], \"/\"))","vargs[2] = tostr(\"(\", vargs[2], \")\");","endif","player:notify(tostr(what, \":\", fullname, \"   \", $string_utils:from_list(vargs, \" \"), permflag ? \" \" + info[2] | \"\"));","if (code == {})","player:notify(\"(That verb has not been programmed.)\");","else","lineseq = {1, length(code) + 1};","range && (lineseq = $seq_utils:intersection(range, lineseq));","if (!lineseq)","player:notify(\"(No lines in that range.)\");","endif","for k in [1..length(lineseq) / 2]","for i in [lineseq[(2 * k) - 1]..lineseq[2 * k] - 1]","if (nflag)","player:notify(tostr(\" \"[1..i < 10], i, \":  \", code[i]));","else","player:notify(code[i]);","endif","$command_utils:suspend_if_needed(0);","endfor","endfor","endif","endif","shown_one = 1;","endif","if (shown_one && (!aflag))","return;","endif","endfor","if (!shown_one)","player:notify(tostr(\"That object does not define that verb\", argspec ? \" with those args.\" | \".\"));","endif"]},{"name":"set_eval_subs","owner":2,"perms":13,"preposition":-1,"code":["\"Copied from Player Class hacked with eval that does substitutions and assorted stuff (#8855):set_eval_subs by Geust (#24442) Fri Aug  5 13:18:59 1994 PDT\";","if (!$perm_utils:controls(caller_perms(), this))","return E_PERM;","elseif (typeof(subs = args[1]) != LIST)","return E_TYPE;","else","for pair in (subs)","if (((length(pair) != 2) || typeof(pair[1] != STR)) || typeof(pair[2] != STR))","return E_INVARG;","endif","endfor","endif","return `this.eval_subs = subs ! ANY';"]},{"name":"@verbs*","owner":2,"perms":25,"preposition":-1,"code":["set_task_perms(player);","if (!dobjstr)","try","if ((verb[7] != \"(\") && (verb[$] != \")\"))","player:tell(\"Usage:  @verbs <object>\");","return;","else","dobjstr = verb[8..$ - 1];","endif","except (E_RANGE)","return player:tell(\"Usage:  @verbs <object>\");","endtry","endif","thing = player:my_match_object(dobjstr);","if (!$command_utils:object_match_failed(thing, dobjstr))","verbs = $object_utils:accessible_verbs(thing);","player:tell(\";verbs(\", thing, \") => \", toliteral(verbs));","endif"]},{"name":"@forked-v*erbose","owner":2,"perms":25,"preposition":-1,"code":["\"Syntax:  @forked-v*erbose [player]\";","\"         @forked-v*erbose all wizards\";","\"\";","\"For a normal player, shows all the tasks you have waiting in your queue, especially those forked or suspended. A wizard will see all the tasks of all the players unless the optional argument is provided. For a task which has suspended, and not a fresh fork, shows the full callers() stack.\";","\"The second form is only usable by wizards and provides an output of all tasks owned by characters who are .wizard=1. Useful to find a task that may get put in a random queue due to $wiz_utils:random_wizard. Or even finding verbs that run with wizard permissions that shouldn't be.\";","set_task_perms(player);","if (!dobjstr)","tasks = queued_tasks();","elseif ((dobjstr == \"all wizards\") && player.wizard)","tasks = {};","for t in (queued_tasks())","if (valid(t[5]) && t[5].wizard)","tasks = {@tasks, t};","endif","$command_utils:suspend_if_needed(1);","endfor","elseif ($command_utils:player_match_result(dobj = $string_utils:match_player(dobjstr), dobjstr)[1])","return;","elseif (typeof(tasks = $wiz_utils:queued_tasks(dobj)) != LIST)","player:notify(tostr(verb, \" \", dobj.name, \"(\", dobj, \"):  \", tasks));","return;","endif","if (tasks)","su = $string_utils;","player:notify(\"Queue ID    Start Time            Owner         Verb (Line) [This]\");","player:notify(\"--------    ----------            -----         -----------------\");","now = time();","for task in (tasks)","$command_utils:suspend_if_needed(0);","{q_id, start, nu, nu2, owner, vloc, vname, lineno, this} = task;","time = (start >= now) ? ctime(start)[5..24] | su:left((start == -1) ? \"Reading input ...\" | tostr(now - start, \" seconds ago...\"), 20);","owner_name = valid(owner) ? owner.name | tostr(\"Dead \", owner);","player:notify(tostr(su:left(tostr(q_id), 10), \"  \", time, \"  \", su:left(owner_name, 12), \"  \", vloc, \":\", vname, \" (\", lineno, \")\", (this != vloc) ? tostr(\" [\", this, \"]\") | \"\"));","if (stack = `task_stack(q_id, 1) ! E_INVARG => 0')","for frame in (listdelete(stack, 1))","{sthis, svname, sprogger, svloc, splayer, slineno} = frame;","player:notify(tostr(\"                    Called By...  \", su:left(valid(sprogger) ? sprogger.name | tostr(\"Dead \", sprogger), 12), \"  \", svloc, \":\", svname, (sthis != svloc) ? tostr(\" [\", sthis, \"]\") | \"\", \" (\", slineno, \")\"));","endfor","endif","endfor","player:notify(\"-----------------------------------------------------------------\");","else","player:notify(\"No tasks.\");","endif"]},{"name":"eval_d","owner":2,"perms":85,"preposition":-2,"code":["\":eval_d(code...) => {compiled?,result}\";","\"This works exactly like the builtin eval() except that the code is evaluated \";","\"as if the d flag were unset.\";","code = {\"set_verb_code(this,\\\"eval_d_util\\\",{\\\"\\\\\\\"Do not remove this verb!  This is an auxiliary verb for :eval_d().\\\\\\\";\\\"});\", \"dobj=iobj=this=#-1;\", \"dobjstr=iobjstr=prepstr=argstr=verb=\\\"\\\";\", tostr(\"caller=\", caller, \";\"), \"set_task_perms(caller_perms());\", @args};","if (!caller_perms().programmer)","return E_PERM;","elseif ((caller_perms() == $no_one) && $no_one:bad_eval(tostr(@args)))","return E_PERM;","elseif (svc = set_verb_code(this, \"eval_d_util\", code))","lines = {};","for line in (svc)","if ((index(line, \"Line \") == 1) && (n = toint(line[6..(colon = index(line + \":\", \":\")) - 1])))","lines = {@lines, tostr(\"Line \", n - 5, line[colon..$])};","else","lines = {@lines, line};","endif","endfor","return {0, lines};","else","set_task_perms(caller_perms());","return {1, this:eval_d_util()};","endif"]},{"name":"toint tonum","owner":36,"perms":173,"preposition":-1,"code":["\":toint(STR)\";","\"=> toint(s) if STR is numeric\";","\"=> E_TYPE if it isn't\";","return match(s = args[1], \"^ *[-+]?[0-9]+ *$\") ? toint(s) | E_TYPE;"]},{"name":"toobj","owner":36,"perms":173,"preposition":-1,"code":["\":toobj(objectid as string) => objectid\";","return match(s = args[1], \"^ *#[-+]?[0-9]+ *$\") ? toobj(s) | E_TYPE;"]},{"name":"toerr","owner":36,"perms":173,"preposition":-1,"code":["\"toerr(n), toerr(\\\"E_FOO\\\"), toerr(\\\"FOO\\\") => E_FOO.\";","if (typeof(s = args[1]) != STR)","n = toint(s) + 1;","if (n > length(this.error_list))","return 1;","endif","elseif (!(n = (s in this.error_names) || ((\"E_\" + s) in this.error_names)))","return 1;","endif","return this.error_list[n];"]},{"name":"error_name","owner":36,"perms":173,"preposition":-1,"code":["\"error_name(E_FOO) => \\\"E_FOO\\\"\";","return toliteral(@args);","return this.error_names[toint(args[1]) + 1];"]},{"name":"show_object","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","{object, ?what = {\"props\", \"verbs\"}} = args;","player:notify(tostr(\"Object ID:  \", object));","player:notify(tostr(\"Name:       \", object.name));","names = {\"Parent\", \"Location\", \"Owner\"};","vals = {parent(object), object.location, object.owner};","for i in [1..length(vals)]","if (!valid(vals[i]))","val = \"*** NONE ***\";","else","val = ((vals[i].name + \" (\") + tostr(vals[i])) + \")\";","endif","player:notify(tostr(names[i], \":      \"[1..12 - length(names[i])], val));","endfor","line = \"Flags:     \";","if (is_player(object))","line = line + \" player\";","endif","for flag in ({\"programmer\", \"wizard\", \"r\", \"w\", \"f\"})","if (object.(flag))","line = (line + \" \") + flag;","endif","endfor","player:notify(line);","if (player.programmer && ((player.wizard || (player == object.owner)) || object.r))","if ((\"verbs\" in what) && (vs = verbs(object)))","player:notify(\"Verb definitions:\");","for v in (vs)","$command_utils:suspend_if_needed(0);","player:notify(tostr(\"    \", v));","endfor","endif","if (\"props\" in what)","if (ps = properties(object))","player:notify(\"Property definitions:\");","for p in (ps)","$command_utils:suspend_if_needed(0);","player:notify(tostr(\"    \", p));","endfor","endif","all_props = $object_utils:all_properties(object);","if (all_props != {})","player:notify(\"Properties:\");","for p in (all_props)","$command_utils:suspend_if_needed(0);","strng = `toliteral(object.(p)) ! E_PERM => \"(Permission denied.)\"';","player:notify(tostr(\"    \", p, \": \", strng));","endfor","endif","endif","elseif (player.programmer)","player:notify(\"** Can't list properties or verbs: permission denied.\");","endif","if (object.contents)","player:notify(\"Contents:\");","for o in (object.contents)","$command_utils:suspend_if_needed(0);","player:notify(tostr(\"    \", o.name, \" (\", o, \")\"));","endfor","endif"]},{"name":"show_property","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","{object, pname} = args;","if (pname in this.builtin_props)","player:notify(tostr(object, \".\", pname));","player:notify(\"Built-in property.\");","else","try","{owner, perms} = property_info(object, pname);","except error (ANY)","player:notify(error[2]);","return;","endtry","player:notify(tostr(object, \".\", pname));","player:notify(tostr(\"Owner:        \", valid(owner) ? tostr(owner.name, \" (\", owner, \")\") | \"*** NONE ***\"));","player:notify(tostr(\"Permissions:  \", perms));","endif","player:notify(tostr(\"Value:        \", $string_utils:print(object.(pname))));"]},{"name":"show_verbdef","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","{object, vname} = args;","if (!(hv = $object_utils:has_verb(object, vname)))","player:notify(\"That object does not define that verb.\");","return;","elseif (hv[1] != object)","player:notify(tostr(\"Object \", object, \" does not define that verb, but its ancestor \", hv[1], \" does.\"));","object = hv[1];","endif","try","{owner, perms, names} = verb_info(object, vname);","except error (ANY)","player:notify(error[2]);","return;","endtry","arg_specs = verb_args(object, vname);","player:notify(tostr(object, \":\", names));","player:notify(tostr(\"Owner:            \", valid(owner) ? tostr(owner.name, \" (\", owner, \")\") | \"*** NONE ***\"));","player:notify(tostr(\"Permissions:      \", perms));","player:notify(tostr(\"Direct Object:    \", arg_specs[1]));","player:notify(tostr(\"Preposition:      \", arg_specs[2]));","player:notify(tostr(\"Indirect Object:  \", arg_specs[3]));"]},{"name":"explain_verb_syntax","owner":2,"perms":173,"preposition":-1,"code":["if (args[4..5] == {\"none\", \"this\"})","return 0;","endif","{thisobj, verb, adobj, aprep, aiobj} = args;","prep_part = (aprep == \"any\") ? \"to\" | this:short_prep(aprep);","\".........`any' => `to' (arbitrary),... `none' => empty string...\";","if ((adobj == \"this\") && (dobj == thisobj))","dobj_part = dobjstr;","iobj_part = ((!prep_part) || (aiobj == \"none\")) ? \"\" | ((aiobj == \"this\") ? dobjstr | iobjstr);","elseif ((aiobj == \"this\") && (iobj == thisobj))","dobj_part = (adobj == \"any\") ? dobjstr | ((adobj == \"this\") ? iobjstr | \"\");","iobj_part = iobjstr;","elseif (!(\"this\" in args[3..5]))","dobj_part = (adobj == \"any\") ? dobjstr | \"\";","iobj_part = (prep_part && (aiobj == \"any\")) ? iobjstr | \"\";","else","return 0;","endif","return tostr(verb, dobj_part ? \" \" + dobj_part | \"\", prep_part ? \" \" + prep_part | \"\", iobj_part ? \" \" + iobj_part | \"\");"]},{"name":"verb_p*erms verb_permi*ssions","owner":2,"perms":173,"preposition":-1,"code":["\"returns the permissions of the current verb (either the owner or the result of the most recent set_task_perms()).\";","return caller_perms();"]},{"name":"verb_loc*ation","owner":36,"perms":173,"preposition":-1,"code":["\"returns the object where the current verb is defined.\";","return callers()[1][4];"]},{"name":"verb_documentation","owner":2,"perms":173,"preposition":-1,"code":["\":verb_documentation([object,verbname]) => documentation at beginning of verb code, if any\";","\"default is the calling verb\";","set_task_perms(caller_perms());","c = callers()[1];","{?object = c[4], ?vname = c[2]} = args;","try","code = verb_code(object, vname);","except error (ANY)","return error[2];","endtry","doc = {};","for line in (code)","if (match(line, \"^\\\"%([^\\\\\\\"]%|\\\\.%)*\\\";$\"))","\"... now that we're sure `line' is just a string, eval() is safe...\";","doc = {@doc, $no_one:eval(\"; return \" + line)[2]};","else","return doc;","endif","endfor","return doc;"]},{"name":"set_verb_documentation","owner":2,"perms":173,"preposition":-1,"code":["\":set_verb_documentation(object,verbname,text)\";","\"  changes documentation at beginning of verb code\";","\"  text is either a string or a list of strings\";","\"  returns a non-1 value if anything bad happens...\";","set_task_perms(caller_perms());","{object, vname, text} = args;","if (typeof(code = `verb_code(object, vname) ! ANY') == ERR)","return code;","elseif (typeof(vd = $code_utils:verb_documentation(object, vname)) == ERR)","return vd;","elseif (!(typeof(text) in {LIST, STR}))","return E_INVARG;","else","newdoc = {};","for l in ((typeof(text) == LIST) ? text | {text})","if (typeof(l) != STR)","return E_INVARG;","endif","newdoc = {@newdoc, $string_utils:print(l) + \";\"};","endfor","if (ERR == typeof(svc = `set_verb_code(object, vname, {@newdoc, @code[length(vd) + 1..$]}) ! ANY'))","\"... this shouldn't happen.  I'm not setting this code -d just yet...\";","return svc;","else","return 1;","endif","endif"]},{"name":"parse_propref","owner":2,"perms":173,"preposition":-1,"code":["\"$code_utils:parse_propref(string)\";","\"Parses string as a MOO-code property reference, returning {object-string, prop-name-string} for a successful parse and false otherwise.  It always returns the right object-string to pass to, for example, this-room:match_object.\";","s = args[1];","if (dot = index(s, \".\"))","object = s[1..dot - 1];","prop = s[dot + 1..$];","if ((object == \"\") || (prop == \"\"))","return 0;","elseif (object[1] == \"$\")","object = `#0.(object[2..$]) ! ANY';","if (typeof(object) != OBJ)","return 0;","endif","object = tostr(object);","endif","elseif (index(s, \"$\") == 1)","object = \"#0\";","prop = s[2..$];","else","return 0;","endif","return {object, prop};"]},{"name":"parse_verbref","owner":2,"perms":173,"preposition":-1,"code":["\"$code_utils:parse_verbref(string)\";","\"Parses string as a MOO-code verb reference, returning {object-string, verb-name-string} for a successful parse and false otherwise.  It always returns the right object-string to pass to, for example, this-room:match_object().\";","s = args[1];","if (colon = index(s, \":\"))","object = s[1..colon - 1];","verbname = s[colon + 1..$];","if (!(object && verbname))","return 0;","elseif (object[1] == \"$\")","pname = object[2..$];","if ((!(pname in properties(#0))) || (typeof(object = #0.(pname)) != OBJ))","return 0;","endif","object = tostr(object);","endif","return {object, verbname};","else","return 0;","endif"]},{"name":"parse_argspec","owner":36,"perms":173,"preposition":-1,"code":["\":parse_arg_spec(@args)\";","\"  attempts to parse the given sequence of args into a verb_arg specification\";","\"returns {verb_args,remaining_args} if successful.\";","\"  e.g., :parse_arg_spec(\\\"this\\\",\\\"in\\\",\\\"front\\\",\\\"of\\\",\\\"any\\\",\\\"foo\\\"..)\";","\"           => {{\\\"this\\\",\\\"in front of\\\",\\\"any\\\"},{\\\"foo\\\"..}}\";","\"returns a string error message if parsing fails.\";","nargs = length(args);","if (nargs < 1)","return {{}, {}};","elseif ((ds = args[1]) == \"tnt\")","return {{\"this\", \"none\", \"this\"}, listdelete(args, 1)};","elseif (!(ds in {\"this\", \"any\", \"none\"}))","return tostr(\"\\\"\", ds, \"\\\" is not a valid direct object specifier.\");","elseif ((nargs < 2) || (args[2] in {\"none\", \"any\"}))","verbargs = args[1..min(3, nargs)];","rest = args[4..nargs];","elseif (!(gp = $code_utils:get_prep(@args[2..nargs]))[1])","return tostr(\"\\\"\", args[2], \"\\\" is not a valid preposition.\");","else","verbargs = {ds, @gp[1..min(2, nargs = length(gp))]};","rest = gp[3..nargs];","endif","if ((length(verbargs) >= 3) && (!(verbargs[3] in {\"this\", \"any\", \"none\"})))","return tostr(\"\\\"\", verbargs[3], \"\\\" is not a valid indirect object specifier.\");","endif","return {verbargs, rest};"]},{"name":"prepositions","owner":36,"perms":173,"preposition":-1,"code":["if (server_version() != this._version)","this:_fix_preps();","endif","return this.prepositions;"]},{"name":"short_prep","owner":36,"perms":173,"preposition":-1,"code":["\":short_prep(p) => shortest preposition equivalent to p\";","\"p may be a single word or one of the strings returned by verb_args().\";","if (server_version() != this._version)","this:_fix_preps();","endif","word = args[1];","word = word[1..index(word + \"/\", \"/\") - 1];","if (p = word in this._other_preps)","return this._short_preps[this._other_preps_n[p]];","elseif (word in this._short_preps)","return word;","else","return \"\";","endif"]},{"name":"full_prep","owner":36,"perms":173,"preposition":-1,"code":["if (server_version() != this._version)","this:_fix_preps();","endif","prep = args[1];","if (p = prep in this._short_preps)","return this.prepositions[p];","elseif (p = prep in this._other_preps)","return this.prepositions[this._other_preps_n[p]];","else","return \"\";","endif"]},{"name":"get_prep","owner":36,"perms":173,"preposition":-1,"code":["\":get_prep(@args) extracts the prepositional phrase from the front of args, returning a list consisting of the preposition (or \\\"\\\", if none) followed by the unused args.\";","\":get_prep(\\\"in\\\",\\\"front\\\",\\\"of\\\",...) => {\\\"in front of\\\",...}\";","\":get_prep(\\\"inside\\\",...)          => {\\\"inside\\\",...}\";","\":get_prep(\\\"frabulous\\\",...}       => {\\\"\\\", \\\"frabulous\\\",...}\";","prep = \"\";","allpreps = {@this._short_preps, @this._other_preps};","rest = 1;","for i in [1..length(args)]","accum = (i == 1) ? args[1] | tostr(accum, \" \", args[i]);","if (accum in allpreps)","prep = accum;","rest = i + 1;","endif","if (!(accum in this._multi_preps))","return {prep, @args[rest..$]};","endif","endfor","return {prep, @args[rest..$]};"]},{"name":"_fix_preps","owner":36,"perms":173,"preposition":1,"code":["\":_fix_preps() updates the properties on this having to do with prepositions.\";","\"_fix_preps should be called whenever we detect that a new server version has been installed.\";","orig_args = verb_args(this, verb);","multis = nothers = others = shorts = longs = {};","i = 0;","while (typeof(`set_verb_args(this, verb, {\"this\", tostr(i), \"this\"}) ! ANY') != ERR)","l = verb_args(this, verb)[2];","all = $string_utils:explode(l, \"/\");","s = all[1];","for p in (listdelete(all, 1))","if (length(p) <= length(s))","s = p;","endif","endfor","for p in (all)","while (j = rindex(p, \" \"))","multis = {p = p[1..j - 1], @multis};","endwhile","endfor","longs = {@longs, l};","shorts = {@shorts, s};","others = {@others, @setremove(all, s)};","nothers = {@nothers, @$list_utils:make(length(all) - 1, length(shorts))};","i = i + 1;","endwhile","set_verb_args(this, verb, orig_args);","this.prepositions = longs;","this._short_preps = shorts;","this._other_preps = others;","this._other_preps_n = nothers;","this._multi_preps = multis;","this._version = server_version();","return;"]},{"name":"find_verb_named","owner":2,"perms":165,"preposition":-1,"code":["\":find_verb_named(object,name[,n])\";","\"  returns the *number* of the first verb on object matching the given name.\";","\"  optional argument n, if given, starts the search with verb n,\";","\"  causing the first n verbs (1..n-1) to be ignored.\";","\"  0 is returned if no verb is found.\";","\"  This routine does not find inherited verbs.\";","{object, name, ?start = 1} = args;","for i in [start..length(verbs(object))]","verbinfo = verb_info(object, i);","if (this:verbname_match(verbinfo[3], name))","return i;","endif","endfor","return 0;"]},{"name":"find_last_verb_named","owner":2,"perms":173,"preposition":-1,"code":["\":find_last_verb_named(object,name[,n])\";","\"  returns the *number* of the last verb on object matching the given name.\";","\"  optional argument n, if given, starts the search with verb n-1,\";","\"  causing verbs (n..length(verbs(object))) to be ignored.\";","\"  -1 is returned if no verb is found.\";","\"  This routine does not find inherited verbs.\";","{object, name, ?last = -1} = args;","if (last < 0)","last = length(verbs(object));","endif","for i in [0..last - 1]","verbinfo = verb_info(object, last - i);","if (this:verbname_match(verbinfo[3], name))","return last - i;","endif","endfor","return -1;"]},{"name":"find_callable_verb_named","owner":2,"perms":173,"preposition":-1,"code":["\":find_callable_verb_named(object,name[,n])\";","\"  returns the *number* of the first verb on object that matches the given\";","\"  name and has the x flag set.\";","\"  optional argument n, if given, starts the search with verb n,\";","\"  causing the first n verbs (0..n-1) to be ignored.\";","\"  0 is returned if no verb is found.\";","\"  This routine does not find inherited verbs.\";","{object, name, ?start = 1} = args;","for i in [start..length(verbs(object))]","verbinfo = verb_info(object, i);","if (index(verbinfo[2], \"x\") && this:verbname_match(verbinfo[3], name))","return i;","endif","endfor","return 0;"]},{"name":"verbname_match(new)","owner":36,"perms":173,"preposition":-1,"code":["\":verbname_match(fullverbname,name) => TRUE iff `name' is a valid name for a verb with the given `fullname'\";","verblist = (\" \" + args[1]) + \" \";","if (index(verblist, (\" \" + (name = args[2])) + \" \") && (!match(name, \"[ *]\")))","\"Note that if name has a * or a space in it, then it can only match one of the * verbnames\";","return 1;","else","namelen = length(name);","while (m = match(verblist, \"[^ *]*%(%*%)[^ ]*\"))","vlast = m[2];","if ((namelen >= (m[3][1][1] - m[1])) && ((!(v = strsub(verblist[m[1]..vlast], \"*\", \"\"))) || (index(v, (verblist[vlast] == \"*\") ? name[1..min(namelen, length(v))] | name) == 1)))","return 1;","endif","verblist = verblist[vlast + 1..$];","endwhile","endif","return 0;"]},{"name":"find_verbs_containing","owner":2,"perms":173,"preposition":-1,"code":["\"$code_utils:find_verbs_containing(pattern[,object|object-list])\";","\"\";","\"Print (to player) the name and owner of every verb in the database whose code contains PATTERN as a substring.  Optional second argument limits the search to the specified object or objects.\";","\"\";","\"Because it searches the entire database, this function may suspend the task several times before returning.\";","\"\";","set_task_perms(caller_perms());","\"... puts the task in a player's own job queue and prevents someone from learning about verbs that are otherwise unreadable to him/her.\";","{pattern, ?where = 0} = args;","count = 0;","if (typeof(where) == INT)","for o in [toobj(where)..max_object()]","if (valid(o))","count = count + this:_find_verbs_containing(pattern, o);","endif","if ($command_utils:running_out_of_time())","player:notify(tostr(\"...\", o));","suspend(0);","endif","endfor","elseif (typeof(where) == LIST)","for o in (where)","count = count + this:_find_verbs_containing(pattern, o);","endfor","else","\"...typeof(where) == OBJ...\";","count = this:_find_verbs_containing(pattern, where);","endif","player:notify(\"\");","player:notify(tostr(\"Total: \", count, \" verbs.\"));"]},{"name":"_find_verbs_containing","owner":2,"perms":173,"preposition":-1,"code":["\":_find_verbs_containing(pattern,object)\";","\"number of verbs in object with code having a line containing pattern\";","\"prints verbname and offending line to player\";","set_task_perms(caller_perms());","{pattern, o} = args;","count = 0;","verbs = $object_utils:accessible_verbs(o);","if (typeof(verbs) == ERR)","return player:notify(tostr(\"verbs(\", o, \") => \", e[2]));","endif","for vnum in [1..length(verbs)]","if (l = this:_grep_verb_code(pattern, o, vnum))","owner = verb_info(o, vnum)[1];","player:notify(tostr(o, \":\", verbs[vnum], \" [\", valid(owner) ? owner.name | \"Recycled Player\", \" (\", owner, \")]:  \", l));","count = count + 1;","endif","if ($command_utils:running_out_of_time())","player:notify(tostr(\"...\", o));","suspend(0);","endif","endfor","return count;"]},{"name":"find_verbs_matching","owner":2,"perms":173,"preposition":-1,"code":["\"$code_utils:find_verbs_matching(pattern[,object|object-list])\";","\"\";","\"Print (to player) the name and owner of every verb in the database whose code has a substring matches the regular expression PATTERN.  Optional second argument limits the search to the specified object or objects.\";","\"\";","\"Because it searches the entire database, this function may suspend the task several times before returning.\";","\"\";","set_task_perms(caller_perms());","\"... puts the task in a player's own job queue and prevents someone from learning about verbs that are otherwise unreadable to him/her.\";","{pattern, ?where = 0} = args;","count = 0;","if (typeof(where) == INT)","for o in [toobj(where)..max_object()]","if (valid(o))","count = count + this:_find_verbs_matching(pattern, o);","endif","if ($command_utils:running_out_of_time())","player:notify(tostr(\"...\", o));","suspend(0);","endif","endfor","elseif (typeof(where) == LIST)","for o in (where)","count = count + this:_find_verbs_matching(pattern, o);","endfor","else","count = this:_find_verbs_matching(pattern, where);","endif","player:notify(\"\");","player:notify(tostr(\"Total: \", count, \" verbs.\"));"]},{"name":"_find_verbs_matching","owner":2,"perms":173,"preposition":-1,"code":["\":_find_verbs_matching(regexp,object[,casematters])\";","\"number of verbs in object with code having a line matching regexp\";","\"prints verbname and offending line to player\";","set_task_perms(caller_perms());","{pattern, o, ?casematters = 0} = args;","count = 0;","verbs = $object_utils:accessible_verbs(o);","if (typeof(verbs) == ERR)","return player:notify(tostr(\"verbs(\", o, \") => \", e[2]));","endif","for vnum in [1..length(verbs)]","if (l = this:_egrep_verb_code(pattern, o, vnum, casematters))","owner = verb_info(o, vnum)[1];","player:notify(tostr(o, \":\", verbs[vnum], \" [\", valid(owner) ? owner.name | \"Recycled Player\", \" (\", owner, \")]:  \", l));","count = count + 1;","endif","if ($command_utils:running_out_of_time())","player:notify(tostr(\"...\", o));","suspend(0);","endif","endfor","return count;"]},{"name":"_grep_verb_code","owner":2,"perms":173,"preposition":-1,"code":["\":_grep_verb_code(pattern,object,verbname) => line number or 0\";","\"  returns line number on which pattern occurs in code for object:verbname\";","set_task_perms(caller_perms());","pattern = args[1];","\"The following gross kluge is due to Quade (#82589).  tostr is fast, and so we can check for nonexistence of a pattern very quickly this way rather than checking line by line.  MOO needs a compiler.  --Nosredna\";","vc = `verb_code(@listdelete(args, 1)) ! ANY';","if ((typeof(vc) == ERR) || (!index(tostr(@vc), pattern)))","return 0;","else","for line in (vc)","if (index(line, pattern))","return line;","endif","endfor","return 0;","endif"]},{"name":"_egrep_verb_code","owner":2,"perms":173,"preposition":-1,"code":["\":_egrep_verb_code(regexp,object,verbname[,casematters]) => 0 or line number\";","\"  returns line number of first line matching regexp in object:verbname code\";","set_task_perms(caller_perms());","{pattern, object, vname, ?casematters = 0} = args;","for line in (vc = `verb_code(object, vname) ! ANY => {}')","try","if (match(line, pattern, casematters))","return line;","endif","except (E_INVARG)","raise(E_INVARG, \"Malformed regular expression.\");","endtry","endfor","return 0;"]},{"name":"_parse_audit_args","owner":36,"perms":173,"preposition":-1,"code":["\"Parse [from <start>] [to <end>] [for <name>].\";","\"Takes a series of strings, most likely @args with dobjstr removed.\";","\"Returns a list {INT start, INT end, STR name}, or {} if there is an error.\";","fail = length(args) % 2;","start = 0;","end = toint(max_object());","match = \"\";","while (args && (!fail))","prep = args[1];","if (prep == \"from\")","if ((start = player.location:match_object(args[2])) >= #0)","start = toint(start);","else","start = toint(args[2]);","endif","elseif (prep == \"to\")","if ((end = player.location:match_object(args[2])) >= #0)","end = toint(end);","else","end = toint(args[2]);","endif","elseif (prep == \"for\")","match = args[2];","else","fail = 1;","endif","args = args[3..length(args)];","endwhile","return fail ? {} | {start, end, match};"]},{"name":"help_db_list","owner":2,"perms":173,"preposition":-1,"code":["\":help_db_list([player]) => list of help dbs\";","\"in the order that they are consulted by player\";","{?who = player} = args;","olist = {who, @$object_utils:ancestors(who)};","if (valid(who.location))","olist = {@olist, who.location, @$object_utils:ancestors(who.location)};","endif","dbs = {};","for o in (olist)","h = `o.help ! ANY => 0';","if (typeof(h) == OBJ)","h = {h};","endif","if (typeof(h) == LIST)","for db in (h)","if ((typeof(db) == OBJ) && (valid(db) && (!(db in dbs))))","dbs = {@dbs, db};","endif","endfor","endif","endfor","return setadd(dbs, $help);"]},{"name":"help_db_search","owner":36,"perms":173,"preposition":-1,"code":["\":help_db_search(string,dblist)\";","\"  searches each of the help db's in dblist for a topic matching string.\";","\"  Returns  {db,topic}  or  {$ambiguous_match,{topic...}}  or {}\";","{what, dblist} = args;","topics = {};","help = 1;","for db in (dblist)","$command_utils:suspend_if_needed(0);","if ({what} == (ts = `db:find_topics(what) ! ANY => 0'))","return {db, ts[1]};","elseif (ts && (typeof(ts) == LIST))","if (help)","help = db;","endif","for t in (ts)","topics = setadd(topics, t);","endfor","endif","endfor","if (length(topics) > 1)","return {$ambiguous_match, topics};","elseif (topics)","return {help, topics[1]};","else","return {};","endif"]},{"name":"corify_object","owner":36,"perms":173,"preposition":-1,"code":["\":corify_object(object)  => string representing object\";","\"  usually just returns tostr(object), but in the case of objects that have\";","\"  corresponding #0 properties, return the appropriate $-string.\";","object = args[1];","\"Just in case #0 is !r on some idiot core.\";","for p in (`properties(#0) ! ANY => {}')","\"And if for some reason, some #0 prop is !r.\";","if (`#0.(p) ! ANY' == object)","return \"$\" + p;","endif","endfor","return tostr(object);"]},{"name":"inside_quotes","owner":2,"perms":173,"preposition":-1,"code":["\"See if the end of the string passed as args[1] ends 'inside' a doublequote.  Used by $code_utils:substitute.\";","{string} = args;","quoted = 0;","while (i = index(string, \"\\\"\"))","if ((!quoted) || ((i == 1) || (string[i - 1] != \"\\\\\")))","quoted = !quoted;","endif","string = string[i + 1..$];","endwhile","return quoted;"]},{"name":"verb_or_property","owner":2,"perms":173,"preposition":-1,"code":["\"verb_or_property(<obj>, <name> [, @<args>])\";","\"Looks for a callable verb or property named <name> on <obj>.\";","\"If <obj> has a callable verb named <name> then return <obj>:(<name>)(@<args>).\";","\"If <obj> has a property named <name> then return <obj>.(<name>).\";","\"Otherwise return E_PROPNF, or E_PERM if you don't have permission to read the property.\";","set_task_perms(caller_perms());","{object, name, @rest} = args;","return `object:(name)(@rest) ! E_VERBNF, E_INVIND => `object.(name) ! ANY'';"]},{"name":"task_valid","owner":2,"perms":173,"preposition":-1,"code":["\"task_valid(INT id)\";","\"Return true iff there is currently a valid task with the given id.\";","set_task_perms($no_one);","{id} = args;","t = $list_utils:slice(queued_tasks(), 1);","return ((id == task_id()) || (id in t)) || (E_PERM == `kill_task(id) ! ANY');"]},{"name":"task_owner","owner":2,"perms":173,"preposition":-1,"code":["\":task_owner(INT task_id) => returns the owner of the task belonging to the id.\";","if (a = $list_utils:assoc(args[1], queued_tasks()))","return a[5];","else","return E_INVARG;","endif"]},{"name":"argstr","owner":2,"perms":173,"preposition":-1,"code":["\":argstr(verb,args[,argstr]) => what argstr should have been.  \";","\"Recall that the command line is parsed into a sequence of words; `verb' is\";","\"assigned the first word, `args' is assigned the remaining words, and argstr\";","\"is assigned a substring of the command line, which *should* be the one\";","\"starting first nonblank character after the verb, but is instead (because\";","\"the parser is BROKEN!) the one starting with the first nonblank character\";","\"after the first space in the line, which is not necessarily after the verb.\";","\"Clearly, if the verb contains spaces --- which can happen if you use\";","\"backslashes and quotes --- this loses, and argstr will then erroneously\";","\"have extra junk at the beginning.  This verb, given verb, args, and the\";","\"actual argstr, returns what argstr should have been.\";","verb = args[1];","argstr = {@args, argstr}[3];","n = length(args = args[2]);","if (!index(verb, \" \"))","return argstr;","elseif (!args)","return \"\";","endif","\"space in verb => two possible cases:\";","\"(1) first space was not in a quoted string.\";","\"    first word of argstr == rest of verb unless verb ended on this space.\";","if ((nqargs = $string_utils:words(argstr)) == args)","return argstr;","elseif (((nqn = length(nqargs)) == (n + 1)) && (nqargs[2..nqn] == args))","return argstr[$string_utils:word_start(argstr)[2][1]..length(argstr)];","else","\"(2) first space was in a quoted string.\";","\"    argstr starts with rest of string\";","qs = $string_utils:word_start(\"\\\"\" + argstr);","return argstr[qs[(length(qs) - length(args)) + 1][1] - 1..length(argstr)];","endif"]},{"name":"verbname_match","owner":36,"perms":173,"preposition":-1,"code":["\":verbname_match(fullverbname,name) => TRUE iff `name' is a valid name for a verb with the given `fullname'\";","verblist = (\" \" + args[1]) + \" \";","if (index(verblist, (\" \" + (name = args[2])) + \" \") && (!(index(name, \"*\") || index(name, \" \"))))","\"Note that if name has a * or a space in it, then it can only match one of the * verbnames\";","return 1;","else","namelen = length(name);","while (star = index(verblist, \"*\"))","vstart = rindex(verblist[1..star], \" \") + 1;","vlast = (vstart + index(verblist[vstart..$], \" \")) - 2;","if ((namelen >= (star - vstart)) && ((!(v = strsub(verblist[vstart..vlast], \"*\", \"\"))) || (index(v, (verblist[vlast] == \"*\") ? name[1..min(namelen, length(v))] | name) == 1)))","return 1;","endif","verblist = verblist[vlast + 1..$];","endwhile","endif","return 0;"]},{"name":"substitute","owner":36,"perms":173,"preposition":-1,"code":["\"$code_utils:substitute(string,subs) => new line\";","\"Subs are a list of lists, {{\\\"target\\\",\\\"sub\\\"},{...}...}\";","\"Substitutes targets for subs in a delimited string fashion, avoiding substituting anything inside quotes, e.g. player:tell(\\\"don't sub here!\\\")\";","{s, subs} = args;","lets = \"abcdefghijklmnopqrstuvwxyz0123456789\";","for x in (subs)","len = length(sub = x[1]);","delimited = index(lets, sub[1]) && index(lets, sub[len]);","prefix = \"\";","while (i = index(s, sub))","prefix = prefix + s[1..i - 1];","if ((((prefix == \"\") || ((!delimited) || (!index(lets, prefix[$])))) && ((!delimited) || (((i + len) > length(s)) || (!index(lets, s[i + len]))))) && (!this:inside_quotes(prefix)))","prefix = prefix + x[2];","else","prefix = prefix + s[i..(i + len) - 1];","endif","s = s[i + len..length(s)];","endwhile","s = prefix + s;","endfor","return s;"]},{"name":"show_who_listing","owner":2,"perms":173,"preposition":-1,"code":["\":show_who_listing(players[,more_players])\";","\" prints a listing of the indicated players.\";","\" For players in the first list, idle/connected times are shown if the player is logged in, otherwise the last_disconnect_time is shown.  For players in the second list, last_disconnect_time is shown, no matter whether the player is logged in.\";","{plist, ?more_plist = {}} = args;","idles = itimes = offs = otimes = {};","argstr = dobjstr = iobjstr = prepstr = \"\";","for p in (more_plist)","if (!valid(p))","caller:notify(tostr(p, \" <invalid>\"));","elseif (typeof(t = `p.last_disconnect_time ! E_PROPNF') == INT)","if (!(p in offs))","offs = {@offs, p};","otimes = {@otimes, {-t, -t, p}};","endif","elseif (is_player(p))","caller:notify(tostr(p.name, \" (\", p, \") \", (t == E_PROPNF) ? \"is not a $player.\" | \"has a garbled .last_disconnect_time.\"));","else","caller:notify(tostr(p.name, \" (\", p, \") is not a player.\"));","endif","endfor","for p in (plist)","if (p in offs)","elseif (!valid(p))","caller:notify(tostr(p, \" <invalid>\"));","elseif (typeof(i = `idle_seconds(p) ! ANY') != ERR)","if (!(p in idles))","idles = {@idles, p};","itimes = {@itimes, {i, connected_seconds(p), p}};","endif","elseif (typeof(t = `p.last_disconnect_time ! E_PROPNF') == INT)","offs = {@offs, p};","otimes = {@otimes, {-t, -t, p}};","elseif (is_player(p))","caller:notify(tostr(p.name, \" (\", p, \") not logged in.\", (t == E_PROPNF) ? \"  Not a $player.\" | \"  Garbled .last_disconnect_time.\"));","else","caller:notify(tostr(p.name, \" (\", p, \") is not a player.\"));","endif","endfor","if (!(idles || offs))","return 0;","endif","idles = $list_utils:sort_alist(itimes);","offs = $list_utils:sort_alist(otimes);","\"...\";","\"... calculate widths...\";","\"...\";","headers = {\"Player name\", @idles ? {\"Connected\", \"Idle time\"} | {\"Last disconnect time\", \"\"}, \"Location\"};","total_width = `caller:linelen() ! ANY => 0' || 79;","max_name = total_width / 4;","name_width = length(headers[1]);","names = locations = {};","for lst in ({@idles, @offs})","$command_utils:suspend_if_needed(0);","p = lst[3];","namestr = tostr(p.name[1..min(max_name, $)], \" (\", p, \")\");","name_width = max(length(namestr), name_width);","names = {@names, namestr};","if (typeof(wlm = `p.location:who_location_msg(p) ! ANY') != STR)","wlm = valid(p.location) ? p.location.name | tostr(\"** Nowhere ** (\", p.location, \")\");","endif","locations = {@locations, wlm};","endfor","time_width = 3 + (offs ? 12 | length(\"59 minutes\"));","before = {0, w1 = 3 + name_width, w2 = w1 + time_width, w2 + time_width};","\"...\";","\"...print headers...\";","\"...\";","su = $string_utils;","tell1 = headers[1];","tell2 = su:space(tell1, \"-\");","for j in [2..4]","tell1 = su:left(tell1, before[j]) + headers[j];","tell2 = su:left(tell2, before[j]) + su:space(headers[j], \"-\");","endfor","caller:notify(tell1[1..min($, total_width)]);","caller:notify(tell2[1..min($, total_width)]);","\"...\";","\"...print lines...\";","\"...\";","active = 0;","for i in [1..total = (ilen = length(idles)) + length(offs)]","if (i <= ilen)","lst = idles[i];","if (lst[1] < (5 * 60))","active = active + 1;","endif","l = {names[i], su:from_seconds(lst[2]), su:from_seconds(lst[1]), locations[i]};","else","lct = offs[i - ilen][3].last_connect_time;","ldt = offs[i - ilen][3].last_disconnect_time;","ctime = `caller:ctime(ldt) ! ANY => 0' || ctime(ldt);","l = {names[i], (lct <= time()) ? ctime | \"Never\", \"\", locations[i]};","if ((i == (ilen + 1)) && idles)","caller:notify(su:space(before[2]) + \"------- Disconnected -------\");","endif","endif","tell1 = l[1];","for j in [2..4]","tell1 = su:left(tell1, before[j]) + l[j];","endfor","caller:notify(tell1[1..min($, total_width)]);","if ($command_utils:running_out_of_time())","if ($login:is_lagging())","\"Check lag two ways---global lag, but we might still fail due to individual lag of the queue this runs in, so check again later.\";","caller:notify(tostr(\"Plus \", total - i, \" other players (\", total, \" total; out of time and lag is high).\"));","return;","endif","now = time();","suspend(0);","if ((time() - now) > 10)","caller:notify(tostr(\"Plus \", total - i, \" other players (\", total, \" total; out of time and lag is high).\"));","return;","endif","endif","endfor","\"...\";","\"...epilogue...\";","\"...\";","caller:notify(\"\");","if (total == 1)","active_str = \", who has\" + ((active == 1) ? \"\" | \" not\");","else","if (active == total)","active_str = (active == 2) ? \"s, both\" | \"s, all\";","elseif (active == 0)","active_str = \"s, none\";","else","active_str = tostr(\"s, \", active);","endif","active_str = tostr(active_str, \" of whom ha\", (active == 1) ? \"s\" | \"ve\");","endif","caller:notify(tostr(\"Total: \", total, \" player\", active_str, \" been active recently.\"));","return total;"]},{"name":"_egrep_verb_code_all","owner":2,"perms":173,"preposition":-1,"code":["\":_egrep_verb_code_all(regexp,object,verbname) => list of lines number\";","\"  returns list of all lines matching regexp in object:verbname code\";","set_task_perms(caller_perms());","{pattern, object, vname} = args;","lines = {};","for line in (vc = `verb_code(object, vname, 1, 0) ! ANY => {}')","if (match(line, pattern))","lines = {@lines, line};","endif","endfor","return lines;"]},{"name":"_grep_verb_code_all","owner":2,"perms":173,"preposition":-1,"code":["\":_grep_verb_code_all(pattern,object,verbname) => list of lines\";","\"  returns list of lines on which pattern occurs in code for object:verbname\";","set_task_perms(caller_perms());","{pattern, object, vname} = args;","lines = {};","for line in (vc = `verb_code(object, vname) ! ANY => {}')","if (index(line, pattern))","lines = {@lines, line};","endif","endfor","return lines;"]},{"name":"verb_usage","owner":2,"perms":173,"preposition":-1,"code":["\":verb_usage([object,verbname]) => usage string at beginning of verb code, if any\";","\"default is the calling verb\";","set_task_perms(caller_perms());","c = callers()[1];","{?object = c[4], ?vname = c[2]} = args;","if (typeof(code = `verb_code(object, vname) ! ANY') == ERR)","return code;","else","doc = {};","indent = \"^$\";","for line in (code)","if (match(line, \"^\\\"%([^\\\\\\\"]%|\\\\.%)*\\\";$\"))","\"... now that we're sure `line' is just a string, eval() is safe...\";","e = $no_one:eval(line)[2];","if (subs = match(e, \"^%(%(Usage%|Syntax%): +%)%([^ ]+%)%(.*$%)\"))","\"Server is broken, hence the next three lines:\";","if (subs[3][4][1] > subs[3][4][2])","subs[3][4] = {0, -1};","endif","indent = (\"^%(\" + $string_utils:space(length(substitute(\"%1\", subs)))) + \" *%)%([^ ]+%)%(.*$%)\";","docverb = substitute(\"%3\", subs);","if (match(vname, \"^[0-9]+$\"))","vname = docverb;","endif","doc = {@doc, (substitute(\"%1\", subs) + vname) + substitute(\"%4\", subs)};","elseif (subs = match(e, indent))","if (substitute(\"%3\", subs) == docverb)","doc = {@doc, (substitute(\"%1\", subs) + vname) + substitute(\"%4\", subs)};","else","doc = {@doc, e};","endif","elseif (indent)","return doc;","endif","else","return doc;","endif","endfor","return doc;","endif"]},{"name":"verb_frame","owner":36,"perms":173,"preposition":-1,"code":["\"returns the callers() frame for the current verb.\";","return callers()[1];"]},{"name":"verb_all_frames","owner":36,"perms":173,"preposition":-1,"code":["\"returns {this:verb_frame(), @callers()}.\";","return callers();"]},{"name":"move_verb","owner":2,"perms":173,"preposition":-1,"code":["\":move_verb(OBJ from, STR verb name, OBJ to, [STR new verb name]) -> Moves the specified verb from one object to another. Returns {OBJ, Full verb name} where the verb now resides if successful, error if not. To succeed, caller_perms() must control both objects and own the verb, unless called with wizard perms. Supplying a fourth argument moves the verb to a new name.\";","\"Should handle verbnames with aliases and wildcards correctly.\";","who = caller_perms();","{from, origverb, to, ?destverb = origverb} = args;","if ((((typeof(from) != OBJ) || (typeof(to) != OBJ)) || (typeof(origverb) != STR)) || (typeof(destverb) != STR))","\"check this first so we can parse out long verb names next\";","return E_TYPE;","endif","origverb_first = strsub(origverb[1..index(origverb + \" \", \" \") - 1], \"*\", \"\") || \"*\";","destverb_first = strsub(destverb[1..index(destverb + \" \", \" \") - 1], \"*\", \"\") || \"*\";","if ((!valid(from)) || (!valid(to)))","return E_INVARG;","elseif ((from == to) && (destverb == origverb))","\"Moving same origverb onto the same object puts the verbcode in the wrong one. Just not allow\";","return E_NACC;","elseif (((!$perm_utils:controls(who, from)) && (!from.w)) || ((!$perm_utils:controls(who, to)) && (!to.w)))","\"caller_perms() is not allowed to hack on either object in question\";","return E_PERM;","elseif (!$object_utils:defines_verb(from, origverb_first))","\"verb is not defined on the from object\";","return E_VERBNF;","elseif ((vinfo = verb_info(from, origverb_first)) && (!$perm_utils:controls(who, vinfo[1])))","\"caller_perms() is not permitted to add a verb with the existing verb owner\";","return E_PERM;","elseif (!who.programmer)","return E_PERM;","else","\"we now know that the caller's perms control the objects or the objects are writable, and we know that the caller's perms control the prospective verb owner (by more traditional means)\";","vcode = verb_code(from, origverb_first);","vargs = verb_args(from, origverb_first);","vinfo[3] = (destverb == origverb) ? vinfo[3] | destverb;","if (typeof(res = `add_verb(to, vinfo, vargs) ! ANY') == ERR)","return res;","else","set_verb_code(to, destverb_first, vcode);","delete_verb(from, origverb_first);","return {to, vinfo[3]};","endif","endif"]},{"name":"move_prop*erty","owner":2,"perms":173,"preposition":-1,"code":["\":move_prop(OBJ from, STR prop name, OBJ to, [STR new prop name]) -> Moves the specified property and its contents from one object to another. Returns {OBJ, property name} where the property now resides if successful, error if not. To succeed, caller_perms() must control both objects and own the property, unless called with wizard perms. Supplying a fourth argument gives the property a new name on the new object.\";","who = caller_perms();","{from, origprop, to, ?destprop = origprop} = args;","if ((((typeof(from) != OBJ) || (typeof(to) != OBJ)) || (typeof(origprop) != STR)) || (typeof(destprop) != STR))","return E_TYPE;","elseif ((!valid(from)) || (!valid(to)))","return E_INVARG;","elseif ((from == to) && (destprop == origprop))","\"Moving same prop onto the same object puts the contents in the wrong one. Just not allow\";","return E_NACC;","elseif (((!$perm_utils:controls(who, from)) && (!from.w)) || ((!$perm_utils:controls(who, to)) && (!to.w)))","\"caller_perms() is not allowed to hack on either object in question\";","return E_PERM;","elseif (!$object_utils:defines_property(from, origprop))","\"property is not defined on the from object\";","return E_PROPNF;","elseif ((pinfo = property_info(from, origprop)) && (!$perm_utils:controls(who, pinfo[1])))","\"caller_perms() is not permitted to add a property with the existing property owner\";","return E_PERM;","elseif (!who.programmer)","return E_PERM;","else","\"we now know that the caller's perms control the objects or the objects are writable, and we know that the caller's perms control the prospective property owner (by more traditional means)\";","pdata = from.(origprop);","pname = (destprop == origprop) ? origprop | destprop;","if (typeof(res = `add_property(to, pname, pdata, pinfo) ! ANY') == ERR)","return res;","else","delete_property(from, origprop);","return {to, pname};","endif","endif"]},{"name":"eval_d_util","owner":2,"perms":165,"preposition":-1,"code":["\"Do not remove this verb!  This is an auxiliary verb for :eval_d().\";"]},{"name":"display_callers","owner":2,"perms":173,"preposition":-1,"code":["\":display_callers([callers() style list]) - displays the output of the given argument, assumed to be a callers() output. See `help callers()' for details. Will use callers() explicitly if no argument is passed.\";","call = (caller_perms() == player) ? \"notify_lines\" | \"tell_lines\";","player:(call)(this:callers_text(@args));"]},{"name":"callers_text","owner":2,"perms":173,"preposition":-1,"code":["\":callers_text([callers() style list]) - returns the output of the given argument, assumed to be a callers() output. See `help callers()' for details. Will use callers() explicitly if no argument is passed.\";","linelen = min(player:linelen(), 200);","text = {};","su = $string_utils;","lu = $list_utils;","verbwidth = 0;","{?match = callers(1)} = args;","for verbitem in (lu:slice(match, 2))","verbwidth = max(verbwidth, length(verbitem));","endfor","verbwidth = 3 + verbwidth;","numwidth = ((linelen - verbwidth) / 4) - 1;","widths = {numwidth, verbwidth, numwidth, numwidth, numwidth};","top = l = between = \"\";","for x in [1..5]","top = (top + between) + su:left({\"This\", \"Verb\", \"Permissions\", \"VerbLocation\", \"Player\"}[x], -widths[x]);","l = (l + between) + su:space(widths[x], \"-\");","between = \" \";","endfor","text = listappend(text, top);","text = listappend(text, l);","for line in (match)","output = {};","for bit in [1..5]","$command_utils:suspend_if_needed(3);","\"bit == 2 below for verb: append line number.\";","output = {@output, su:left((typeof(word = line[bit]) == STR) ? (bit == 2) ? tostr(word, \"(\", `line[6] ! ANY => 0', \")\") | word | tostr(word, \"(\", valid(word) ? lu:shortest({word.name, @word.aliases}) | ((word == $nothing) ? \"invalid\" | ((word == $ambiguous_match) ? \"ambiguous match\" | \"Error\")), \")\"), -widths[bit]), \" \"};","endfor","text = listappend(text, su:trimr(tostr(@output)));","endfor","text = listappend(text, l);","return text;"]},{"name":"set_property_value set_verb_or_property","owner":2,"perms":165,"preposition":-1,"code":["\":set_property_value(object, property, value)\";","\" set_verb_or_property(same) -- similar to `verb_or_property'\";","\"  -- attempts to set <object>.<property> to <value>.  If there exists <object>:set_<property>, then it is called and its returned value is returned.  If not, we try to set the property directly; the result of this is returned.\";","set_task_perms(caller_perms());","if (length(args) != 3)","return E_ARGS;","elseif (typeof(o = args[1]) != OBJ)","return E_INVARG;","elseif (!$recycler:valid(o))","return E_INVIND;","elseif (typeof(p = args[2]) != STR)","return E_INVARG;","elseif ($object_utils:has_callable_verb(o, v = \"set_\" + p))","return o:(v)(args[3]);","else","return o.(p) = args[3];","endif"]},{"name":"owns_task","owner":2,"perms":173,"preposition":-1,"code":["\"$code_utils:owns_task(who, task_id)\";","\"The purpose of this is to be faster than $code_utils:task_owner(task_id) in those cases where you are interested in whether a certain person owns the task rather than in determining the owner of a task where you have no preconceived notion of the owner.\";","return $list_utils:assoc(args[1], $wiz_utils:queued_tasks(args[2]));"]},{"name":"dflag_on","owner":2,"perms":173,"preposition":-1,"code":["\"Syntax:  $code_utils:dflag_on()   => 0|1\";","\"\";","\"Returns true if the verb calling the verb that called this verb has the `d' flag set true. Returns false if it is !d. If there aren't that many callers, or the calling verb was a builtin such as eval, assume the debug flag is on for traceback purposes and return true.\";","\"This is useful for determining whether the calling verb should return or raise an error to the verb that called it.\";","return (length(c = callers()) >= 2) ? `index(verb_info(c[2][4], c[2][2])[2], \"d\") && 1 ! E_INVARG => 1' | 1;"]},{"name":"type_str","owner":36,"perms":173,"preposition":-1,"code":["\"type_str -- returns a string describing the type of args[1]\";","x = args[1];","type_data = {1, 3.14, \"\", #0, E_NONE, {}};","type_strs = {\"INT\", \"FLOAT\", \"STR\", \"OBJ\", \"ERR\", \"LIST\"};","for i in [1..length(type_data)]","if (typeof(type_data[i]) == typeof(x))","return type_strs[i];","endif","endfor","return \"NONE\";"]},{"name":"dump_properties","owner":2,"perms":173,"preposition":-1,"code":["\":dump_properties (object, create_flag): returns the list of strings representing the property information for this object and its ancestor objects in @dump format.\";","set_task_perms(caller_perms());","{dobj, create} = args;","targname = tostr(dobj);","result = {};","for p in (`properties(dobj) ! ANY => {}')","pquoted = toliteral(p);","try","info = property_info(dobj, p);","value = dobj.(p);","except error (ANY)","result = {@result, tostr(\"\\\"\", targname, \".(\", pquoted, \") => \", toliteral(error[1]), \" (\", error[2], \")\")};","continue p;","endtry","if (create)","uvalue = (typeof(value) == LIST) ? \"{}\" | 0;","result = {@result, tostr(\"@prop \", targname, \".\", pquoted, \" \", uvalue || toliteral(value), \" \", info[2] || \"\\\"\\\"\", (info[1] == dobj.owner) ? \"\" | tostr(\" \", info[1]))};","if (uvalue && value)","result = {@result, tostr(\";;\", targname, \".(\", pquoted, \") = \", toliteral(value))};","endif","else","if (info[2] != \"rc\")","result = {@result, tostr(\"@chmod \", targname, \".\", pquoted, \" \", info[2])};","endif","if (info[1] != dobj.owner)","result = {@result, tostr(\"@chown \", targname, \".\", pquoted, \" \", info[1])};","endif","result = {@result, tostr(\";;\", targname, \".(\", pquoted, \") = \", toliteral(value))};","endif","$command_utils:suspend_if_needed(0);","endfor","for a in ($object_utils:ancestors(dobj))","for p in (`properties(a) ! ANY => {}')","$command_utils:suspend_if_needed(1);","pquoted = toliteral(p);","try","value = dobj.(p);","except error (ANY)","result = {@result, tostr(\"\\\"\", targname, \".(\", pquoted, \") => \", toliteral(error[1]), \" (\", error[2], \")\")};","continue p;","endtry","avalue = `a.(p) ! ANY';","if ((typeof(avalue) == ERR) || (value != avalue))","result = {@result, tostr(\";;\", targname, \".(\", pquoted, \") = \", toliteral(value))};","endif","endfor","$command_utils:suspend_if_needed(1);","endfor","return result;"]},{"name":"dump_preamble","owner":2,"perms":173,"preposition":-1,"code":["\":dump_preamble(object): produces the @create command necessary to dump this object.\";","dobj = args[1];","parent = parent(dobj);","pstring = tostr(parent);","for p in (properties(#0))","if (#0.(p) == parent)","pstring = \"$\" + p;","endif","endfor","return tostr(\"@create \", pstring, \" named \", dobj.name, \":\", $string_utils:from_list(dobj.aliases, \",\"));"]},{"name":"dump_verbs","owner":2,"perms":173,"preposition":-1,"code":["\":dump_verbs (object, create_flag): returns the list of strings representing the verb information for this object in @dump format.\";","set_task_perms(caller_perms());","{dobj, create} = args;","targname = tostr(dobj);","result = {};","v = 1;","while ((info = `verb_info(dobj, v) ! ANY') || (info == E_PERM))","if (`index(info[3], \"(old)\") ! ANY' && 0)","\"Thought about skipping (old) verbs...\";","player:tell(\"Skipping \", dobj, \":\\\"\", info[3], \"\\\"...\");","else","suspend(1);","if (typeof(info) == ERR)","result = {@result, tostr(\"\\\"\", dobj, \":\", v, \" --- \", info, \"\\\";\")};","else","if (i = index(vname = info[3], \" \"))","vname = vname[1..i - 1];","endif","if (vname[1] != \"*\")","vname = strsub(vname, \"*\", \"\");","endif","args = verb_args(dobj, v);","prep = (args[2] in {\"any\", \"none\"}) ? args[2] | $code_utils:short_prep(args[2]);","perms = (info[2] != ((args == {\"this\", \"none\", \"this\"}) ? \"rxd\" | \"rd\")) ? info[2] || \"\\\"\\\"\" | \"\";","if (create)","if (info[1] == dobj.owner)","tail = perms ? tostr(\" \", perms) | \"\";","else","tail = tostr(\" \", perms || info[2], \" \", info[1]);","endif","result = {@result, tostr(\"@verb \", targname, \":\\\"\", info[3], \"\\\" \", args[1], \" \", prep, \" \", args[3], tail)};","else","result = {@result, tostr(\"@args \", targname, \":\\\"\", info[3], \"\\\" \", args[1], \" \", prep, \" \", args[3])};","if (info[1] != dobj.owner)","result = {@result, tostr(\"@chown \", targname, \":\", vname, \" \", info[1])};","endif","if (perms)","result = {@result, tostr(\"@chmod \", targname, \":\", vname, \" \", perms)};","endif","endif","if (code = verb_code(dobj, v, 1, 1))","result = {@result, tostr(\"@program \", targname, \":\", vname)};","for c in (code)","result = {@result, c};","$command_utils:suspend_if_needed(0);","endfor","result = {@result, \".\", \"\"};","endif","endif","endif","if (`index(tostr(\" \", info[3], \" \"), \" * \") ! ANY')","\"... we have a * verb.  may as well forget trying to list...\";","\"... the rest; they're invisible.  set v to something nonstring.\";","v = E_TYPE;","else","v = v + 1;","endif","$command_utils:suspend_if_needed(0);","endwhile","return result;"]},{"name":"player_quota","owner":2,"perms":173,"preposition":-1,"code":["return $player.ownership_quota;"]},{"name":"prog_quota","owner":2,"perms":173,"preposition":-1,"code":["return $prog.ownership_quota;"]},{"name":"get_topic","owner":2,"perms":173,"preposition":-1,"code":["text = pass(@args);","object = $string_utils:match_object(what = args[1], player.location);","if ((text != E_PROPNF) || (!valid(object)))","return text;","elseif (ohelp = `object:help_msg() ! ANY' || `object.help_msg ! ANY')","return {tostr(object.name, \" (\", object, \"):\"), \"----\", @(typeof(ohelp) == LIST) ? ohelp | {ohelp}};","else","about = $object_utils:has_verb(object, \"about\");","return {tostr(\"Sorry, but no help is available on \", object.name, \" (\", object, \").\"), tostr(\"Try `examine \", what, \"'\", @about ? {\" or `about \", what, \"'\"} | {}, \".\")};","endif"]},{"name":"find_topics","owner":2,"perms":173,"preposition":-1,"code":["topiclist = pass(@args);","if (topiclist || (!args))","return topiclist;","elseif (valid(o = $string_utils:match_object(what = args[1], player.location)))","return {what};","else","return {};","endif"]},{"name":"full_index","owner":36,"perms":173,"preposition":-1,"code":["text = {};","for db in ($code_utils:help_db_list())","if ($object_utils:has_callable_verb(db, \"index\"))","text = {@text, @db:index({tostr(db.name, \" (\", db, \")\")})};","endif","endfor","return text;"]},{"name":"index_list","owner":36,"perms":173,"preposition":-1,"code":["hdr = \"Available Help Indices\";","text = {\"\", hdr, $string_utils:space(hdr, \"-\")};","for db in ($code_utils:help_db_list())","try","for p in (db:find_index_topics())","text = {@text, tostr($string_utils:left(p, 14), \" -- \", `db.(p)[2] ! ANY' || db.name, \" (\", db, \")\")};","endfor","except (ANY)","\"generally it will be E_TYPE when :find_index_topics returns an ERR. Just skip\";","continue db;","endtry","endfor","if (full = this:find_full_index_topic())","text = {@text, \"\", tostr($string_utils:left(full, 14), \" -- \", \"EVERYTHING\")};","endif","return text;"]},{"name":"wizard_list","owner":2,"perms":173,"preposition":-1,"code":["wizzes = {};","for w in ($object_utils:leaves($wiz))","if (w.wizard && (w.advertised && is_player(w)))","wizzes = {@wizzes, w};","endif","endfor","wizzes = {#2, @$list_utils:randomly_permute(setremove(wizzes, #2))};","numwiz = length(wizzes);","hlist = {\"ArchWizard:\", \"Wizard\" + ((numwiz == 2) ? \":\" | \"s:\"), @$list_utils:make(max(0, numwiz - 2), \"\")};","slist = {};","su = $string_utils;","for i in [1..numwiz]","wiz = wizzes[i];","slist = {@slist, tostr(su:left(hlist[i], 13), su:left(wiz.name, 16), (wpi = `wiz.public_identity.name ! ANY') ? (\" (a.k.a. \" + wpi) + \")\" | \"\")};","endfor","return slist;"]},{"name":"dump_topic","owner":36,"perms":173,"preposition":-1,"code":["if (((text = pass(@args)) != E_PROPNF) || ((!valid(object = $string_utils:match_object(what = args[1], player.location))) || (!$object_utils:has_property(object, \"help_msg\"))))","return text;","else","return {tostr(\";;\", $code_utils:corify_object(object), \".help_msg = $command_utils:read_lines()\"), @$command_utils:dump_lines((typeof(text = object.help_msg) == LIST) ? text | {text})};","endif"]},{"name":"find_full_index_topic","owner":36,"perms":173,"preposition":-1,"code":["\":find_full_index_topic([search])\";","\"Return the *full_index* topic or 0\";","\"If search argument is given and true, we don't depend on cached info.\";","{?search = 0} = args;","\"... N.B.  There is no cached info; it turns out that\";","\"... full-index is near enough to the beginning of $help's property list\";","\"... that there's no point to doing this.  --Rog\";","for p in (`properties(this) ! E_PERM => {}')","if (`this.(p)[1] ! ANY' == \"*full_index*\")","return p;","endif","endfor","return 0;"]},{"name":"description","owner":36,"perms":173,"preposition":-1,"code":["raw = ctime(this.last_news_time);","\"         111111111122222\";","\"123456789012345678901234\";","\"Fri Nov 30 14:31:21 1990\";","date = (raw[1..10] + \",\") + raw[20..24];","return strsub(this.description, \"%d\", date);"]},{"name":"is_writable_by","owner":2,"perms":173,"preposition":-1,"code":["return pass(@args) || (args[1] in $list_utils:map_prop($object_utils:descendants($wiz), \"mail_identity\"));"]},{"name":"rm_message_seq","owner":36,"perms":173,"preposition":-1,"code":["if (this:ok_write(caller, caller_perms()))","seq = args[1];","this.current_news_going = $seq_utils:intersection(this.current_news, seq);","this.current_news = $seq_utils:contract(this.current_news, seq);","return $mail_agent:(verb)(@args);","else","return E_PERM;","endif"]},{"name":"undo_rmm","owner":36,"perms":173,"preposition":-1,"code":["if (!this:ok_write(caller, caller_perms()))","return E_PERM;","endif","seq = $mail_agent:(verb)(@args);","this.current_news = $seq_utils:union(this.current_news_going, $seq_utils:expand(this.current_news, seq));","this.current_news_going = {};","return seq;"]},{"name":"expunge_rmm","owner":36,"perms":173,"preposition":-1,"code":["if (!this:ok_write(caller, caller_perms()))","return E_PERM;","endif","this.current_news_going = {};","return $mail_agent:(verb)(@args);"]},{"name":"set_current_news","owner":36,"perms":173,"preposition":-1,"code":["if (!this:ok_write(caller, caller_perms()))","return E_PERM;","else","this.current_news = new = args[1];","if (new)","newlast = $seq_utils:last(new);","newlasttime = this:messages_in_seq(newlast)[2][1];","if (newlasttime > this.last_news_time)","\"... only notify people if there exists a genuinely new item...\";","this.last_news_time = newlasttime;","this:touch();","endif","else","\"...flush everything...\";","this.last_news_time = 0;","endif","endif"]},{"name":"add_current_news","owner":36,"perms":173,"preposition":-1,"code":["if (!this:ok_write(caller, caller_perms()))","return E_PERM;","else","return this:set_current_news($seq_utils:union(this.current_news, args[1]));","endif"]},{"name":"rm_current_news","owner":36,"perms":173,"preposition":-1,"code":["if (!this:ok_write(caller, caller_perms()))","return E_PERM;","else","return this:set_current_news($seq_utils:intersection(this.current_news, $seq_utils:complement(args[1])));","endif"]},{"name":"news_display_seq_full","owner":2,"perms":173,"preposition":-1,"code":["\":news_display_seq_full(msg_seq) => {cur, last-read-date}\";","\"Display the given msg_seq as a collection of news items\";","set_task_perms(caller_perms());","desc = this:description();","player:notify((typeof(desc) == LIST) ? desc[1] | desc);","player:notify(\"\");","msgs = this:messages_in_seq(args[1]);","for i in [-(n = length(msgs))..-1]","x = msgs[-i];","player:notify_lines(this:to_text(@x[2]));","player:notify(\"\");","$command_utils:suspend_if_needed(0);","endfor","player:notify(\"(end)\");","return {msgs[n][1], msgs[n][2][1]};"]},{"name":"to_text","owner":36,"perms":173,"preposition":-1,"code":["\":to_text(@msg) => message in text form -- formatted like a $news entry circa October, 1993\";","date = args[1];","by = args[2];","\"by = by[1..index(by, \\\"(\\\") - 2]\";","subject = (args[4] == \" \") ? \"-*-NEWS FLASH-*-\" | $string_utils:uppercase(args[4]);","text = args[(\"\" in {@args, \"\"}) + 1..$];","ctime = $time_utils:time_sub(\"$D, $N $3, $Y\", date);","return {ctime, subject, @text};","return {subject, tostr(\"  by \", by, \" on \", ctime), \"\", @text};"]},{"name":"check","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","if ((player:get_current_message(this) || {0, 0})[2] < this.last_news_time)","if ((n = player:mail_option(\"news\")) in {0, \"all\"})","player:tell(\"There is new news.  Type `news' to read all news or `news new' to read just new news.\");","elseif (n == \"contents\")","player:tell(\"There is new news.  Type `news all' to read all news or `news new' to read just new news.\");","elseif (n == \"new\")","player:tell(\"There is new news.  Type `news' to read new news, or `news all' to read all news.\");","endif","endif"]},{"name":"touch","owner":2,"perms":45,"preposition":-1,"code":["if (!this:ok_write(caller, valid(who = caller_perms()) ? who | player))","player:notify(\"Permission denied.\");","return;","endif","fork (0)","for p in (connected_players())","$command_utils:suspend_if_needed(0);","if ((p:get_current_message(this) || {0, 0})[2] < this.last_news_time)","p:notify(\"There's a new edition of the newspaper.  Type 'news new' to see the new article(s).\");","endif","endfor","endfork"]},{"name":"@addnews","owner":2,"perms":157,"preposition":1,"code":["if ((caller_perms() != #-1) && (caller_perms() != player))","raise(E_PERM);","endif","set_task_perms(player);","if (!this:is_writable_by(player))","player:notify(\"You can't write the news.\");","elseif (typeof(result = this:add_news(args[1..(prepstr in args) - 1], player:get_current_message(this) || {0, 0})) == STR)","player:notify(result);","else","new = this.current_news;","if (new)","player:notify(\"Current newspaper set.\");","this:display_seq_headers(new);","else","player:notify(\"Current newspaper is now empty.\");","endif","endif"]},{"name":"@rmnews","owner":2,"perms":157,"preposition":5,"code":["if ((caller_perms() != #-1) && (caller_perms() != player))","raise(E_PERM);","endif","set_task_perms(player);","if (!this:is_writable_by(player))","player:notify(\"You can't write the news.\");","elseif (typeof(result = this:rm_news(args[1..(prepstr in args) - 1], player:get_current_message(this) || {0, 0})) == STR)","player:notify(result);","else","new = this.current_news;","if (new)","player:notify(\"Current newspaper set.\");","this:display_seq_headers(new);","else","player:notify(\"Current newspaper is now empty.\");","endif","endif"]},{"name":"@setnews","owner":2,"perms":105,"preposition":1,"code":["set_task_perms(player);","if (!this:is_writable_by(player))","player:notify(\"You can't write the news.\");","elseif (typeof(seq = this:_parse(strings = args[(prepstr in args) + 1..$], @player:get_current_message(this) || {0, 0})) == STR)","player:notify(seq);","else","old = this.current_news;","if (old == seq)","player:notify(\"No change.\");","else","this:set_current_news(seq);","if (seq)","player:notify(\"Current newspaper set.\");","this:display_seq_headers(seq);","else","player:notify(\"Current newspaper is now empty.\");","endif","endif","endif"]},{"name":"_parse","owner":36,"perms":173,"preposition":-1,"code":["if (!(strings = args[1]))","return \"You need to specify a message sequence\";","elseif (typeof(pms = this:parse_message_seq(@args)) == STR)","return $string_utils:substitute(pms, {{\"%f\", \"The news\"}, {\"%<has>\", \"has\"}, {\"%%\", \"%\"}});","elseif (typeof(pms) != LIST)","return tostr(pms);","elseif (length(pms) > 1)","return tostr(\"I don't understand `\", pms[2], \"'.\");","elseif (!(seq = pms[1]))","return tostr(\"The News (\", this, \") has no `\", $string_utils:from_list(pms[2][1..used], \" \"), \"' messages.\");","else","return seq;","endif"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","pass();","this:rm_message_seq($seq_utils:range(1, this:length_all_msgs()));","this:expunge_rmm();","this.description = \"It's the current issue of the News, dated %d.\";","this.mail_forward = {};","for p in ({\"moderator_forward\", \"writers\", \"last_used_time\", \"mail_notify\"})","this.(p) = $mail_recipient.(p);","endfor","this.moderated = 1;","this.last_news_time = 0;","this.readers = 1;","this.archive_news = {};","$mail_agent:send_message(#2, this, \"Welcome to LambdaCore\", $wiz_utils.new_core_message);","this:add_news(\"$\");","else","return E_PERM;","endif"]},{"name":"add_news","owner":2,"perms":173,"preposition":-1,"code":["if (!this:ok_write(caller, caller_perms()))","$error:raise(E_PERM);","endif","{specs, ?cur = {0, 0}} = args;","seq = this:_parse(specs, @cur);","if (typeof(seq) == STR)","return seq;","endif","old = this.current_news;","new = $seq_utils:union(old, seq);","if (old == new)","return \"Those messages are already in the news.\";","endif","this:set_current_news(new);","return 1;"]},{"name":"rm_news","owner":2,"perms":173,"preposition":-1,"code":["if (!this:ok_write(caller, caller_perms()))","raise(E_PERM);","endif","{specs, ?cur = {0, 0}} = args;","seq = this:_parse(specs, @cur);","if (typeof(seq) == STR)","return seq;","endif","old = this.current_news;","new = $seq_utils:intersection(old, $seq_utils:complement(seq));","if (old == new)","return \"Those messages were not in the news.\";","endif","this:set_current_news(new);","return 1;"]},{"name":"@listnews","owner":2,"perms":141,"preposition":4,"code":["player:notify(\"The following articles are currently in the newspaper:\");","this:display_seq_headers(this.current_news);"]},{"name":"@clearnews","owner":36,"perms":41,"preposition":-1,"code":["set_task_perms(player);","if (this:is_writable_by(player))","this:set_current_news({});","player:notify(\"Current newspaper is now empty.\");","else","player:notify(\"You can't write the news.\");","endif"]},{"name":"disfunc","owner":2,"perms":173,"preposition":-1,"code":["\"Copied from The Coat Closet (#11):disfunc by Haakon (#2) Mon May  8 10:41:04 1995 PDT\";","if ((((cp = caller_perms()) == (who = args[1])) || $perm_utils:controls(cp, who)) || (caller == this))","\"need the first check since guests don't control themselves\";","if (who.home == this)","move(who, $limbo);","this:announce(\"You hear a quiet popping sound; \", who.name, \" has disconnected.\");","else","pass(who);","endif","endif"]},{"name":"enterfunc","owner":2,"perms":173,"preposition":-1,"code":["\"Copied from The Coat Closet (#11):enterfunc by Haakon (#2) Mon May  8 10:41:38 1995 PDT\";","who = args[1];","if ($limbo:acceptable(who))","move(who, $limbo);","else","pass(who);","endif"]},{"name":"match","owner":36,"perms":173,"preposition":-1,"code":["\"Copied from The Coat Closet (#11):match by Lambda (#50) Mon May  8 10:42:01 1995 PDT\";","m = pass(@args);","if (m == $failed_match)","\"... it might be a player off in the body bag...\";","m = $string_utils:match_player(args[1]);","if (valid(m) && (!(m.location in {this, $limbo})))","return $failed_match;","endif","endif","return m;"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["\"Copied from The Coat Closet (#11):init_for_core by Nosredna (#2487) Mon May  8 10:42:52 1995 PDT\";","if (!caller_perms().wizard)","return E_PERM;","endif","for v in ({\"announce*\", \"emote\", \"button\", \"knob\"})","if (`verb_info($player_start, v) ! E_VERBNF => 0')","delete_verb($player_start, v);","endif","endfor","for p in ({\"out\", \"quiet\", \"button\"})","if (p in properties($player_start))","delete_property($player_start, p);","endif","endfor","for p in ($object_utils:all_properties($room))","clear_property($player_start, p);","endfor","$player_start.name = \"The First Room\";","$player_start.aliases = {};","$player_start.description = \"This is all there is right now.\";","$player_start.exits = $player_start.entrances = {};"]},{"name":"keep_clean","owner":2,"perms":173,"preposition":-1,"code":["\"Copied from The Coat Closet (#11):keep_clean by Haakon (#2) Mon May  8 10:47:08 1995 PDT\";","if ($perm_utils:controls(caller_perms(), this))","junk = {};","while (1)","for x in (junk)","$command_utils:suspend_if_needed(0);","if (x in this.contents)","\"This is old junk that's still around five minutes later.  Clean it up.\";","if (!valid(x.owner))","move(x, $nothing);","#2:tell(\">**> Cleaned up orphan object `\", x.name, \"' (\", x, \"), owned by \", x.owner, \", to #-1.\");","elseif (!$object_utils:contains(x, x.owner))","move(x, x.owner);","x.owner:tell(\"You shouldn't leave junk in \", this.name, \"; \", x.name, \" (\", x, \") has been moved to your inventory.\");","#2:tell(\">**> Cleaned up `\", x.name, \"' (\", x, \"), owned by `\", x.owner.name, \"' (\", x.owner, \"), to \", x.owner, \".\");","endif","endif","endfor","junk = {};","for x in (this.contents)","if ((seconds_left() < 2) || (ticks_left() < 1000))","suspend(0);","endif","if (!is_player(x))","junk = {@junk, x};","endif","endfor","suspend(5 * 60);","endwhile","endif"]},{"name":"_recreate","owner":2,"perms":173,"preposition":-1,"code":["\"Return a toad (child of #1, owned by $hacker) from this.contents.  Move it to #-1.  Recreate as a child of args[1], or of #1 if no args are given.  Chown to caller_perms() or args[2] if present.\";","{?what = #1, ?who = caller_perms()} = args;","if (!(caller_perms().wizard || (who == caller_perms())))","return E_PERM;","elseif (!(valid(what) && is_player(who)))","return E_INVARG;","elseif ((((who != what.owner) && (!what.f)) && (!who.wizard)) && (!caller_perms().wizard))","return E_PERM;","endif","for potential in (this.contents)","if (((potential.owner == $hacker) && (parent(potential) == $garbage)) && (!children(potential)))","return this:setup_toad(potential, who, what);","endif","endfor","return E_NONE;"]},{"name":"_recycle","owner":2,"perms":173,"preposition":-1,"code":["\"Take the object in args[1], and turn it into a child of #1 owned by $hacker.\";","\"If the object is a player, decline.\";","item = args[1];","if (!$perm_utils:controls(caller_perms(), item))","raise(E_PERM);","elseif (is_player(item))","raise(E_INVARG);","endif","this:addhist(caller_perms(), item);","\"...recreate can fail (:recycle can crash)...\";","this:add_orphan(item);","this:kill_all_tasks(item);","$quota_utils:preliminary_reimburse_quota(item.owner, item);","$building_utils:recreate(item, $garbage);","this:remove_orphan(item);","\"...\";","$wiz_utils:set_owner(item, $hacker);","item.name = tostr(\"Recyclable \", item);","`move(item, this) ! ANY => 0';"]},{"name":"_create","owner":2,"perms":173,"preposition":-1,"code":["e = `set_task_perms(caller_perms()) ! ANY';","if (typeof(e) == ERR)","return e;","else","val = this:_recreate(@args);","return (val == E_NONE) ? $quota_utils:bi_create(@args) | val;","endif"]},{"name":"addhist","owner":2,"perms":173,"preposition":-1,"code":["if (caller == this)","h = this.history;","if ((len = length(h)) > this.nhist)","h = h[len - this.nhist..len];","endif","this.history = {@h, args};","endif"]},{"name":"show*-history","owner":2,"perms":45,"preposition":-1,"code":["if ($perm_utils:controls(valid(caller_perms()) ? caller_perms() | player, this))","for x in (this.history)","pname = valid(x[1]) ? x[1].name | \"A recycled player\";","oname = valid(x[2]) ? x[2].name | \"recycled\";","player:notify(tostr(pname, \" (\", x[1], \") recycled \", x[2], \" (now \", oname, \")\"));","endfor","else","player:tell(\"Sorry.\");","endif"]},{"name":"request","owner":2,"perms":157,"preposition":5,"code":["\"added check that obj is already $garbage - Bits 12/16/5\";","if (!(caller_perms() in {player, #-1}))","raise(E_PERM);","endif","dobj = valid(dobj) ? dobj | $string_utils:match_object(dobjstr, player.location);","if (!valid(dobj))","dobj = (n = toint(dobjstr)) ? toobj(n) | #-1;","endif","if (!valid(dobj))","player:tell(\"Couldn't parse \", dobjstr, \" as a valid object number.\");","elseif (!(dobj in this.contents))","player:tell(\"Couldn't find \", dobj, \" in \", this.name, \".\");","elseif (!$object_utils:isa(dobj, $garbage))","player:tell(\"Sorry, that isn't recyclable.\");","elseif ($object_utils:has_callable_verb(this, \"request_refused\") && (msg = this:request_refused(player, dobj)))","player:tell(\"Sorry, can't do that:  \", msg);","else","if (typeof(emsg = this:setup_toad(dobj, player, $root_class)) != ERR)","dobj:moveto(player);","dobj.aliases = {dobj.name = \"Object \" + tostr(dobj)};","player:tell(\"You now have \", dobj, \" ready for @recreation.\");","if (this.announce_removal_msg)","player.location:announce($string_utils:pronoun_sub(this.announce_removal_msg));","endif","else","player:tell(emsg);","endif","endif"]},{"name":"setup_toad","owner":2,"perms":173,"preposition":-1,"code":["\"this:setup_toad(objnum,new_owner,parent)\";","\"Called by :_create and :request.\";","if (caller != this)","return E_PERM;","endif","{potential, who, what} = args;","if (!$quota_utils:creation_permitted(who))","return E_QUOTA;","else","$wiz_utils:set_owner(potential, who);","move(potential, #-1);","set_task_perms({@callers(), {#-1, \"\", player}}[2][3]);","\"... if :initialize crashes...\";","this:add_orphan(potential);","$building_utils:recreate(potential, what);","this:remove_orphan(potential);","\"... if we don't get this far, the object stays on the orphan list...\";","\"... orphan list should be checked periodically...\";","return potential;","endif"]},{"name":"add_orphan","owner":36,"perms":173,"preposition":-1,"code":["if (caller == this)","this.orphans = setadd(this.orphans, args[1]);","endif"]},{"name":"remove_orphan","owner":36,"perms":173,"preposition":-1,"code":["if (caller == this)","this.orphans = setremove(this.orphans, args[1]);","endif"]},{"name":"valid","owner":2,"perms":173,"preposition":-1,"code":["\"Usage:  valid(object)\";","\"True if object is valid and not $garbage.\";","return valid(args[1]) && (parent(args[1]) != $garbage);"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","this.orphans = {};","this.history = {};","this.lost_souls = {};","pass();","endif"]},{"name":"resurrect","owner":2,"perms":173,"preposition":-1,"code":["who = caller_perms();","if (!valid(parent = {@args, $garbage}[1]))","return E_INVARG;","elseif (!who.wizard)","return E_PERM;","elseif (typeof(o = renumber($quota_utils:bi_create(parent, $hacker))) == ERR)","\"..death...\";","elseif (parent == $garbage)","$recycler:_recycle(o);","else","o.aliases = {o.name = tostr(\"Resurrectee \", o)};","$wiz_utils:set_owner(o, who);","move(o, who);","endif","reset_max_object();","return o;"]},{"name":"reclaim_lost_souls","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","raise(E_PERM);","endif","fork (1800)","this:(verb)();","endfork","for x in (this.lost_souls)","this.lost_souls = setremove(this.lost_souls, x);","if ((valid(x) && (typeof(x.owner.owned_objects) == LIST)) && (!(x in x.owner.owned_objects)))","x.owner.owned_objects = setadd(x.owner.owned_objects, x);","$quota_utils:summarize_one_user(x.owner);","endif","$command_utils:suspend_if_needed(0);","endfor"]},{"name":"look_self","owner":36,"perms":173,"preposition":-1,"code":["if (prepstr in {\"in\", \"inside\", \"into\"})","recycler = this;","linelen = ((linelen = abs(player.linelen)) < 20) ? 78 | linelen;","intercolumn_gap = 2;","c_width = length(tostr(max_object())) + intercolumn_gap;","n_columns = (linelen + (c_width - 1)) / c_width;","things = $list_utils:sort_suspended(0, this.contents);","header = tostr(this.name, \" (\", this, \") contains:\");","player:tell_lines({header, @$string_utils:columnize_suspended(0, things, n_columns)});","else","return pass(@args);","endif","\"This code contributed by Mickey.\";"]},{"name":"check_quota_scam","owner":2,"perms":173,"preposition":-1,"code":["who = args[1];","if ($quota_utils.byte_based && (is_clear_property(who, \"size_quota\") || is_clear_property(who, \"owned_objects\")))","raise(E_QUOTA);","endif","cheater = 0;","other_cheaters = {};","for x in (this.lost_souls)","if (((valid(x) && ((owner = x.owner) != $hacker)) && (typeof(owner.owned_objects) == LIST)) && (!(x in owner.owned_objects)))","if (owner == who)","who.owned_objects = setadd(who.owned_objects, x);","cheater = 1;","else","\"it's someone else's quota scam we're detecting...\";","other_cheaters = setadd(other_cheaters, owner);","owner.owned_objects = setadd(owner.owned_objects, x);","this.lost_souls = setremove(this.lost_souls, x);","endif","endif","this.lost_souls = setremove(this.lost_souls, x);","endfor","if ($quota_utils.byte_based)","if (cheater)","$quota_utils:summarize_one_user(who);","endif","if (other_cheaters)","fork (0)","for x in (other_cheaters)","$quota_utils:summarize_one_user(x);","endfor","endfork","endif","endif"]},{"name":"gc","owner":36,"perms":173,"preposition":-1,"code":["for x in (this.orphans)","if ((!valid(x)) || ((x.owner != $hacker) && (x in x.owner.owned_objects)))","this.orphans = setremove(this.orphans, x);","endif","endfor"]},{"name":"moveto","owner":36,"perms":173,"preposition":-1,"code":["pass(#-1);"]},{"name":"kill_all_tasks","owner":2,"perms":173,"preposition":-1,"code":["\"kill_all_tasks ( object being recycled )\";","\" -- kill all tasks involving this now-recycled object\";","((caller == this) || (caller == #0)) || raise(E_PERM);","{object} = args;","(typeof(object) == OBJ) || raise(E_INVARG);","fork (0)","for t in (queued_tasks())","for c in (`task_stack(t[1]) ! E_INVARG => {}')","if (object in c)","kill_task(t[1]);","continue t;","endif","endfor","endfor","endfork"]},{"name":"description","owner":2,"perms":173,"preposition":-1,"code":["return (\"Garbage object \" + tostr(this)) + \".\";"]},{"name":"look_self","owner":2,"perms":173,"preposition":-1,"code":["player:tell(this:description());"]},{"name":"title titlec","owner":2,"perms":173,"preposition":-1,"code":["return tostr(\"Recyclable \", this);"]},{"name":"tell","owner":2,"perms":173,"preposition":-1,"code":["return;"]},{"name":"do_examine","owner":2,"perms":13,"preposition":-1,"code":["args[1]:notify(tostr(this, \" is a garbage object, ready for reuse.\"));"]},{"name":"actual","owner":36,"perms":173,"preposition":-1,"code":["if (i = args[1] in {\"noinclude\", \"sender\"})","return {{{\"include\", \"all\"}[i], !args[2]}};","else","return {args};","endif"]},{"name":"parse_@mail","owner":36,"perms":173,"preposition":-1,"code":["\"... we'll take anything...\";","raw = args[2];","if (raw == 1)","\"...+@mail => @mailo=new\";","return {args[1], \"new\"};","else","return args[1..2];","endif"]},{"name":"parse_sticky parse_manymsgs","owner":36,"perms":173,"preposition":-1,"code":["{oname, raw, data} = args;","if (typeof(raw) == LIST)","if (length(raw) > 1)","return \"Too many arguments.\";","endif","raw = raw[1];","elseif (typeof(raw) == INT)","return {oname, raw && ((oname == \"manymsgs\") ? 20 | 1)};","endif","if ((value = $code_utils:toint(raw)) == E_TYPE)","return tostr(\"`\", raw, \"'?  Number expected.\");","endif","return {oname, value};"]},{"name":"parse_replyto","owner":36,"perms":173,"preposition":-1,"code":["{oname, raw, data} = args;","if (typeof(raw) == STR)","raw = $string_utils:explode(raw, \",\");","elseif (typeof(raw) == INT)","return raw ? \"You need to give one or more recipients.\" | {oname, 0};","endif","value = $mail_editor:parse_recipients({}, raw);","if (value)","return {oname, value};","else","return \"No valid recipients in list.\";","endif"]},{"name":"show_manymsgs","owner":36,"perms":173,"preposition":-1,"code":["value = this:get(@args);","if (value)","return {tostr(value), {tostr(\"Query when asking for \", value, \" or more messages.\")}};","else","return {0, {\"Willing to be spammed with arbitrarily many messages/headers\"}};","endif"]},{"name":"show_sticky","owner":36,"perms":173,"preposition":-1,"code":["value = this:get(@args);","if (value)","return {value, {\"Sticky folders:  mail commands default to whatever\", \"mail collection the previous successful command looked at.\"}};","else","return {0, {\"Teflon folders:  mail commands always default to `on me'.\"}};","endif"]},{"name":"show_@mail","owner":36,"perms":173,"preposition":-1,"code":["if (value = this:get(@args))","return {\"\", {tostr(\"Default message sequence for @mail:  \", (typeof(value) == STR) ? value | $string_utils:from_list(value, \" \"))}};","else","default = $mail_agent.(\"player_default_@mail\");","return {0, {tostr(\"Default message sequence for @mail:  \", (typeof(default) == STR) ? default | $string_utils:from_list(default, \" \"))}};","endif"]},{"name":"show_replyto","owner":36,"perms":173,"preposition":-1,"code":["if (value = this:get(@args))","return {\"\", {tostr(\"Default Reply-to:  \", $mail_agent:name_list(@value))}};","else","return {0, {\"No default Reply-to: field\"}};","endif"]},{"name":"show","owner":36,"perms":173,"preposition":-1,"code":["if (o = (name = args[2]) in {\"sender\", \"noinclude\"})","args[2] = {\"all\", \"include\"}[o];","return {@pass(@args), tostr(\"(\", name, \" is a synonym for -\", args[2], \")\")};","else","return pass(@args);","endif"]},{"name":"check_replyto","owner":36,"perms":173,"preposition":-1,"code":["\"... must be object, list of objects, or false...\";","value = args[1];","if (typeof(value) == OBJ)","return {{value}};","elseif (!this:istype(value, {{OBJ}}))","return $string_utils:capitalize(\"Object or list of objects expected.\");","else","return {value};","endif"]},{"name":"show_netmail","owner":2,"perms":173,"preposition":-1,"code":["if (value = this:get(@args))","return {value, {\"Have MOO-mail automatically forwarded to me at\", \"my registered email-address.\"}};","else","return {value, {\"Receive MOO-mail here on the MOO.\"}};","endif","\"Last modified Tue Jun  1 02:10:08 1993 EDT by Edison@OpalMOO (#200).\";"]},{"name":"check_netmail","owner":2,"perms":173,"preposition":-1,"code":["\":check_netmail(value) => Makes sure the email-address is one that can actually be used by $network:sendmail().\";","\"The actual value sent is not checked since it can only be a boolean flag.  The player's email_address property is what is checked.\";","\"Possible situations where the address would be unusable are when the address is invalid or we can't connect to the site to send mail.\";","\"Returns a string error message if unusable or {value} otherwise.\";","if (caller != this)","return E_PERM;","endif","if (args[1] && (reason = $network:email_will_fail($wiz_utils:get_email_address(player))))","return tostr(\"Invalid registered email_address: \", reason);","endif","return args;"]},{"name":"show_expire","owner":36,"perms":173,"preposition":-1,"code":["value = this:get(args[1], \"expire\");","if (value < 0)","return {1, {\"Messages will not expire.\"}};","else","return {value, {tostr(\"Unkept messages expire in \", $time_utils:english_time(value || $mail_agent.player_expire_time), value ? \"\" | \" (default)\")}};","endif"]},{"name":"parse_expire","owner":36,"perms":173,"preposition":-1,"code":["{oname, value, data} = args;","if ((typeof(value) == STR) && index(value, \" \"))","value = $string_utils:explode(value, \" \");","if (!value)","return {oname, 0};","endif","endif","if (value == 1)","return {oname, -1};","elseif (typeof(value) == LIST)","if (length(value) > 1)","nval = $time_utils:parse_english_time_interval(@value);","if (typeof(nval) == ERR)","return \"Time interval should be of a form like \\\"30 days, 10 hours and 43 minutes\\\".\";","else","return {oname, nval};","endif","endif","value = value[1];","endif","if ((nval = $code_utils:toint(value)) || (nval == 0))","return {oname, (nval < 0) ? -1 | nval};","elseif (value == \"Never\")","return {oname, -1};","else","return \"Number, time interval (e.g., \\\"30 days\\\"), or \\\"Never\\\" expected\";","endif"]},{"name":"init_for_core","owner":2,"perms":165,"preposition":-1,"code":["if (caller_perms().wizard)","for x in ({\"fast_check\", \"idle_check\", \"idle_threshold\"})","this:remove_name(x);","for y in ({\"show\", \"check\", \"parse\"})","delete_verb(this, (y + \"_\") + x);","delete_property(this, (y + \"_\") + x);","endfor","endfor","endif"]},{"name":"check_news","owner":36,"perms":173,"preposition":-1,"code":["if ((what = args[1]) in {\"new\", \"contents\", \"all\"})","return {what};","else","return \"Error: `news' option must be one of `new' or `contents' or `all'\";","endif"]},{"name":"parse_news","owner":36,"perms":173,"preposition":-1,"code":["if (typeof(args[2]) == INT)","return tostr(strsub(verb, \"parse_\", \"\"), \" is not a boolean option.\");","else","return {args[1], (typeof(args[2]) == STR) ? args[2] | $string_utils:from_list(args[2], \" \")};","endif"]},{"name":"show_news","owner":36,"perms":173,"preposition":-1,"code":["if ((value = this:get(@args)) == \"all\")","return {value, {\"the `news' command will show all news\"}};","elseif (value == \"contents\")","return {value, {\"the `news' command will show the titles of all articles\"}};","elseif (value == \"new\")","return {value, {\"the `news' command will show only new news\"}};","else","return {0, {\"the `news' command will show all news\"}};","endif"]},{"name":"actual","owner":36,"perms":173,"preposition":-1,"code":["if (i = args[1] in {\"parens\", \"noisy_insert\"})","return {{{\"no_parens\", \"quiet_insert\"}[i], !args[2]}};","else","return {args};","endif"]},{"name":"show","owner":36,"perms":173,"preposition":-1,"code":["if (o = (name = args[2]) in {\"parens\", \"noisy_insert\"})","args[2] = {\"no_parens\", \"quiet_insert\"}[o];","return {@pass(@args), tostr(\"(\", name, \" is a synonym for -\", args[2], \")\")};","else","return pass(@args);","endif"]},{"name":"get","owner":36,"perms":173,"preposition":-1,"code":["\":get(options,name) => returns the value of the option specified by name\";","\"i.e., if {name,value} is present in options, return value\";","\"      if name is present, return 1\";","\"      otherwise return 0\";","{options, name} = args;","if (name in options)","return 1;","elseif (a = $list_utils:assoc(name, options))","return a[2];","else","return 0;","endif"]},{"name":"set","owner":36,"perms":173,"preposition":-1,"code":["\":set(optionlist,oname,value) => revised optionlist or string error message.\";","\"oname must be the full name of an option in .names or .extras.\";","\"Note that values must not be of type ERR.  \";","\"FALSE (0, blank string, or empty list) is always a legal value.\";","\"If a verb :check_foo is defined on this, it will be used to typecheck any\";","\"non-false or object-type value supplied as a new value for option `foo'.\";","\"\";","\"   :check_foo(value) => string error message or {value to use}\";","\"\";","\"If instead there is a property .check_foo, that will give either the expected \";","\"type or a list of allowed types.\";","\"Otherwise, the option is taken to be a boolean flag and all non-false, \";","\"non-object values map to 1.\";","\"\";","{options, oname, value} = args;","if (!((oname in this.names) || (oname in this.extras)))","return \"Unknown option:  \" + oname;","elseif (typeof(value) == ERR)","\"... no option should have an error value...\";","return \"Error value\";","elseif ((!value) && (typeof(value) != OBJ))","\"... always accept FALSE (0, blankstring, emptylist)...\";","elseif ($object_utils:has_callable_verb(this, check = \"check_\" + oname))","\"... a :check_foo verb exists; use it to typecheck the value...\";","if (typeof(c = this:(check)(value)) == STR)","return c;","endif","value = c[1];","elseif ($object_utils:has_property(this, tprop = \"type_\" + oname))","\"... a .type_foo property exists...\";","\"... property value should be a type or list of types...\";","if (!this:istype(value, t = this.(tprop)))","return $string_utils:capitalize(this:desc_type(t) + \" value expected.\");","endif","elseif ($object_utils:has_property(this, cprop = \"choices_\" + oname))","\"... a .choices_foo property exists...\";","\"... property value should be a list of {value,docstring} pairs...\";","if (!$list_utils:assoc(value, c = this.(cprop)))","return tostr(\"Allowed values: \", $string_utils:english_list($list_utils:slice(c, 1), \"(??)\", \" or \"));","endif","else","\"... value is considered to be boolean...\";","if (!value)","\"... must be an object.  oops.\";","return tostr(\"Non-object value expected.\");","endif","value = 1;","endif","\"... We now have oname and a value.  However, if oname is one of the extras,\";","\"... then we need to call :actual to see what it really means.\";","if (oname in this.names)","nvlist = {{oname, value}};","elseif ((typeof(nvlist = this:actual(oname, value)) != LIST) || (!nvlist))","return nvlist || \"Not implemented.\";","endif","\"... :actual returns a list of pairs...\";","for nv in (nvlist)","{oname, value} = nv;","if (i = (oname in options) || $list_utils:iassoc(oname, options))","if ((!value) && (typeof(value) != OBJ))","\"value == 0, blank string, empty list\";","options[i..i] = {};","elseif (value == 1)","options[i] = oname;","else","options[i] = {oname, value};","endif","elseif (value || (typeof(value) == OBJ))","options[1..0] = {(value == 1) ? oname | {oname, value}};","endif","endfor","return options;"]},{"name":"parse","owner":36,"perms":173,"preposition":-1,"code":["\":parse(args[,...]) => {oname [,value]} or string error message\";","\"additional arguments are fed straight through to :parse_* routines.\";","\" <option> <value>     => {option, value}\";","\" <option>=<value>     => {option, value}\";","\" <option> is <value>  => {option, value}\";","\" +<option>            => {option, 1}\";","\" -<option>            => {option, 0}\";","\" !<option>            => {option, 0}\";","\" <option>             => {option}\";","if (!(words = args[1]))","return \"\";","endif","option = words[1];","words[1..1] = {};","if (flag = option && index(\"-+!\", option[1]))","option[1..1] = \"\";","endif","if (i = index(option, \"=\"))","rawval = option[i + 1..$];","option = option[1..i - 1];","if (i == 1)","\"... =bar ...\";","return \"Blank option name?\";","elseif (flag)","\"... +foo=bar\";","return \"Don't give a value if you use +, -, or !\";","elseif (words)","\"... foo=bar junk\";","return $string_utils:from_list(words, \" \") + \"??\";","endif","elseif (!option)","return \"Blank option name?\";","elseif (flag)","if (words)","\"... +foo junk\";","return \"Don't give a value if you use +, -, or !\";","endif","rawval = (flag - 1) % 2;","else","words && ((words[1] == \"is\") && (words[1..1] = {}));","rawval = words;","endif","\"... do we know about this option?...\";","if (!(oname = this:_name(strsub(option, \"-\", \"_\"))))","return tostr((oname == $failed_match) ? \"Unknown\" | \"Ambiguous\", \" option:  \", option);","endif","\"... determine new value...\";","if (!rawval)","\"... `@option foo is' or `@option foo=' ...\";","return (rawval == {}) ? {oname} | {oname, 0};","elseif ($object_utils:has_callable_verb(this, pverb = \"parse_\" + oname))","return this:(pverb)(oname, rawval, args[2..$]);","elseif ($object_utils:has_property(this, cprop = \"choices_\" + oname))","return this:parsechoice(oname, rawval, this.(cprop));","elseif (rawval in {0, \"0\", {\"0\"}})","return {oname, 0};","elseif (rawval in {1, \"1\", {\"1\"}})","return {oname, 1};","else","return tostr(\"Option is a flag, use `+\", option, \"' or `-\", option, \"' (or `!\", option, \"')\");","endif"]},{"name":"_name","owner":36,"perms":173,"preposition":-1,"code":["\":_name(string) => full option name corresponding to string \";","\"               => $failed_match or $ambiguous_match as appropriate.\";","if (((string = args[1]) in this.names) || (string in this.extras))","return string;","endif","char = (namestr = this._namelist)[1];","if (!(i = index(namestr, char + string)))","return $failed_match;","elseif (i != rindex(namestr, char + string))","return $ambiguous_match;","else","j = index(namestr[i + 1..$], char);","return namestr[i + 1..(i + j) - 1];","endif"]},{"name":"add_name","owner":36,"perms":173,"preposition":-1,"code":["\":add_name(name[,isextra]) adds name to the list of options recognized.\";","\"name must be a nonempty string and must not contain spaces, -, +, !, or =.\";","\"isextra true means that name isn't an actual option (recognized by :get) but merely a name that the option setting command should recognize to set a particular combination of options.  Actual options go in .names; others go in .extras\";","{name, ?isextra = 0} = args;","if (!$perm_utils:controls(caller_perms(), this))","return E_PERM;","elseif ((!name) || match(name, \"[-!+= ]\"))","\"...name is blank or contains a forbidden character\";","return E_INVARG;","elseif (name in this.names)","\"...name is already in option list\";","if (isextra)","this.names = setremove(this.names, name);","this.extras = setadd(this.extras, name);","return 1;","else","return 0;","endif","elseif (name in this.extras)","if (isextra)","return 0;","else","this.names = setadd(this.names, name);","this.extras = setremove(this.extras, name);","return 1;","endif","else","char = this._namelist[1];","if (isextra)","this.extras = setadd(this.extras, name);","else","this.names = setadd(this.names, name);","endif","if (!index(this._namelist, (char + name) + char))","this._namelist = tostr(this._namelist, name, char);","endif","return 1;","endif"]},{"name":"remove_name","owner":36,"perms":173,"preposition":-1,"code":["\":remove_name(name) removes name from the list of options recognized.\";","if (!$perm_utils:controls(caller_perms(), this))","return E_PERM;","elseif (!(((name = args[1]) in this.names) || (name in this.extras)))","\"...hmm... already gone...\";","return 0;","else","char = this._namelist[1];","this._namelist = strsub(this._namelist, (char + name) + char, char);","this.names = setremove(this.names, name);","this.extras = setremove(this.extras, name);","return 1;","endif"]},{"name":"show","owner":36,"perms":173,"preposition":-1,"code":["\":show(options,name or list of names)\";","\" => text describing current value of option and what it means\";","name = args[2];","if (typeof(name) == LIST)","text = {};","for n in (name)","text = {@text, @this:show(@listset(args, n, 2))};","endfor","return text;","elseif (!((name in this.names) || (name in this.extras)))","return {\"Unknown option:  \" + name};","elseif ($object_utils:has_callable_verb(this, sverb = \"show_\" + name))","r = this:(sverb)(@args);","value = r[1];","desc = r[2];","elseif ($object_utils:has_property(this, sverb) && ((value = this:get(args[1], name)) in {0, 1}))","desc = this.(sverb)[value + 1];","if (typeof(desc) == STR)","desc = {desc};","endif","elseif ($object_utils:has_property(this, cprop = \"choices_\" + name))","if (!(value = this:get(args[1], name)))","desc = this.(cprop)[1][2];","elseif (!(a = $list_utils:assoc(value, this.(cprop))))","return {(name + \" has unexpected value \") + toliteral(value)};","else","desc = a[2];","endif","elseif (name in this.extras)","return {name + \" not documented (complain)\"};","else","value = this:get(args[1], name);","desc = {\"not documented (complain)\"};","if (typeof(value) in {LIST, STR})","desc[1..0] = toliteral(value);","value = \"\";","endif","endif","if (value in {0, 1})","which = \"-+\"[value + 1] + name;","elseif ((typeof(value) in {OBJ, STR, INT}) && (value != \"\"))","which = tostr(\" \", name, \"=\", value);","else","which = \" \" + name;","endif","show = {$string_utils:left(which + \"  \", this.namewidth) + desc[1]};","for i in [2..length(desc)]","show = {@show, $string_utils:space(this.namewidth) + desc[i]};","endfor","return show;"]},{"name":"actual","owner":36,"perms":173,"preposition":-1,"code":["\":actual(<name>,<value>) => list of {<name>,<value>} pairs or string errormsg\";","\" corresponding to what setting option <name> to <value> actually means\";","\" e.g., :actual(\\\"unfoo\\\",1) => {{\\\"foo\\\",0}}\";","\" e.g., :actual(\\\"g7mode\\\",1) => {{\\\"splat\\\",37},{\\\"baz\\\",#3}}\";","return \"Not implemented.\";"]},{"name":"istype","owner":36,"perms":173,"preposition":-1,"code":["\":istype(value,types) => whether value is one of the given types\";","if ((vtype = typeof(value = args[1])) in (types = args[2]))","return 1;","elseif (vtype != LIST)","return 0;","else","for t in (types)","if ((typeof(t) == LIST) && this:islistof(value, t))","return 1;","endif","endfor","endif","return 0;"]},{"name":"islistof","owner":36,"perms":173,"preposition":-1,"code":["\":islistof(value,types) => whether value (a list) has each element being one of the given types\";","types = args[2];","for v in (value = args[1])","if (!this:istype(v, types))","return 0;","endif","endfor","return 1;"]},{"name":"desc_type","owner":36,"perms":173,"preposition":-1,"code":["\":desc_type(types) => string description of types\";","nlist = {};","for t in (types = args[1])","if (typeof(t) == LIST)","if (length(t) > 1)","nlist = {@nlist, tostr(\"(\", this:desc_type(t), \")-list\")};","else","nlist = {@nlist, tostr(this:desc_type(t), \"-list\")};","endif","elseif (t in {INT, OBJ, STR, LIST})","nlist = {@nlist, {\"number\", \"object\", \"string\", \"?\", \"list\"}[t + 1]};","else","return \"Bad type list\";","endif","endfor","return $string_utils:english_list(nlist, \"nothing\", \" or \");"]},{"name":"parsechoice","owner":36,"perms":173,"preposition":-1,"code":["\":parsechoice(oname,rawval,assoclist)\";","which = {};","oname = args[1];","rawval = args[2];","choices = $list_utils:slice(args[3], 1);","errmsg = tostr(\"Allowed values for this flag: \", $string_utils:english_list(choices, \"(??)\", \" or \"));","if (typeof(rawval) == LIST)","if (length(rawval) > 1)","return errmsg;","endif","rawval = rawval[1];","elseif (typeof(rawval) != STR)","return errmsg;","endif","for c in (choices)","if (index(c, rawval) == 1)","which = {@which, c};","endif","endfor","if (!which)","return errmsg;","elseif (length(which) > 1)","return tostr(rawval, \" is ambiguous.\");","else","return {oname, which[1]};","endif"]},{"name":"raise","owner":36,"perms":173,"preposition":-1,"code":["raise(@args);","\"this:(this.names[tonum(args[1]) + 1])()\";"]},{"name":"E_NONE","owner":36,"perms":173,"preposition":-1,"code":["\"... hmmm... don't know how to raise E_NONE...\";","return E_NONE;"]},{"name":"E_TYPE","owner":36,"perms":173,"preposition":-1,"code":["\"...raise E_TYPE ...\";","1[2];"]},{"name":"E_DIV","owner":36,"perms":173,"preposition":-1,"code":["\"...raise E_DIV ...\";","1 / 0;"]},{"name":"E_PERM","owner":36,"perms":173,"preposition":-1,"code":["\"...raise E_PERM ...\";","this.owner.password;"]},{"name":"E_PROPNF","owner":36,"perms":173,"preposition":-1,"code":["\"...raise E_PROPNF ...\";","this.a;"]},{"name":"E_VERBNF","owner":36,"perms":173,"preposition":-1,"code":["\"...raise E_VERBNF ...\";","this:a();"]},{"name":"E_VARNF","owner":36,"perms":173,"preposition":-1,"code":["\"...raise E_VARNF ...\";","a;"]},{"name":"E_INVIND","owner":36,"perms":173,"preposition":-1,"code":["\"...raise E_INVIND ...\";","#-1.a;"]},{"name":"E_RECMOVE","owner":36,"perms":173,"preposition":-1,"code":["move(this, this);"]},{"name":"E_MAXREC","owner":36,"perms":173,"preposition":-1,"code":["\"...raise E_MAXREC ...\";","this:(verb)();"]},{"name":"E_RANGE","owner":36,"perms":173,"preposition":-1,"code":["\"...raise E_RANGE ...\";","{}[1];"]},{"name":"E_ARGS","owner":36,"perms":173,"preposition":-1,"code":["\"...raise E_ARGS ...\";","toint();"]},{"name":"E_NACC","owner":36,"perms":173,"preposition":-1,"code":["\"...raise E_NACC ...\";","move($hacker, this);"]},{"name":"E_INVARG","owner":36,"perms":173,"preposition":-1,"code":["\"...raise E_INVARG ...\";","parent(#-1);"]},{"name":"E_QUOTA","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms($no_one);","\"...raise E_QUOTA ...\";","create($thing);"]},{"name":"accept","owner":36,"perms":173,"preposition":-1,"code":["return 0;"]},{"name":"name","owner":36,"perms":173,"preposition":-1,"code":["return toliteral(args[1]);","\"return this.names[tonum(args[1]) + 1];\";"]},{"name":"toerr","owner":36,"perms":173,"preposition":-1,"code":["\"toerr -- given a string or a number, return the corresponding ERR.\";","\"If not found or an execution error, return -1.\";","if (typeof(string = args[1]) == STR)","for e in (this.all_errors)","if (tostr(e) == string)","return e;","endif","endfor","elseif (typeof(number = args[1]) == INT)","for e in (this.all_errors)","if (toint(e) == number)","return e;","endif","endfor","endif","return -1;"]},{"name":"match_error","owner":36,"perms":173,"preposition":-1,"code":["\"match_error -- searches for tostr(E_WHATEVER) in a string, returning the ERR, returns -1 if no error string is found.\";","string = args[1];","for e in (this.all_errors)","if (index(string, tostr(e)))","return e;","endif","endfor","return -1;"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","while ($object_utils:defines_verb(this, \"secret_SHHH\"))","delete_verb(this, \"secret_SHHH\");","endwhile","pass();","\"this:rm_message_seq({1, 1 + this:length_all_msgs()})\";","\"this:expunge_rmm()\";","for p in (properties(this))","$command_utils:suspend_if_needed(0);","if (p && (p[1] == \" \"))","delete_property(this, p);","endif","endfor","this.messages = this.messages_going = {};","this.mail_forward = {};","this.mail_notify = {player};","player.current_message = {@player.current_message, {this, 0, 0}};","for p in ({\"moderator_forward\", \"moderator_notify\", \"writers\", \"readers\", \"expire_period\", \"last_used_time\"})","this.(p) = $mail_recipient.(p);","endfor","this.moderated = 1;","else","return E_PERM;","endif"]},{"name":"look_self","owner":71,"perms":173,"preposition":-1,"code":["player:tell_lines(this:description());","player:tell($string_utils:pronoun_sub(\"%S %<is> moving around from room to room, cleaning up.\", this));"]},{"name":"cleanup","owner":71,"perms":173,"preposition":-1,"code":["\"$housekeeper:cleanup([insist]) => clean up player's objects. Argument is 'up' or 'up!' for manually requested cleanups (notify player differently)\";","if (caller_perms() != this)","return E_PERM;","endif","for object in (this.clean)","x = object in this.clean;","if (this.requestors[x] == player)","if (result = this:replace(object, @args))","player:tell(result, \".\");","endif","endif","$command_utils:suspend_if_needed(0);","endfor","player:tell(\"The housekeeper has finished cleaning up your objects.\");"]},{"name":"replace","owner":71,"perms":173,"preposition":-1,"code":["\"replace the object given to its proper spot (if there is one).\";","{object, ?insist = 0} = args;","i = object in this.clean;","if (!i)","return tostr(object, \" is not on the \", this.name, \"'s cleanup list\");","endif","place = this.destination[i];","if (!(($recycler:valid(object) && ($recycler:valid(place) || (place == #-1))) && (!(object.location in this.recycle_bins))))","\"object no longer valid (recycled or something), remove it.\";","this.clean = listdelete(this.clean, i);","this.requestors = listdelete(this.requestors, i);","this.destination = listdelete(this.destination, i);","return tostr(object) + \" is no longer valid, removed from cleaning list\";","endif","oldloc = loc = object.location;","if (object.location == place)","\"already in its place\";","return \"\";","endif","requestor = this.requestors[i];","if (insist != \"up!\")","if ($code_utils:verb_or_property(object, \"in_use\"))","return (\"Not returning \" + object.name) + \" because it claims to be in use\";","endif","for thing in (object.contents)","if (thing:is_listening())","return (((\"Not returning \" + object.name) + \" because \") + thing.name) + \" is inside\";","endif","$command_utils:suspend_if_needed(0);","endfor","if (valid(loc) && (loc != $limbo))","if (loc:is_listening())","return (((\"Not returning \" + object.name) + \" because \") + loc.name) + \" is holding it\";","endif","for y in (loc:contents())","if ((y != object) && y:is_listening())","return ((((\"Not returning \" + object.name) + \" because \") + y.name) + \" is in \") + loc.name;","endif","$command_utils:suspend_if_needed(0);","endfor","endif","endif","if (valid(place) && (!place:acceptable(object)))","return (place.name + \" won't accept \") + object.name;","endif","try","requestor:tell(\"As you requested, the housekeeper tidies \", $string_utils:nn(object), \" from \", $string_utils:nn(loc), \" to \", $string_utils:nn(place), \".\");","if ($object_utils:has_verb(loc, \"announce_all_but\"))","loc:announce_all_but({requestor, object}, \"At \", requestor.name, \"'s request, the \", this.name, \" sneaks in, picks up \", object.name, \" and hurries off to put \", ($object_utils:has_property(object, \"po\") && (typeof(object.po) == STR)) ? object.po | \"it\", \" away.\");","endif","except (ANY)","\"Ignore errors\";","endtry","this:moveit(object, place, requestor);","if ((loc = object.location) == oldloc)","return (object.name + \" wouldn't go; \") + ((!place:acceptable(object)) ? (\" perhaps \" + $string_utils:nn(place)) + \" won't let it in\" | ((\" perhaps \" + $string_utils:nn(loc)) + \" won't let go of it\"));","endif","try","object:tell(\"The housekeeper puts you away.\");","if ($object_utils:isa(loc, $room))","loc:announce_all_but({object}, \"At \", requestor.name, \"'s request, the housekeeper sneaks in, deposits \", object:title(), \" and leaves.\");","else","loc:tell(\"You notice the housekeeper sneak in, give you \", object:title(), \" and leave.\");","endif","except (ANY)","\"Ignore errors\";","endtry","return \"\";"]},{"name":"cleanup_list","owner":71,"perms":29,"preposition":-1,"code":["if (args)","if (!valid(who = args[1]))","return;","endif","player:tell(who.name, \"'s personal cleanup list:\");","else","who = 0;","player:tell(\"Housekeeper's complete cleanup list:\");","endif","player:tell(\"------------------------------------------------------------------\");","printed_anything = 0;","objs = this.clean;","reqs = this.requestors;","dest = this.destination;","for i in [1..length(objs)]","$command_utils:suspend_if_needed(2);","req = reqs[i];","ob = objs[i];","place = dest[i];","if (((who == 0) || (req == who)) || (ob.owner == who))","if (!valid(ob))","player:tell($string_utils:left(tostr(ob), 7), $string_utils:left(\"** recycled **\", 50), \"(\", req.name, \")\");","else","player:tell($string_utils:left(tostr(ob), 7), $string_utils:left(ob.name, 26), \"=>\", $string_utils:left(tostr(place), 7), place.name || \"nowhere\", \" (\", req.name, \")\");","endif","printed_anything = 1;","endif","endfor","if (!printed_anything)","player:tell(\"** The housekeeper has nothing in the cleanup list.\");","endif","player:tell(\"------------------------------------------------------------------\");"]},{"name":"add_cleanup","owner":71,"perms":93,"preposition":-2,"code":["if (!$perm_utils:controls(caller_perms(), this))","return E_PERM;","endif","{what, ?who = player, ?where = what.location} = args;","if ((what < #1) || (!valid(what)))","return \"invalid object\";","endif","if ($object_utils:isa(who, $guest))","return tostr(\"Guests can't use the \", this.name, \".\");","endif","if (!is_player(who))","return tostr(\"Non-players can't use the \", this.name, \".\");","endif","if (!valid(where))","return tostr(\"The \", this.name, \"doesn't know how to find \", where, \" in order to put away \", what.name, \".\");","endif","if (is_player(what))","return (\"The \" + this.name) + \" doesn't do players, except to cart them home when they fall asleep.\";","endif","for x in (this.eschews)","if ($object_utils:isa(what, x[1]))","ok = 0;","for y in [3..length(x)]","if ($object_utils:isa(what, x[y]))","ok = 1;","endif","endfor","if (!ok)","return tostr(\"The \", this.name, \" doesn't do \", x[2], \"!\");","endif","endif","endfor","if ($object_utils:has_callable_verb(where, \"litterp\") ? where:litterp(what) | ((where in this.public_places) && (!(what in where.residents))))","return tostr(\"The \", this.name, \" won't litter \", where.name, \"!\");","endif","if (i = what in this.clean)","if ((!this:controls(i, who)) && valid(this.destination[i]))","return tostr(this.requestors[i].name, \" already asked that \", what.name, \" be kept at \", this.destination[i].name, \"!\");","endif","this.requestors[i] = who;","this.destination[i] = where;","else","this.clean = {what, @this.clean};","this.requestors = {who, @this.requestors};","this.destination = {where, @this.destination};","endif","return tostr(\"The \", this.name, \" will keep \", what.name, \" (\", what, \") at \", valid(where) ? ((where.name + \" (\") + tostr(where)) + \")\" | where, \".\");"]},{"name":"remove_cleanup","owner":71,"perms":29,"preposition":-1,"code":["if (!$perm_utils:controls(caller_perms(), this))","return E_PERM;","endif","{what, ?who = player} = args;","if (i = what in this.clean)","if (!this:controls(i, who))","return tostr(\"You may remove an object from \", this.name, \" list only if you own the object, the place it is kept, or if you placed the original cleaning order.\");","endif","this.clean = listdelete(this.clean, i);","this.destination = listdelete(this.destination, i);","this.requestors = listdelete(this.requestors, i);","return tostr(what.name, \" (\", what, \") removed from cleanup list.\");","else","return tostr(what.name, \" not in cleanup list.\");","endif"]},{"name":"controls","owner":71,"perms":173,"preposition":-1,"code":["\"does player control entry I?\";","{i, who} = args;","if ((who in {this.owner, @this.owners}) || who.wizard)","return \"Yessir.\";","endif","cleanable = this.clean[i];","if (this.requestors[i] == who)","return \"you asked for the previous result, you can change this one.\";","elseif (((who == cleanable.owner) || (!valid(dest = this.destination[i]))) || (who == dest.owner))","return \"you own the object or the place where it is being cleaned to, or the destination is no longer valid.\";","else","return \"\";","endif"]},{"name":"continuous","owner":71,"perms":173,"preposition":-1,"code":["\"start the housekeeper cleaning continuously. Kill any previous continuous\";","\"task. Not meant to be called interactively.\";","if (!$perm_utils:controls(caller_perms(), this))","return E_PERM;","endif","if ($code_utils:task_valid(this.task))","taskn = this.task;","this.task = 0;","kill_task(taskn);","endif","fork taskn (0)","while (1)","index = 1;","while (index < length(this.clean))","x = this.clean[index];","index = index + 1;","try","this:replace(x);","except id (ANY)","endtry","suspend(this.testing ? 2 | this:time());","endwhile","suspend(5);","this:litterbug();","endwhile","endfork","this.task = taskn;"]},{"name":"litterbug","owner":71,"perms":173,"preposition":-1,"code":["for room in (this.public_places)","for thingy in (room.contents)","suspend(10);","if (((thingy.location == room) && this:is_litter(thingy)) && (!this:is_watching(thingy, $nothing)))","\"if it is litter and no-one is watching\";","fork (0)","this:send_home(thingy);","endfork","suspend(0);","endif","endfor","endfor"]},{"name":"is_watching","owner":71,"perms":173,"preposition":-1,"code":["return valid(thing = args[1]) && thing:is_listening();"]},{"name":"send_home","owner":71,"perms":173,"preposition":-1,"code":["if (caller != this)","return E_PERM;","endif","litter = args[1];","littering = litter.location;","this:ejectit(litter, littering);","home = litter.location;","if ($object_utils:isa(home, $room))","home:announce_all(\"The \", this.name, \" sneaks in, deposits \", litter:title(), \" and leaves.\");","else","home:tell(\"You notice the \", this.name, \" sneak in, give you \", litter:title(), \" and leave.\");","endif","if ($object_utils:has_callable_verb(littering, \"announce_all_but\"))","littering:announce_all_but({litter}, \"The \", this.name, \" sneaks in, picks up \", litter:title(), \" and rushes off to put it away.\");","endif"]},{"name":"moveit","owner":2,"perms":173,"preposition":-1,"code":["\"Wizardly verb to move object with requestor's permission\";","if (caller != this)","return E_PERM;","else","set_task_perms(player = args[3]);","return args[1]:moveto(args[2]);","endif"]},{"name":"ejectit","owner":2,"perms":173,"preposition":-1,"code":["\"this:ejectit(object,room): Eject args[1] from args[2].  Callable only by housekeeper's quarters verbs.\";","if (caller == this)","args[2]:eject(args[1]);","endif"]},{"name":"is_object_cleaned","owner":71,"perms":173,"preposition":-1,"code":["what = args[1];","if (!(where = what in this.clean))","return 0;","else","return {this.destination[where], this.requestors[where]};","endif"]},{"name":"is_litter","owner":71,"perms":173,"preposition":-1,"code":["thingy = args[1];","for x in (this.litter)","if ($object_utils:isa(thingy, x[1]) && (!$object_utils:isa(thingy, x[2])))","return 1;","endif","endfor","return 0;"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","this.password = \"Impossible password to type\";","this.last_password_time = 0;","this.litter = {};","this.public_places = {};","this.requestors = {};","this.destination = {};","this.clean = {};","this.eschews = {};","this.recycle_bins = {};","this.cleaning = #-1;","this.task = 0;","this.owners = {#2};","this.mail_forward = {#2};","this.player_queue = {};","this.move_player_task = 0;","this.moveto_task = 0;","pass(@args);","endif"]},{"name":"clean_status","owner":71,"perms":173,"preposition":-1,"code":["count = 0;","for i in (this.requestors)","if (i == player)","count = count + 1;","endif","$command_utils:suspend_if_needed(1);","endfor","player:tell(\"Number of items in cleanup list: \", tostr(length(this.clean)));","player:tell(\"Number of items you requested to be tidied: \", tostr(count));","player:tell(\"Number of requestors: \", tostr(length($list_utils:remove_duplicates(this.requestors))));","player:tell(\"Time to complete one cleaning circuit: \", $time_utils:english_time(length(this.clean) * this:time()));"]},{"name":"is_cleaning","owner":71,"perms":173,"preposition":-1,"code":["\"return a string status if the hosuekeeper is cleaning this object\";","cleanable = args[1];","info = this:is_object_cleaned(cleanable);","if (info == 0)","return tostr(cleanable.name, \" is not cleaned by the \", this.name, \".\");","else","return tostr(cleanable.name, \" is kept tidy at \", info[1].name, \" (\", info[1], \") at \", info[2].name, \"'s request.\");","endif"]},{"name":"time","owner":71,"perms":173,"preposition":-1,"code":["\"Returns the amount of time to suspend between objects while continuous cleaning.\";","\"Currently set to try to complete cleaning circuit in one hour, but not exceed one object every 20 seconds.\";","return max(20 + $login:current_lag(), length(this.clean) ? 3600 / length(this.clean) | 0);"]},{"name":"acceptable","owner":2,"perms":173,"preposition":-1,"code":["return caller == this;"]},{"name":"move_players_home","owner":2,"perms":173,"preposition":-1,"code":["if (!$perm_utils:controls(caller_perms(), this))","\"perms don't control the $housekeeper; probably not called by $room:disfunc then. Used to let args[1] call this. No longer.\";","return E_PERM;","endif","this.player_queue = {@this.player_queue, {args[1], time() + 300}};","if ($code_utils:task_valid(this.move_player_task))","\"the move-players-home task is already running\";","return;","endif","fork tid (10)","while (this.player_queue)","if ((mtime = this.player_queue[1][2]) < (time() + 10))","who = this.player_queue[1][1];","\"Remove from queue first so that if they do something malicious, like put a kill_task in a custom :accept_for_abode, they won't be in the queue when the task restarts with the next player disconnect. Ho_Yan 12/3/98\";","this.player_queue = listdelete(this.player_queue, 1);","if (is_player(who) && (!$object_utils:connected(who)))","dest = `who.home:accept_for_abode(who) ! ANY => 0' ? who.home | $player_start;","if (who.location != dest)","player = who;","this:move_em(who, dest);","endif","endif","else","suspend(mtime - time());","endif","$command_utils:suspend_if_needed(1);","endwhile","endfork","this.move_player_task = tid;"]},{"name":"move_em","owner":2,"perms":173,"preposition":-1,"code":["if (caller == this)","{who, dest} = args;","set_task_perms(who);","fork (0)","fork (0)","\"This is forked so that it's protected from aborts due to errors in the player's :moveto verb.\";","if (who.location != dest)","\"Unfortunately, if who is -already- at $player_start, move() won't call :enterfunc and the sleeping body never goes to $limbo. Have to call explicitly for that case. Ho_Yan 11/2/95\";","if (who.location == $player_start)","$player_start:enterfunc(who);","else","move(who, $player_start);","endif","endif","endfork","start = who.location;","this:set_moveto_task();","who:moveto(dest);","if (who.location != start)","start:announce(this:take_away_msg(who));","endif","if (who.location == dest)","dest:announce(this:drop_off_msg(who));","endif","endfork","else","return E_PERM;","endif"]},{"name":"take_away_msg drop_off_msg","owner":71,"perms":173,"preposition":-1,"code":["return $string_utils:pronoun_sub(this.(verb), args[1], this);"]},{"name":"set_moveto_task","owner":71,"perms":173,"preposition":-1,"code":["\"sets $housekeeper.moveto_task to the current task_id() so player:moveto's can check for validity.\";","if (caller != this)","return E_PERM;","endif","this.moveto_task = task_id();"]},{"name":"parse_address","owner":2,"perms":173,"preposition":-1,"code":["\"Given an email address, return {userid, site}.\";","\"Valid addresses are of the form `userid[@site]'.\";","\"At least for now, if [@site] is left out, site will be returned as blank.\";","\"Should be a default address site, or something, somewhere.\";","address = args[1];","return (at = index(address, \"@\")) ? {address[1..at - 1], address[at + 1..$]} | {address, \"\"};"]},{"name":"local_domain","owner":2,"perms":173,"preposition":-1,"code":["\"given a site, try to figure out what the `local' domain is.\";","\"if site has a @ or a % in it, give up and return E_INVARG.\";","\"blank site is returned as is; try this:local_domain(this.localhost) for the answer you probably want.\";","site = args[1];","if (index(site, \"@\") || index(site, \"%\"))","return E_INVARG;","elseif (match(site, \"^[0-9.]+$\"))","return E_INVARG;","elseif (!site)","return \"\";","elseif (!(dot = rindex(site, \".\")))","dot = rindex(site = this.site, \".\");","endif","if ((!dot) || (!(dot = rindex(site[1..dot - 1], \".\"))))","return site;","else","domain = site[dot + 1..$];","site = site[1..dot - 1];","while (site && (domain in this.large_domains))","if (dot = rindex(site, \".\"))","domain = tostr(site[dot + 1..$], \".\", domain);","site = site[1..dot - 1];","else","return tostr(site, \".\", domain);","endif","endwhile","return domain;","endif"]},{"name":"open","owner":2,"perms":173,"preposition":-1,"code":["\":open(address, port, [connect-connection-to])\";","\"Open a network connection to address/port.  If the connect-connection-to is passed, then the connection will be connected to that object when $login gets ahold of it.  If not, then the connection is just ignored by $login, i.e. not bothered by it with $welcome_message etc.\";","\"The object specified by connect-connection-to has to be a player (though it need not be a $player).\";","\"Returns the (initial) connection or an error, as in open_network_connection\";","if (!this:trust(caller_perms()))","return E_PERM;","endif","address = args[1];","port = args[2];","if (length(args) < 3)","connect_to = $nothing;","elseif ((typeof(connect_to = args[3]) == OBJ) && (valid(connect_to) && is_player(connect_to)))","if (!$perm_utils:controls(caller_perms(), connect_to))","return E_PERM;","endif","else","return E_INVARG;","endif","if (typeof(connection = `open_network_connection(address, port) ! ANY') != ERR)","if (valid(connect_to))","this.connect_connections_to = {@this.connect_connections_to, {connection, connect_to}};","endif","endif","return connection;"]},{"name":"close","owner":2,"perms":173,"preposition":-1,"code":["if (!this:trust(caller_perms()))","return E_PERM;","endif","con = args[1];","if (!index(`connection_name(con) ! ANY => \"\"', \" to \"))","return E_INVARG;","endif","boot_player(con);","if (i = $list_utils:iassoc(con, $network.connect_connections_to))","$network.connect_connections_to = listdelete($network.connect_connections_to, i);","endif","return 1;"]},{"name":"sendmail","owner":2,"perms":29,"preposition":-1,"code":["\"sendmail(to, subject, line1, line2, ...)\";","\"  sends mail to internet address 'to', with given subject.\";","\"  It fills in various fields, such as date, from (from player), etc.\";","\"  the rest of the arguments are remaining lines of the message, and may begin with additional header fields.\";","\"  (must match RFC822 specification).\";","\"Requires $network.trust to call (no anonymous mail from MOO).\";","\"Returns 0 if successful, or else error condition or string saying why not.\";","if (!this:trust(caller_perms()))","return E_PERM;","endif","mooname = this.MOO_name;","mooinfo = tostr(mooname, \" (\", this.site, \" \", this.port, \")\");","if (reason = this:invalid_email_address(to = args[1]))","return reason;","endif","\"took out Envelope-from:  + this.errors_to_address\";","return this:raw_sendmail(to, \"Date: \" + ctime(), \"From: \" + this:return_address_for(player), \"To: \" + to, \"Subject: \" + args[2], \"Errors-to: \" + this.errors_to_address, \"X-Mail-Agent: \" + mooinfo, @args[3..$]);"]},{"name":"trust","owner":2,"perms":173,"preposition":-1,"code":["return (who = args[1]).wizard || (who in this.trusts);"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","pass(@args);","this.active = 0;","this.errors_to_address = \"moomailerrors@yourhost\";","this.site = \"yoursite\";","this.postmaster = \"postmastername@yourhost\";","this.usual_postmaster = \"postmastername@yourhost\";","this.password_postmaster = \"postmastername@yourhost\";","this.envelope_from = \"postmastername@yourhost\";","this.blank_envelope = 0;","this.MOO_name = \"YourMOO\";","this.maildrop = \"localhost\";","this.port = 7777;","this.large_domains = {};","this.trusts = {$hacker};","this.connect_connections_to = {};","endif"]},{"name":"raw_sendmail","owner":2,"perms":29,"preposition":-1,"code":["\"Copied from sendmail fix (#88079):raw_sendmail by Lineman (#108318) Mon Feb  1 19:29:43 1999 PST\";","\"rawsendmail(to, @lines)\";","\"sends mail without processing. Returns 0 if successful, or else reason why not.\";","if (!caller_perms().wizard)","return E_PERM;","endif","if (!this.active)","return \"Networking is disabled.\";","endif","if (typeof(this.debugging) == LIST)","\"who to notify\";","debugging = this.debugging;","else","\"notify this owner\";","debugging = this.debugging && {this.owner};","endif","address = args[1];","body = listdelete(args, 1);","data = {\"HELO \" + this.site, (\"MAIL FROM:<\" + this.postmaster) + \">\", (\"RCPT TO:<\" + address) + \">\", \"DATA\"};","blank = 0;","for x in (body)","this:suspend_if_needed(0);","if (!(blank || match(x, \"[a-z0-9-]*: \")))","if (x)","data = {@data, \"\"};","endif","blank = 1;","endif","data = {@data, (x && (x[1] == \".\")) ? \".\" + x | x};","endfor","data = {@data, \".\", \"QUIT\", \"\"};","suspend(0);","target = $network:open(this.maildrop, 25);","if (typeof(target) == ERR)","return tostr(\"Cannot open connection to maildrop \", this.maildrop, \": \", target);","endif","set_connection_option(target, \"hold-input\", 1);","blast = 0;","msg = 0;","expects = {\"220\", \"250\", \"250\", \"250%|251\", \"354\", \"250\", \"221\"};","for line in (data)","if (!blast)","reply = this:tcp_wait(target);","if (typeof(reply) == ERR)","msg = \"Connection dropped or timed out.\";","break;","elseif (!match(reply[1..3], expects[1]))","msg = ((\"Expected \" + expects[1]) + \" but got \") + reply;","break;","endif","debugging && notify(debugging[1], \"GET: \" + reply);","expects[1..1] = {};","if (reply[1..3] == \"221\")","\"Service closing transmission channel\";","break;","elseif (reply[1..3] == \"354\")","\"Start mail input; end with <CRLF>.<CRLF>\";","blast = 1;","endif","elseif (line == \".\")","blast = 0;","endif","debugging && notify(debugging[1], \"SEND:\" + line);","notify(target, line);","((ticks_left() < 4000) || (seconds_left() < 2)) && suspend(0);","endfor","$network:close(target);","debugging && notify(debugging[1], \"EXIT:\" + (msg || \"Mail sent successfully.\"));","return msg;"]},{"name":"invalid_email_address","owner":2,"perms":173,"preposition":-1,"code":["\"invalid_email_address(email) -- check to see if email looks like a valid email address. Return reason why not.\";","address = args[1];","if (!address)","return \"no email address supplied\";","endif","if (!(at = rindex(address, \"@\")))","return (\"'\" + address) + \"' doesn't look like a valid internet email address\";","endif","name = address[1..at - 1];","host = address[at + 1..$];","if (match(name, \"^in%%\") || match(name, \"^smtp%%\"))","return tostr(\"'\", name, \"' doesn't look like a valid username (try removing the 'in%' or 'smtp%')\");","endif","if (!match(host, $network.valid_host_regexp))","return tostr(\"'\", host, \"' doesn't look like a valid internet host\");","endif","if (!match(name, $network.valid_email_regexp))","return tostr(\"'\", name, \"' doesn't look like a valid user name for internet mail\");","endif","return \"\";"]},{"name":"invalid_hostname","owner":2,"perms":173,"preposition":-1,"code":["return match(args[1], this.valid_host_regexp) ? \"\" | tostr(\"'\", args[1], \"' doesn't look like a valid internet host name\");"]},{"name":"email_will_fail","owner":2,"perms":173,"preposition":-1,"code":["\":email_will_fail(email-address[, display?]) => Makes sure the email-address is one that can actually be used by $network:sendmail().\";","{email, ?display = 0} = args;","reason = this:invalid_email_address(email);","if (reason && display)","player:tell(\"Invalid email address: \", reason);","endif","return reason;","\"following is code from OpalMOO, not used here\";","\"Possible situations where the address would be unusable are when the address is invalid or we can't connect to the site to send mail.\";","\"If <display> is true, error messages are displayed to the player and 1 is returned when address is unuable.  If <display> is false and address is unusable, the error message is returned.  If the address is usable, 0 is always returned.\";","if (!this:approved_for_network(caller_perms()))","return E_PERM;","endif","if (!this:valid_email_address(email))","msg = tostr(\"Your email address (\", email, \") is not a usable account.\");","elseif ((result = this:verify_email_address(email)) == E_INVARG)","msg = tostr(\"Unable to connect to \", this:parse_address(email)[2], \".\");","elseif (typeof(result) == STR)","msg = tostr(\"The site \", (parse = this:parse_address(email))[2], \" does not recognize \", parse[1], \" as a valid account.\");","else","return 0;","endif","if (display)","player:tell(msg);","return 1;","else","return msg;","endif","\"Last modified Tue Jun 15 00:19:01 1993 EDT by Ranma (#200).\";"]},{"name":"read","owner":2,"perms":173,"preposition":-1,"code":["\"for trusted players, they can read from objects they own or open connections\";","if (!this:trust(caller_perms()))","return E_PERM;","elseif (valid(x = args[1]))","if ((x.owner == x) || (x.owner != caller_perms()))","return E_INVARG;","endif","\"elseif (!this:is_outgoing_connection(x) return E_PERM\";","endif","return `read(@args) ! ANY';"]},{"name":"is_open","owner":36,"perms":173,"preposition":-1,"code":["\":is_open(object)\";","\"return true if the object is somehow connected, false otherwise.\";","return typeof(`idle_seconds(@args) ! ANY') == INT;","\"Relies on test in idle_seconds, and the error catching\";"]},{"name":"incoming_connection","owner":2,"perms":173,"preposition":-1,"code":["\"Peer at an incoming connection.  Decide if it should be connected to something, return that object. If it should be ignored (outbound connection), return 1. Called only by #0:do_login_command\";","if (caller != #0)","return;","endif","what = args[1];","\"this code for unix servers >= 1.7.5 only\";","if (index(`connection_name(what) ! ANY => \"\"', \" to \"))","\"outbound connection\";","if (ct = $list_utils:assoc(what, this.connect_connections_to))","this.connect_connections_to = setremove(this.connect_connections_to, ct);","return ct[2];","else","return 1;","endif","else","return 0;","endif"]},{"name":"return_address_for","owner":2,"perms":173,"preposition":-1,"code":["\":return_address_for(player) => string of 'return address'. Currently inbound mail doesn't work, so this is a bogus address.\";","who = args[1];","if (valid(who) && is_player(who))","return tostr(toint(who), \"@\", this.site, \" (\", who.name, \")\");","else","return tostr($login.registration_address, \" (non-player \", who, \")\");","endif"]},{"name":"server_started","owner":2,"perms":173,"preposition":-1,"code":["\"called when restarting to clean out state.\";","if (caller != #0)","return E_PERM;","endif","this.connect_connections_to = {};"]},{"name":"is_outgoing_connection","owner":2,"perms":173,"preposition":-1,"code":["return index(`connection_name(args[1]) ! ANY => \"\"', \" to \");"]},{"name":"notify","owner":2,"perms":173,"preposition":-1,"code":["\"for trusted players, they can write to connections\";","if (!this:trust(caller_perms()))","return E_PERM;","elseif (valid(x = args[1]))","return E_INVARG;","elseif (!this:is_outgoing_connection(x))","return E_PERM;","endif","return notify(x, args[2]);"]},{"name":"suspend_if_needed","owner":2,"perms":173,"preposition":-1,"code":["\"$command_utils:suspend_if_needed but chowned to player\";","if ($command_utils:running_out_of_time())","set_task_perms(caller_perms().wizard ? player | caller_perms());","return $command_utils:suspend_if_needed(@args);","endif"]},{"name":"error","owner":2,"perms":173,"preposition":-1,"code":["\":error(ERN, host, port) interpret open_network_connection(host, port) error\";","{msg, host, port} = args;","if (msg == E_PERM)","return \"Networking not enabled in server, or else user doesn't have permission to call o_n_c();\";","elseif (msg == E_INVARG)","return tostr(\"The host/port \", toliteral(host), \"/\", toliteral(port), \" is invalid or is not responding.\");","elseif (msg == E_QUOTA)","return tostr(\"The connection to \", toliteral(host), \"/\", toliteral(port), \" cannot be made at this time.\");","else","return tostr(\"Unusual error: \", toliteral(msg));","endif"]},{"name":"help_msg","owner":36,"perms":173,"preposition":-1,"code":["\"'cause this doesn't have a $_utils name\";","return this:description();"]},{"name":"adjust_postmaster_for_password","owner":2,"perms":173,"preposition":-1,"code":["\"adjust_postmaster_for_password(enter_or_exit): permits the MOO to have two different postmasters for different kinds of bounces.  If entering password (argument \\\"enter\\\"), change to $network.password_postmaster, else (argument \\\"exit\\\") change to $network.usual_postmaster.\";","if (args[1] == \"enter\")","$network.postmaster = $network.password_postmaster;","$network.errors_to_address = $network.password_postmaster;","$network.envelope_from = $network.password_postmaster;","else","$network.postmaster = $network.usual_postmaster;","$network.errors_to_address = $network.usual_postmaster;","$network.envelope_from = $network.blank_envelope ? \"\" | $network.usual_postmaster;","endif"]},{"name":"add_queued_mail","owner":36,"perms":173,"preposition":-1,"code":["\"$network:add_queued_mail( mail message )\";","\"  -- where `mail message' is in the same format as passed to :raw_sendmail\";","if (caller == this)","this.queued_mail = {@this.queued_mail, {time(), args}};","if (!$code_utils:task_valid(this.queued_mail_task))","fork fid (3600)","this:send_queued_mail();","endfork","this.queued_mail_task = fid;","endif","return 1;","else","return E_PERM;","endif"]},{"name":"send_queued_mail","owner":2,"perms":173,"preposition":-1,"code":["\"$network:send_queued_mail()\";","\"  -- tries to send the mail stored in the .queued_mail property\";","while (queued_mail = this.queued_mail)","message = queued_mail[1];","if (!this:raw_sendmail(@message[2]))","this.queued_mail = setremove(this.queued_mail, message);","else","\"wait an hour\";","suspend(3600);","endif","endwhile"]},{"name":"tcp_wait","owner":2,"perms":173,"preposition":-1,"code":["\"Copied from sendmail fix (#88079):tcp_wait by Lineman (#108318) Mon Feb  1 19:28:18 1999 PST\";","{conn, ?timeout = 0} = args;","if (!caller_perms().wizard)","return E_PERM;","elseif (timeout)","fork task (timeout)","boot_player(conn);","endfork","endif","while (1)","if (typeof(line = `read(conn) ! ANY') == ERR)","break;","elseif (match(line, \"^[0-9][0-9][0-9] \"))","timeout && `kill_task(task) ! ANY';","break;","endif","endwhile","return line;"]},{"name":"_make","owner":2,"perms":173,"preposition":-1,"code":["\":_make(...) => new node with value {...}\";","if (!(caller in {this._mgr, this}))","return E_PERM;","endif","prop = this:_genprop();","add_property(this, prop, args, {$generic_biglist_home.owner, \"\"});","return prop;"]},{"name":"_kill","owner":2,"perms":173,"preposition":-1,"code":["\":_kill(node) destroys the given node.\";","if (!(caller in {this, this._mgr}))","return E_PERM;","endif","delete_property(this, args[1]);"]},{"name":"_get","owner":36,"perms":173,"preposition":-1,"code":["return (caller == this._mgr) ? this.(args[1]) | E_PERM;"]},{"name":"_put","owner":36,"perms":173,"preposition":-1,"code":["return (caller == this._mgr) ? this.(args[1]) = listdelete(args, 1) | E_PERM;"]},{"name":"_genprop","owner":36,"perms":173,"preposition":-1,"code":["gp = this._genprop;","ngp = \"\";","for i in [1..length(gp)]","if (gp[i] != \"z\")","ngp = (ngp + \"bcdefghijklmnopqrstuvwxyz\"[strcmp(gp[i], \"`\")]) + gp[i + 1..$];","return \" \" + (this._genprop = ngp);","endif","ngp = ngp + \"a\";","endfor","return \" \" + (this._genprop = ngp + \"a\");"]},{"name":"_ord","owner":36,"perms":173,"preposition":-1,"code":["\"this is a dummy. You have to decide what your leaves are going to look like and then write this verb accordingly.  It should, given a leaf/list-element, return the corresponding key value.  So for an ordinary alist, where all of the leaves are of the form {key,datum}, you want:\";","return args[1][1];"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return E_PERM;","endif","this.mowner = $hacker;","this._mgr = $biglist;"]},{"name":"help_msg","owner":36,"perms":173,"preposition":-1,"code":["all_help = this.help_msg;","if (typeof(all_help) == STR)","all_help = {all_help};","endif","helpless = {};","for vrb in (this.feature_verbs)","if (loc = $object_utils:has_verb(this, vrb))","loc = loc[1];","help = $code_utils:verb_documentation(loc, vrb);","if (help)","all_help = {@all_help, \"\", tostr(loc, \":\", verb_info(loc, vrb)[3]), @help};","else","helpless = {@helpless, vrb};","endif","endif","endfor","if (helpless)","all_help = {@all_help, \"\", (\"No help found on \" + $string_utils:english_list(helpless, \"nothing\", \" or \")) + \".\"};","endif","return {@all_help, \"----\"};"]},{"name":"look_self","owner":36,"perms":173,"preposition":-1,"code":["\"Definition from #1\";","desc = this:description();","if (desc)","player:tell_lines(desc);","else","player:tell(\"You see nothing special.\");","endif","player:tell(\"Please type \\\"help \", this, \"\\\" for more information.\");"]},{"name":"using this","owner":36,"perms":173,"preposition":-1,"code":["\"Proper usage for the Generic Feature Object:\";","\"\";","\"First of all, the Generic Feature Object is constructed with the idea\";","\"that its children will be @moved to #24300, which is kind of a warehouse\";","\"for feature objects.  If there's enough interest, I'll try to make the\";","\"stuff that works with that in mind optional.\";","\"\";","\"Make a short description.  This is so I can continue to have looking at\";","\"#24300 give the descriptions of each of the objects in its .contents.\";","\"The :look_msg automatically includes a pointer to `help <this object>',\";","\"so you don't have to.\";","\"\";","\"Put a list of the commands you want people to use in\";","\"<this object>.feature_verbs.  (You need to use the :set_feature_verbs\";","\"verb to do this.)\";","\"\";","\"When someone types `help <this object>', they will be told the comment\";","\"strings from each of the verbs named in .feature_verbs.\";"]},{"name":"examine_commands_ok","owner":2,"perms":173,"preposition":-1,"code":["return this in args[1].features;"]},{"name":"set_feature_ok","owner":36,"perms":173,"preposition":-1,"code":["if ($perm_utils:controls(caller_perms(), this) || (caller == this))","return this.feature_ok = args[1];","else","return E_PERM;","endif"]},{"name":"hidden_verbs","owner":36,"perms":173,"preposition":-1,"code":["\"Can't see `get' unless it's in the room; can't see `drop' unless it's in the player.  Should possibly go on $thing.\";","\"Should use :contents, but I'm in a hurry.\";","hidden = pass(@args);","if (this.location != args[1])","hidden = setadd(hidden, {$thing, verb_info($thing, \"drop\")[3], {\"this\", \"none\", \"none\"}});","hidden = setadd(hidden, {$thing, verb_info($thing, \"give\")[3], {\"this\", \"at/to\", \"any\"}});","endif","if (this.location != args[1].location)","hidden = setadd(hidden, {$thing, verb_info($thing, \"get\")[3], {\"this\", \"none\", \"none\"}});","endif","return hidden;"]},{"name":"set_feature_verbs","owner":36,"perms":173,"preposition":-1,"code":["if ($perm_utils:controls(caller_perms(), this) || (caller == this))","return this.feature_verbs = args[1];","else","return E_PERM;","endif"]},{"name":"initialize","owner":36,"perms":173,"preposition":-1,"code":["if ((caller == this) || $perm_utils:controls(caller_perms(), this))","pass(@args);","this.feature_verbs = {};","else","return E_PERM;","endif"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (($code_utils:verb_location() == this) && caller_perms().wizard)","this.warehouse = $feature_warehouse;","`delete_property(this, \"guest_ok\") ! ANY';","`delete_verb(this, \"set_ok_for_guest_use\") ! ANY';","`set_verb_code(this, \"player_connected\", {\"return;\"}) ! ANY';","pass();","endif"]},{"name":"feature_remove","owner":2,"perms":173,"preposition":-1,"code":["\"This is just a blank verb definition to encourage others to use this verb name if they care when a user is no longer using that feature.\";"]},{"name":"player_connected","owner":2,"perms":173,"preposition":-1,"code":["return;"]},{"name":"get_now","owner":2,"perms":173,"preposition":-1,"code":["\"Usage:  get_now(site, port, message)\";","\"Returns a list of strings, or an error if we couldn't connect.\";","{host, port, message, ?extra = {0}} = args;","if (!this:trusted(caller_perms()))","return E_PERM;","elseif ((!match(host, $network.valid_host_regexp)) && (!match(host, \"[0-9]+%.[0-9]+%.[0-9]+%.[0-9]+\")))","\"allow either welformed internet hosts or explicit IP addresses.\";","return E_INVARG;","elseif ((port < 100) && (!(port in {70, 80, 81, 79})))","\"disallow connections to low number ports; necessary?\";","return E_INVARG;","endif","opentime = time();","con = $network:open(host, port);","opentime = time() - opentime;","if (typeof(con) == ERR)","return con;","endif","notify(con, message);","results = {};","count = this.limit;","\"perhaps this isn't necessary, but if a gopher source is slowly spewing things, perhaps we don't want to hang forever -- perhaps this should just fork a process to close the connection instead?\";","now = time();","timeout = 30;","end = \"^%.$\";","if (extra[1] == \"2\")","end = \"^[2-9]\";","endif","while ((((typeof(string = `read(con) ! ANY') == STR) && (!match(string, end))) && ((count = count - 1) > 0)) && ((now + timeout) > (now = time())))","if (string && (string[1] == \".\"))","string = string[2..$];","endif","results = {@results, string};","endwhile","$network:close(con);","if (opentime > 0)","\"This is to keep repeated calls to $network:open to 'slow responding hosts' from totally spamming.\";","suspend(0);","endif","return results;"]},{"name":"parse","owner":2,"perms":173,"preposition":-1,"code":["\"parse gopher result line:\";","\"return {host, port, tag, label}\";","\"host/port/tag are what you send to the gopher server to get that line\";","\"label is <type>/human readable entry\";","{string} = args;","tab = index(string, \"\t\");","label = string[1..tab - 1];","string = string[tab + 1..$];","tab = index(string, \"\t\");","tag = string[1..tab - 1];","string = string[tab + 1..$];","tab = index(string, \"\t\");","host = string[1..tab - 1];","if (host[$] == \".\")","host = host[1..$ - 1];","endif","string = string[tab + 1..$];","tab = index(string, \"\t\");","port = toint(tab ? string[1..tab - 1] | string);","return {host, port, tag, label};","\"ignore extra material after port, if any\";"]},{"name":"show_text","owner":2,"perms":173,"preposition":-1,"code":["\"$gopher:show_text(who, start, end, ..node..)\";","\"like who:notify_lines($gopher:get(..node..)[start..end]), but pipelined\";","if (!caller_perms().wizard)","return E_PERM;","endif","{who, start, end, @args} = args;","con = $network:open(who, start);","if (typeof(con) == ERR)","player:tell(\"Sorry, can't get this information now.\");","return;","endif","notify(con, end);","line = 0;","sent = 0;","end = end || this.limit;","while (((string = `read(con) ! ANY') != \".\") && (typeof(string) == STR))","line = line + 1;","if ((line >= start) && ((!end) || (line <= end)))","sent = sent + 1;","if (valid(who))","if (string && (string[1] == \".\"))","string = string[2..$];","endif","who:notify(string);","else","notify(who, string);","endif","endif","endwhile","$network:close(con);","return sent;"]},{"name":"type","owner":2,"perms":173,"preposition":-1,"code":["type = args[1];","if (type == \"1\")","return \"menu\";","elseif (type == \"?\")","return \"menu?\";","elseif (type == \"0\")","return \"text\";","elseif (type == \"7\")","return \"search\";","elseif (type == \"9\")","return \"binary\";","elseif (type == \"2\")","return \"phone directory\";","elseif (type == \"4\")","return \"binhex\";","elseif (type == \"8\")","return \"telnet\";","elseif (type == \"I\")","return \"image\";","elseif (type == \" \")","\"not actually gopher protocol: used by 'goto'\";","return \"\";","else","return \"unknown\";","endif","\"not done, need to fill out\";"]},{"name":"summary","owner":2,"perms":173,"preposition":-1,"code":["\"return a 'nice' string showing the information in a gopher node\";","if (typeof(parse = args[1]) == STR)","parse = this:parse(parse);","endif","if (parse[1] == \"!\")","return {\"[remembered set]\", \"\", \"\"};","endif","if (length(parse) > 3)","label = parse[4];","if (label)","type = $gopher:type(label[1]);","label = label[2..$];","if (type == \"menu\")","elseif (type == \"search\")","label = ((\"<\" + parse[3][rindex(parse[3], \"\t\") + 1..$]) + \"> \") + label;","else","label = (type + \": \") + label;","endif","else","label = \"(top)\";","endif","else","label = parse[3] + \" (top)\";","endif","port = \"\";","if (parse[2] != 70)","port = tostr(\" \", parse[2]);","endif","return {tostr(\"[\", parse[1], port, \"]\"), label, parse[3]};"]},{"name":"get","owner":2,"perms":173,"preposition":-1,"code":["\"Usage: get(site, port, selection)\";","\"returns a list of strings, or an error if it couldn't connect. Results are cached.\";","if (this.frozen)","return E_QUOTA;","endif","request = args[1..3];","while ((index = request in this.cache_requests) && (this.cache_times[index] > time()))","if (typeof(result = this.cache_values[index]) != INT)","return result;","endif","if ($code_utils:task_valid(result))","\"spin, let other process getting same data win, or timeout\";","suspend(1);","else","\"well, other process crashed, or terminated, or whatever.\";","this.cache_times[index] = 0;","endif","endwhile","if (!this:trusted(caller_perms()))","return E_PERM;","endif","while (this.cache_times && (this.cache_times[1] < time()))","$command_utils:suspend_if_needed(0);","this.cache_times = listdelete(this.cache_times, 1);","this.cache_values = listdelete(this.cache_values, 1);","this.cache_requests = listdelete(this.cache_requests, 1);","\"caution: don't want to suspend between test and removal\";","endwhile","$command_utils:suspend_if_needed(0);","this:cache_entry(@request);","value = this:get_now(@args);","$command_utils:suspend_if_needed(0);","index = this:cache_entry(@request);","this.cache_times[index] = time() + ((typeof(value) == ERR) ? 120 | 1800);","this.cache_values[index] = value;","return value;"]},{"name":"clear_cache","owner":2,"perms":173,"preposition":-1,"code":["if (!this:trusted(caller_perms()))","return E_PERM;","endif","if (!args)","this.cache_values = this.cache_times = this.cache_requests = {};","elseif (index = args[1..3] in this.cache_requests)","this.cache_requests = listdelete(this.cache_requests, index);","this.cache_times = listdelete(this.cache_times, index);","this.cache_values = listdelete(this.cache_values, index);","endif"]},{"name":"unparse","owner":2,"perms":173,"preposition":-1,"code":["\"unparse(host, port, tag, label) => string\";","{host, port, tag, label} = args;","if (tab = index(tag, \"\t\"))","\"remove search terms from search nodes\";","tag = tag[1..tab - 1];","endif","return tostr(label, \"\t\", tag, \"\t\", host, \"\t\", port);"]},{"name":"interpret_error","owner":2,"perms":173,"preposition":-1,"code":["\"return an explanation for a 'false' $gopher:get result\";","value = args[1];","if (value == E_INVARG)","return \"That gopher server is not reachable or is not responding.\";","elseif (value == E_QUOTA)","return \"Gopher connections cannot be made at this time because of system resource limitations!\";","elseif (typeof(value) == ERR)","return tostr(\"The gopher request results in an error: \", value);","else","return \"The gopher request has no results.\";","endif"]},{"name":"trusted","owner":2,"perms":173,"preposition":-1,"code":["\"default -- gopher trusts everybody\";","return 1;"]},{"name":"_textp","owner":2,"perms":173,"preposition":-1,"code":["\"_textp(parsed node)\";","\"Return true iff the parsed info points to a text node.\";","return index(\"02\", args[1][4][1]);"]},{"name":"_mail_text","owner":2,"perms":173,"preposition":-1,"code":["\"_mail_text(parsed node)\";","\"Return the text to be mailed out for the given node.\";","where = args[1];","if (this:_textp(where))","return $gopher:get(@where);","else","text = {};","for x in ($gopher:get(@where))","parse = $gopher:parse(x);","sel = parse[4];","text = {@text, \"Type=\" + sel[1], \"Name=\" + sel[2..$], \"Path=\" + parse[3], \"Host=\" + parse[1], \"Port=\" + tostr(parse[2]), \"#\"};","endfor","return text;","endif"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","this:clear_cache();","pass(@args);","endif"]},{"name":"display_cache","owner":2,"perms":45,"preposition":-1,"code":["\"Just for debugging -- shows what's in the gopher cache\";","req = this.cache_requests;","tim = this.cache_times;","val = this.cache_values;","\"save values in case cache changes while printing\";","player:tell(\"size -- expires -- host (port) ------ selector ------------\");","for i in [1..length(req)]","re = req[i];","host = $string_utils:left(re[1] + ((re[2] == 70) ? \"\" | tostr(\" (\", re[2], \")\")), 24);","expires = $string_utils:right($time_utils:dhms(tim[i] - time()), 8);","va = val[i];","if (typeof(va) == LIST)","va = length(va);","elseif (typeof(va) == ERR)","va = toliteral(va);","else","va = tostr(va);","endif","selector = re[3];","if (length(selector) > 40)","selector = \"...\" + selector[$ - 37..$];","endif","player:tell($string_utils:right(va, 8), expires, \" \", host, selector);","endfor","player:tell(\"--- end cache display -------------------------------------\");"]},{"name":"get_cache","owner":2,"perms":173,"preposition":-1,"code":["\"Usage: get_cache(site, port, selection)\";","\"return current cache\";","request = args[1..3];","if (index = request in this.cache_requests)","if (this.cache_times[index] > now)","return this.cache_values[index];","endif","endif","return 0;"]},{"name":"cache_entry","owner":2,"perms":173,"preposition":-1,"code":["if (index = args in this.cache_requests)","return index;","else","this.cache_times = {@this.cache_times, time() + 240};","this.cache_values = {@this.cache_values, task_id()};","this.cache_requests = {@this.cache_requests, args};","return length(this.cache_requests);","endif"]},{"name":"help_msg","owner":2,"perms":173,"preposition":-1,"code":["return this:description();"]},{"name":"daily","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","day = 24 * 3600;","hour_of_day_GMT = 10;","fork ((((hour_of_day_GMT * 60) * 60) + day) - (time() % day))","this:daily();","endfork","this.frozen = 1;","this:clear_cache();","suspend(3900);","this.frozen = 0;","endif"]},{"name":"actual","owner":36,"perms":173,"preposition":-1,"code":["if (i = args[1] in {\"list_numbers\"})","return {{{\"list_no_numbers\"}[i], !args[2]}};","else","return {args};","endif"]},{"name":"show","owner":36,"perms":173,"preposition":-1,"code":["if (o = (name = args[2]) in {\"list_numbers\"})","args[2] = {\"list_no_numbers\"}[o];","return {@pass(@args), tostr(\"(\", name, \" is a synonym for -\", args[2], \")\")};","else","return pass(@args);","endif"]},{"name":"show_verb_args","owner":36,"perms":173,"preposition":-1,"code":["if (value = this:get(@args))","return {value, {tostr(\"Default args for @verb:  \", $string_utils:from_list(value, \" \"))}};","else","return {0, {\"Default args for @verb:  none none none\"}};","endif"]},{"name":"check_verb_args","owner":36,"perms":173,"preposition":-1,"code":["value = args[1];","if (typeof(value) != LIST)","return \"List expected\";","elseif (length(value) != 3)","return \"List of length 3 expected\";","elseif (!(value[1] in {\"this\", \"none\", \"any\"}))","return tostr(\"Invalid dobj specification:  \", value[1]);","elseif (!((p = $code_utils:short_prep(value[2])) || (value[2] in {\"none\", \"any\"})))","return tostr(\"Invalid preposition:  \", value[2]);","elseif (!(value[3] in {\"this\", \"none\", \"any\"}))","return tostr(\"Invalid iobj specification:  \", value[3]);","else","if (p)","value[2] = p;","endif","return {value};","endif"]},{"name":"parse_verb_args","owner":36,"perms":173,"preposition":-1,"code":["{oname, raw, data} = args;","if (typeof(raw) == STR)","raw = $string_utils:explode(raw, \" \");","elseif (typeof(raw) == INT)","return raw ? {oname, {\"this\", \"none\", \"this\"}} | {oname, 0};","endif","value = $code_utils:parse_argspec(@raw);","if (typeof(value) != LIST)","return tostr(value);","elseif (value[2])","return tostr(\"I don't understand \\\"\", $string_utils:from_list(value[2], \" \"), \"\\\"\");","else","value = {@value[1], \"none\", \"none\", \"none\"}[1..3];","return {oname, (value == {\"none\", \"none\", \"none\"}) ? 0 | value};","endif"]},{"name":"show_@prop_flags","owner":36,"perms":173,"preposition":-1,"code":["value = this:get(@args);","if (value)","return {value, {tostr(\"Default permissions for @property=`\", value, \"'.\")}};","else","return {0, {\"Default permissions for @property=`rc'.\"}};","endif"]},{"name":"check_@prop_flags","owner":2,"perms":173,"preposition":-1,"code":[]},{"name":"parse_@prop_flags","owner":2,"perms":173,"preposition":-1,"code":["{oname, raw, data} = args;","if (typeof(raw) != STR)","return \"Must be a string composed of the characters `rwc'.\";","endif","len = length(raw);","for x in [1..len]","if (!(raw[x] in {\"r\", \"w\", \"c\"}))","return \"Must be a string composed of the characters `rwc'.\";","endif","endfor","return {oname, raw};"]},{"name":"check_create_flags","owner":36,"perms":173,"preposition":-1,"code":["value = args[1];","if (m = match(value, \"[^rwf]\"))","return tostr(\"Unknown object flag:  \", value[m[1]]);","else","return {tostr(index(value, \"r\") ? \"r\" | \"\", index(value, \"w\") ? \"w\" | \"\", index(value, \"f\") ? \"f\" | \"\")};","endif"]},{"name":"show_create_flags","owner":36,"perms":173,"preposition":-1,"code":["if (value = this:get(@args))","return {value, {tostr(\"Object flags for @create:  \", value)}};","else","return {0, {tostr(\"@create leaves all object flags reset\")}};","endif"]},{"name":"parse_create_flags","owner":36,"perms":173,"preposition":-1,"code":["raw = args[2];","if (raw == 1)","\"...+create_flags => create_flags=r\";","return {args[1], \"r\"};","elseif (typeof(raw) == STR)","return args[1..2];","elseif (typeof(raw) != LIST)","return \"???\";","elseif (length(raw) > 1)","return tostr(\"I don't understand \\\"\", $string_utils:from_list(listdelete(raw, 1), \" \"), \"\\\"\");","else","return {args[1], raw[1]};","endif"]},{"name":"show_dig_room show_dig_exit","owner":36,"perms":173,"preposition":-1,"code":["name = args[2];","what = (verb == \"show_dig_room\") ? \"room\" | \"exit\";","if ((value = this:get(args[1], name)) == 0)","return {0, {tostr(\"@dig \", what, \"s are children of $\", what, \".\")}};","else","return {value, {tostr(\"@dig \", what, \"s are children of \", value, \" (\", valid(value) ? value.name | \"invalid\", \").\")}};","endif"]},{"name":"parse_dig_room parse_dig_exit","owner":36,"perms":173,"preposition":-1,"code":["{oname, raw, data} = args;","if (typeof(raw) == LIST)","if (length(raw) > 1)","return tostr(\"I don't understand \\\"\", $string_utils:from_list(listdelete(raw, 1), \" \"), \"\\\".\");","endif","raw = raw[1];","endif","if (typeof(raw) != STR)","return \"You need to give an object id.\";","elseif ($command_utils:object_match_failed(value = player:my_match_object(raw), raw))","return \"Option unchanged.\";","endif","what = (verb == \"parse_dig_room\") ? \"room\" | \"exit\";","generic = #0.(what);","if (value == generic)","return {oname, 0};","else","if (!$object_utils:isa(value, generic))","player:tell(\"Warning: \", value, \" is not a descendant of $\", what, \".\");","endif","return {oname, value};","endif"]},{"name":"initialize_quota","owner":36,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return E_PERM;","else","args[1].size_quota = this.default_quota;","args[1].ownership_quota = this.large_negative_number;","endif"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return E_PERM;","else","set_verb_code(this, \"can_peek\", {\"return args[1]==this.owner || $perm_utils:controls(args[1], args[2]);\"});","set_verb_code(this, \"can_touch\", {\"return args[1].wizard;\"});","this.exempted = {};","this.working = #2;","this.task_time_limit = 500;","this.repeat_cycle = 0;","this.large_objects = {};","this.report_recipients = {#2};","endif"]},{"name":"adjust_quota_for_programmer","owner":36,"perms":173,"preposition":-1,"code":["return 0;"]},{"name":"bi_create","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","who = this:parse_create_args(@args);","\"Because who can be E_INVARG, need to catch E_TYPE. Let $recycler:_create deal with returning E_PERM since that's what's going to happen. Ho_Yan 11/19/96.\";","if ((!`who.wizard ! E_TYPE => 0') && $recycler.contents)","return $recycler:_create(@args);","elseif (this:creation_permitted(who))","this:enable_create(who);","value = `create(@args) ! ANY';","this:disable_create(who);","if (typeof(value) != ERR)","this:charge_quota(who, value);","if ((typeof(who.owned_objects) == LIST) && (!(value in who.owned_objects)))","this:add_owned_object(who, value);","endif","endif","return value;","else","return E_QUOTA;","endif"]},{"name":"enable_create","owner":2,"perms":173,"preposition":-1,"code":["if ((caller != this) && (!caller_perms().wizard))","return E_PERM;","else","args[1].ownership_quota = 1;","endif"]},{"name":"disable_create","owner":2,"perms":173,"preposition":-1,"code":["if ((caller != this) && (!caller_perms().wizard))","return E_PERM;","else","args[1].ownership_quota = this.large_negative_number;","endif"]},{"name":"parse_create_args","owner":36,"perms":173,"preposition":-1,"code":["\"This figures out who is gonna own the stuff @create does.  If one arg, return caller_perms().  If two args, then if caller_perms().wizard, args[2].\";","{what, ?who = #-1} = args;","if (!valid(who))","return caller_perms();","elseif ($perm_utils:controls(caller_perms(), who))","return who;","else","return E_INVARG;","endif"]},{"name":"creation_permitted verb_addition_permitted property_addition_permitted","owner":36,"perms":173,"preposition":-1,"code":["\"Here's the tricky one.  Collect all the user's characters' cached usage data and total quotas.  Compare same.  If usage bigger than quotas, return 0.  Else, add up the total number of objects that haven't been measured recently.  If greater than the allowed, return 0.  Else, reluctantly, return 1.\";","who = args[1];","if (who.wizard || (who == $hacker))","\"... sorry folks --Rog\";","return 1;","endif","if ((!$object_utils:has_property(who, \"size_quota\")) || is_clear_property(who, \"size_quota\"))","return 0;","endif","$recycler:check_quota_scam(who);","allwho = this:all_characters(who);","quota = 0;","usage = 0;","unmeasured = 0;","for x in (allwho)","quota = quota + x.size_quota[1];","usage = usage + x.size_quota[2];","unmeasured = unmeasured + x.size_quota[4];","endfor","if (usage >= quota)","return 0;","elseif (unmeasured >= this.max_unmeasured)","return 0;","else","return 1;","endif"]},{"name":"all_characters","owner":36,"perms":173,"preposition":-1,"code":["{who} = args;","if ((caller != this) && (!this:can_peek(caller_perms(), who)))","return E_PERM;","elseif ($object_utils:has_property($local, \"second_char_registry\"))","seconds = $local.second_char_registry:all_second_chars(who);","if (seconds == E_INVARG)","return {who};","else","return seconds;","endif","else","return {who};","endif"]},{"name":"display_quota","owner":36,"perms":173,"preposition":-1,"code":["who = args[1];","if (this:can_peek(caller_perms(), who) && (length(all = this:all_characters(who)) > 1))","many = 1;","else","many = 0;","all = {who};","endif","if (many)","tquota = 0;","tusage = 0;","ttime = $maxint;","tunmeasured = 0;","tunmeasurable = 0;","endif","for x in (all)","{quota, usage, timestamp, unmeasured} = x.size_quota;","unmeasurable = 0;","if (unmeasured >= 100)","unmeasurable = unmeasured / 100;","unmeasured = unmeasured % 100;","endif","if (many)","player:tell(x.name, \" quota: \", $string_utils:group_number(quota), \"; usage: \", $string_utils:group_number(usage), \"; unmeasured: \", unmeasured, \"; no .object_size: \", unmeasurable, \".\");","tquota = tquota + quota;","tusage = tusage + usage;","ttime = min(ttime, timestamp);","tunmeasured = tunmeasured + unmeasured;","tunmeasurable = tunmeasurable + unmeasurable;","endif","endfor","if (many)","this:display_quota_summary(who, tquota, tusage, ttime, tunmeasured, tunmeasurable);","else","this:display_quota_summary(who, quota, usage, timestamp, unmeasured, unmeasurable);","endif"]},{"name":"get_quota","owner":36,"perms":173,"preposition":-1,"code":["return args[1].size_quota[1];"]},{"name":"charge_quota","owner":36,"perms":173,"preposition":-1,"code":["\"Charge args[1] for the quota required to own args[2]\";","{who, what} = args;","if ((caller == this) || caller_perms().wizard)","usage_index = 2;","unmeasured_index = 4;","object_size = $object_utils:has_property(what, \"object_size\") ? what.object_size[1] | -1;","if (object_size <= 0)","who.size_quota[unmeasured_index] = who.size_quota[unmeasured_index] + 1;","else","who.size_quota[usage_index] = who.size_quota[usage_index] + object_size;","endif","else","return E_PERM;","endif"]},{"name":"reimburse_quota","owner":36,"perms":173,"preposition":-1,"code":["\"reimburse args[1] for the quota required to own args[2]\";","\"If it is a $garbage, then if who = $hacker, then we mostly ignore everything.  Who cares what $hacker's quota looks like.\";","{who, what} = args;","if ((caller == this) || caller_perms().wizard)","usage_index = 2;","unmeasured_index = 4;","if (parent(what) == $garbage)","return 0;","elseif (((valid(who) && is_player(who)) && $object_utils:has_property(what, \"object_size\")) && (!is_clear_property(who, \"size_quota\")))","object_size = what.object_size[1];","if (object_size <= 0)","who.size_quota[unmeasured_index] = who.size_quota[unmeasured_index] - 1;","else","who.size_quota[usage_index] = who.size_quota[usage_index] - object_size;","endif","endif","else","return E_PERM;","endif"]},{"name":"set_quota","owner":36,"perms":173,"preposition":-1,"code":["\"Set args[1]'s quota to args[2]\";","if ((caller_perms().wizard || (caller == this)) || this:can_touch(caller_perms()))","\"Size_quota[1] is the total quota permitted.\";","return args[1].size_quota[1] = args[2];","else","return E_PERM;","endif"]},{"name":"get_size_quota","owner":36,"perms":173,"preposition":-1,"code":["\"Return args[1]'s quotas.  second arg of 1 means add all second chars.\";","{who, ?all = 0} = args;","if (all && ((caller == this) || this:can_peek(caller_perms(), who)))","all = this:all_characters(who);","else","all = {who};","endif","baseline = {0, 0, 0, 0};","for x in (all)","baseline[1] = baseline[1] + x.size_quota[1];","baseline[2] = baseline[2] + x.size_quota[2];","baseline[3] = min(baseline[3], x.size_quota[3]) || x.size_quota[3];","baseline[4] = baseline[4] + x.size_quota[4];","endfor","return baseline;"]},{"name":"display_quota_summary","owner":36,"perms":173,"preposition":-1,"code":["{who, quota, usage, timestamp, unmeasured, unmeasurable} = args;","player:tell(who.name, \" has a total building quota of \", $string_utils:group_number(quota), \" bytes.\");","player:tell($gender_utils:get_pronoun(\"P\", who), \" total usage was \", $string_utils:group_number(usage), \" as of \", player:ctime(timestamp), \".\");","if (usage > quota)","player:tell(who.name, \" is over quota by \", $string_utils:group_number(usage - quota), \" bytes.\");","else","player:tell(who.name, \" may create up to \", $string_utils:group_number(quota - usage), \" more bytes of objects, properties, or verbs.\");","endif","if (unmeasured)","plural = unmeasured != 1;","player:tell(\"There \", plural ? tostr(\"are \", unmeasured, \" objects\") | \"is 1 object\", \" which \", plural ? \"are\" | \"is\", \" not yet included in the tally; this tally may thus be inaccurate.\");","if (unmeasured >= this.max_unmeasured)","player:tell(\"The number of unmeasured objects is too large; no objects may be created until @measure new is used.\");","endif","endif","if (unmeasurable)","plural = unmeasurable != 1;","player:tell(\"There \", plural ? tostr(\"are \", unmeasurable, \" objects\") | \"is 1 object\", \" which do\", plural ? \"\" | \"es\", \" not have a .object_size property and will thus prevent additional building.\", (who == player) ? \"  Contact a wizard for assistance in having this situation repaired.\" | \"\");","endif"]},{"name":"quota_remaining","owner":36,"perms":173,"preposition":-1,"code":["\"This wants to only be called by a wizard cuz I'm lazy.  This is just for @second-char anyway.\";","if (caller_perms().wizard)","q = this:get_size_quota(args[1], 1);","return q[1] - q[2];","endif"]},{"name":"preliminary_reimburse_quota","owner":36,"perms":173,"preposition":-1,"code":["\"This does the reimbursement work of the recycler, since we ignore $garbage in ordinary reimbursement.\";","if (caller_perms().wizard)","this:reimburse_quota(@args);","else","return E_PERM;","endif"]},{"name":"value_bytes","owner":2,"perms":173,"preposition":-1,"code":["return value_bytes(args[1]);","set_task_perms(caller_perms());","v = args[1];","t = typeof(v);","if (t == LIST)","b = ((length(v) + 1) * 2) * 4;","for vv in (v)","$command_utils:suspend_if_needed(2);","b = b + this:value_bytes(vv);","endfor","return b;","elseif (t == STR)","return length(v) + 1;","else","return 0;","endif"]},{"name":"object_bytes object_size","owner":2,"perms":173,"preposition":-1,"code":["\"No need for lengthy algorithms to measure an object, we have a builtin now. Ho_Yan 10/31/96\";","set_task_perms($wiz_utils:random_wizard());","o = args[1];","if (((($object_utils:has_property(o, \"object_size\") && (o.object_size[1] > this.too_large)) && (!caller_perms().wizard)) && (caller_perms() != this.owner)) && (caller_perms() != $hacker))","return o.object_size[1];","endif","b = object_bytes(o);","if ($object_utils:has_property(o, \"object_size\"))","oldsize = is_clear_property(o, \"object_size\") ? 0 | o.object_size[1];","if ($object_utils:has_property(o.owner, \"size_quota\"))","\"Update quota cache.\";","if (oldsize)","o.owner.size_quota[2] = o.owner.size_quota[2] + (b - oldsize);","else","o.owner.size_quota[2] = o.owner.size_quota[2] + b;","if (o.owner.size_quota[4] > 0)","o.owner.size_quota[4] = o.owner.size_quota[4] - 1;","endif","endif","endif","o.object_size = {b, time()};","endif","if (b > this.too_large)","this.large_objects = setadd(this.large_objects, o);","endif","return b;"]},{"name":"do_summary","owner":36,"perms":157,"preposition":0,"code":["who = args[1];","results = this:summarize_one_user(who);","{total, nuncounted, nzeros, oldest, eldest} = results;","player:tell(who.name, \" statistics:\");","player:tell(\"  \", $string_utils:group_number(total), \" bytes of storage measured.\");","player:tell(\"  Oldest measurement date \", ctime(oldest), \" (\", $string_utils:from_seconds(time() - oldest), \" ago) of object \", eldest, \" (\", valid(eldest) ? eldest.name | \"$nothing\", \")\");","if (nzeros || nuncounted)","player:tell(\"  Number of objects with no statistics recorded:  \");","player:tell(\"      \", nzeros, \" recently created, \", nuncounted, \" not descendents of #1\");","endif"]},{"name":"summarize_one_user","owner":36,"perms":173,"preposition":-1,"code":["\"Summarizes total space usage by one user (args[1]).  Optional second argument is a flag to say whether to re-measure all objects for this user; specify the number of seconds out of date you are willing to accept.  If negative, will only re-measure objects which have no recorded data.\";","\"Returns a list of four values:\";","\"  total : total measured space in bytes\";","\"  uncounted : Number of objects that were not counted because they aren't descendents of #1\";","\"  zeros : Number of objects which have been created too recently to have any measurement data at all (presumably none if re-measuring)\";","\"  most-out-of-date : the time() the oldest actual measurement was taken\";","\"  object-thereof: the object who had this time()'d measurement\";","who = args[1];","if (length(args) == 2)","if (args[2] < 0)","earliest = 1;","else","earliest = time() - args[2];","endif","else","earliest = 0;","endif","nzeros = 0;","oldest = time();","eldest = #-1;","nuncounted = 0;","total = 0;","for x in ((typeof(who.owned_objects) == LIST) ? who.owned_objects | {})","if (x.owner == who)","\"Bulletproofing against recycling during suspends!\";","\"Leaves us open to unsummarized creation during this period, which is unfortunate.\";","if ($object_utils:has_property(x, \"object_size\"))","size = x.object_size[1];","time = x.object_size[2];","if (time < earliest)","\"Re-measure.  This side-effects x.object_size.\";","this:object_bytes(x);","size = x.object_size[1];","time = x.object_size[2];","endif","if (time && (time <= oldest))","oldest = time;","eldest = x;","elseif (!time)","nzeros = nzeros + 1;","endif","if (size >= 0)","total = total + size;","endif","else","nuncounted = nuncounted + 1;","endif","endif","$command_utils:suspend_if_needed(0);","endfor","if (!is_clear_property(who, \"size_quota\"))","\"Cache the data, but only if they aren't scamming.\";","who.size_quota[2] = total;","who.size_quota[3] = oldest;","who.size_quota[4] = (nuncounted * this.unmeasured_multiplier) + nzeros;","endif","return {total, nuncounted, nzeros, oldest, eldest};"]},{"name":"recent_object_bytes","owner":2,"perms":173,"preposition":-1,"code":["\":recent_object_bytes(x, n) -- return object size of x, guaranteed to be no more than n days old.  N defaults to this.cycle_days.\";","{object, ?since = this.cycle_days} = args;","if (!valid(object))","return 0;","elseif (`object.object_size[2] ! ANY => 0' > (time() - (((since * 24) * 60) * 60)))","\"Trap error when doesn't have .object_size for some oddball reason ($garbage). Ho_Yan 11/19/96\";","return object.object_size[1];","else","return this:object_bytes(object);","endif"]},{"name":"measurement_task","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return E_PERM;","else","start_time = time();","{num_processed, num_repetitions} = this:measurement_task_body(args[1]);","players = players();","lengthp = length(players);","if ((!num_repetitions) && (num_processed < (lengthp / 2)))","\"Add this in because we aren't getting people summarized like we should.  We're going to work for way longer now, cuz we're going to do a second pass, but we really need to get those summaries done.  Only do this if we hardly did any work.  Note the -1 here: measure all newly created objects as well.  More work, sigh.\";","extra_end = time() + (3600 * 3);","for x in (players)","if (is_player(x) && (time() < extra_end))","\"Robustness as above, plus don't run all day.  My kingdom for a break statement\";","this:summarize_one_user(x, -1);","endif","$command_utils:suspend_if_needed(0);","endfor","endif","$mail_agent:send_message(player, this.report_recipients, \"quota-utils report\", {tostr(\"About to measure objects of player \", this.working.name, \" (\", this.working, \"), \", $string_utils:ordinal(this.working in players), \" out of \", lengthp, \".  We processed \", num_processed + (lengthp * num_repetitions), \" players in this run in \", num_repetitions, \" time\", (num_repetitions == 1) ? \"\" | \"s\", \" through all players.  Total time spent:  \", $time_utils:dhms(time() - start_time), \".\")});","endif"]},{"name":"can_peek","owner":36,"perms":173,"preposition":-1,"code":["return (args[1] == this.owner) || $perm_utils:controls(args[1], args[2]);"]},{"name":"can_touch","owner":36,"perms":173,"preposition":-1,"code":["return args[1].wizard;"]},{"name":"do_breakdown","owner":2,"perms":173,"preposition":-1,"code":["dobj = args[1];","who = valid(caller_perms()) ? caller_perms() | player;","if (!this:can_peek(who, dobj.owner))","return E_PERM;","endif","props = $object_utils:all_properties(dobj);","grand_total = obj_over = this:object_overhead_bytes(dobj);","output = {tostr(\"Object overhead:  \", obj_over)};","if (props)","total = 0;","lines = {};","output = {@output, \"Properties, defined and inherited, sorted by size:\"};","for x in (props)","if (!is_clear_property(dobj, x))","size = value_bytes(dobj.(x));","total = total + size;","if (size)","lines = {@lines, {x, size}};","endif","endif","endfor","lines = $list_utils:reverse($list_utils:sort_suspended(0, lines, $list_utils:slice(lines, 2)));","for x in (lines)","text = tostr(\"  \", x[1], \":  \", x[2]);","output = {@output, text};","endfor","output = {@output, tostr(\"Total size of properties:  \", total)};","grand_total = grand_total + total;","endif","prop_over = this:property_overhead_bytes(dobj, props);","output = {@output, tostr(\"Property overhead:  \", prop_over)};","grand_total = grand_total + prop_over;","if (verbs(dobj))","output = {@output, \"Verbs, sorted by size:\"};","total = 0;","lines = {};","for x in [1..length(verbs(dobj))]","vname = verb_info(dobj, x)[3];","size = (value_bytes(verb_code(dobj, x, 0, 0)) + length(vname)) + 1;","total = total + size;","lines = {@lines, {vname, size}};","endfor","lines = $list_utils:reverse($list_utils:sort_suspended(0, lines, $list_utils:slice(lines, 2)));","for x in (lines)","text = tostr(\"  \", x[1], \":  \", x[2]);","output = {@output, text};","endfor","output = {@output, tostr(\"Total size of verbs:  \", total)};","grand_total = grand_total + total;","verb_over = this:verb_overhead_bytes(dobj);","output = {@output, tostr(\"Verb overhead:  \", verb_over)};","grand_total = grand_total + verb_over;","endif","output = {@output, tostr(\"Grand total:  \", grand_total)};","return output;"]},{"name":"object_overhead_bytes","owner":36,"perms":173,"preposition":-1,"code":["object = args[1];","return ((13 * 4) + length(object.name)) + 1;"]},{"name":"property_overhead_bytes","owner":2,"perms":173,"preposition":-1,"code":["{o, ?ps = $object_utils:all_properties_suspended(o)} = args;","return (value_bytes(properties(o)) - 4) + ((length(ps) * 4) * 4);"]},{"name":"verb_overhead_bytes","owner":2,"perms":173,"preposition":-1,"code":["o = args[1];","vs = verbs(o);","return (length(vs) * 5) * 4;"]},{"name":"add_owned_object","owner":2,"perms":173,"preposition":-1,"code":["\":add_owned_object(who, what) -- adds what to whose .owned_objects.\";","{who, what} = args;","if ((typeof(who.owned_objects) == LIST) && (what.owner == who))","who.owned_objects = setadd(who.owned_objects, what);","endif"]},{"name":"measurement_task_nofork","owner":2,"perms":173,"preposition":-1,"code":["\"This is a one-shot run of the measurement task, as opposed to :measurement_task, which will fork once per day.\";","if (!caller_perms().wizard)","return E_PERM;","else","{num_processed, num_repetitions} = this:measurement_task_body();","$mail_agent:send_message(player, player, \"quota-utils report\", {tostr(\"About to measure objects of player \", this.working.name, \" (\", this.working, \"), \", $string_utils:ordinal(this.working in players), \" out of \", lengthp, \".  We processed \", num_processed + (lengthp * num_repetitions), \" players in this run in \", num_repetitions, \" times through all players.\")});","endif"]},{"name":"measurement_task_body","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return E_PERM;","else","num_processed = 0;","num_repetitions = 0;","usage_index = 2;","time_index = 3;","unmeasured_index = 4;","players = setremove(players(), $hacker);","lengthp = length(players);","index = this.working in players;","keep_going = 1;","if (!index)","\"Uh, oh, our guy got reaped while we weren't looking.  Better look for someone else.\";","index = 1;","while ((this.working > players[index]) && (index < lengthp))","$command_utils:suspend_if_needed(0);","index = index + 1;","endwhile","this.working = players[index];","endif","day = (60 * 60) * 24;","stop = time() + args[1];","early = time() - (day * this.cycle_days);","tooidle = day * this.cycle_days;","\"tooidletime is only used if !this.repeat_cycle.\";","tooidletime = time() - tooidle;","local_per_player_hack = $object_utils:has_verb($local, \"per_player_daily_scan\");","while ((time() < stop) && keep_going)","who = players[index];","if (is_player(who) && $object_utils:has_property(who, \"size_quota\"))","\"Robustness in the face of reaping...\";","if ((!this.repeat_cycle) || ((who.last_disconnect_time > tooidletime) && (who.last_disconnect_time != $maxint)))","\"only measure people who login regularly if we're a big moo.\";","usage = 0;","unmeasured = 0;","earliest = time();","for o in (who.owned_objects)","if ((valid(o) && (o.owner == who)) && (!(o in this.exempted)))","\"sanity check: might have recycled while we suspended!\";","if ($object_utils:has_property(o, \"object_size\"))","if (o.object_size[2] < early)","usage = usage + this:object_bytes(o);","else","usage = usage + o.object_size[1];","earliest = min(earliest, o.object_size[2]);","endif","else","unmeasured = unmeasured + 1;","endif","endif","$command_utils:suspend_if_needed(3);","endfor","if (!is_clear_property(who, \"size_quota\"))","who.size_quota[usage_index] = usage;","who.size_quota[unmeasured_index] = this.unmeasured_multiplier * unmeasured;","who.size_quota[time_index] = earliest;","else","$mail_agent:send_message(player, player, \"Quota Violation\", {tostr(who, \" has a clear .size_quota property.\"), $string_utils:names_of({who, @$object_utils:ancestors(who)})});","endif","elseif (who.size_quota[unmeasured_index])","\"If they managed to create an object *despite* being too idle (presumably programmatically), measure it.\";","this:summarize_one_user(who, -1);","endif","elseif (is_player(who))","\"They don't have a size_quota property.  Whine.\";","$mail_agent:send_message(player, player, \"Quota Violation\", {tostr(who, \" doesn't seem to have a .size_quota property.\"), $string_utils:names_of({who, @$object_utils:ancestors(who)})});","endif","if (local_per_player_hack)","$local:per_player_daily_scan(who);","endif","if (index >= lengthp)","index = 1;","else","index = index + 1;","endif","num_processed = num_processed + 1;","if (num_processed > lengthp)","if (this.repeat_cycle)","\"If we've gotten everyone up to threshold, try measuring some later than that.\";","early = early + ((24 * 60) * 60);","tooidle = tooidle * 4;","tooidletime = tooidletime - tooidle;","num_repetitions = num_repetitions + 1;","num_processed = 0;","if (early > time())","\"Don't spin our wheels when we've measured everything!\";","keep_going = 0;","endif","else","keep_going = 0;","endif","endif","this.working = players[index];","endwhile","return {num_processed, num_repetitions};","endif"]},{"name":"schedule_measurement_task","owner":2,"perms":173,"preposition":-1,"code":["if ((caller == this) || caller_perms().wizard)","day = 24 * 3600;","hour_of_day_GMT = 8;","fork ((((hour_of_day_GMT * 60) * 60) + day) - (time() % day))","this:schedule_measurement_task();","this.measurement_task_running = task_id();","this:measurement_task(this.task_time_limit);","this.measurement_task_running = 0;","endfork","endif"]},{"name":"task_perms","owner":2,"perms":173,"preposition":-1,"code":["\"Put all your wizards in $byte_quota_utils.wizards.  Then various long-running tasks will cycle among the permissions, spreading out the scheduler-induced personal lag.\";","$wiz_utils.old_task_perms_user = setadd($wiz_utils.old_task_perms_user, caller);","return $wiz_utils:random_wizard();"]},{"name":"property_exists","owner":2,"perms":173,"preposition":-1,"code":["\"this:property_exists(object, property)\";","\" => does the specified property exist?\";","return !(!`property_info(@args) ! ANY');"]},{"name":"ensure_props_exist","owner":36,"perms":173,"preposition":-1,"code":["\"*Must* be called with PDATA first, and LINES second.\";","if ((caller != this) && (!caller_perms().wizard))","return E_PERM;","else","try","this.(args[2]);","except (E_PROPNF)","add_property(this, args[2], {}, {$hacker, \"\"});","endtry","try","this.(args[3]);","except (E_PROPNF)","add_property(this, args[3], 5, {$hacker, \"\"});","endtry","endif"]},{"name":"init_for_core","owner":36,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return;","else","for x in (properties(this))","delete_property(this, x);","$command_utils:suspend_if_needed(0);","endfor","endif"]},{"name":"add_data","owner":36,"perms":173,"preposition":-1,"code":["{who, newdata} = args;","if (is_player(who) && caller_perms().wizard)","\"if ($perm_utils:controls(caller_perms(), who) && is_player(who))\";","d = tostr(who, \"pdata\");","l = tostr(who, \"lines\");","this:ensure_props_exist(who, d, l);","data = this.(d);","lines = this.(l);","\"Icky G7 code copied straight out of $player:tell.\";","if (((len = length(this.(d) = {@data, newdata})) * 2) > (lines * 3))","this.(d) = this.(d)[(len - lines) + 1..len];","endif","else","return E_PERM;","endif"]},{"name":"get_data","owner":36,"perms":173,"preposition":-1,"code":["who = args[1];","if ($perm_utils:controls(caller_perms(), who))","d = tostr(who, \"pdata\");","if (typeof(`this.(d) ! ANY') == LIST)","return this.(d);","else","return {};","endif","else","return E_PERM;","endif"]},{"name":"erase_data","owner":36,"perms":173,"preposition":-1,"code":["who = args[1];","if ($perm_utils:controls(caller_perms(), who))","d = tostr(who, \"pdata\");","\"OK if this would toss its cookies if no prop, no damage.\";","`this.(d) = {} ! ANY';","else","return E_PERM;","endif"]},{"name":"set_kept_lines","owner":36,"perms":173,"preposition":-1,"code":["maximum = 20;","who = args[1];","if ($perm_utils:controls(caller_perms(), who) && is_player(who))","l = tostr(who, \"lines\");","this:ensure_props_exist(who, l, l);","this.(l) = min(args[2], maximum);","else","return E_PERM;","endif"]},{"name":"gc","owner":36,"perms":173,"preposition":-1,"code":["if ((((caller != this) && (caller_perms() != #-1)) && (caller_perms() != player)) || (!player.wizard))","$error:raise(E_PERM);","endif","threshold = ((60 * 60) * 24) * 3;","for x in (properties(this))","l = length(x);","who = toobj(x[1..l - 5]);","if (((!valid(who)) || (!is_player(who))) || (!this:is_paranoid(who)))","delete_property(this, x);","else","if (index(x, \"lines\"))","if (typeof(this.(x)) != INT)","this.(x) = 10;","endif","elseif (index(x, \"pdata\"))","if ((who.last_disconnect_time < (time() - threshold)) && (who.last_connect_time < (time() - threshold)))","this.(x) = {};","endif","if (typeof(this.(x)) != LIST)","this.(x) = {};","endif","endif","endif","$command_utils:suspend_if_needed(0);","endfor"]},{"name":"help_msg","owner":2,"perms":173,"preposition":-1,"code":["return this:description();"]},{"name":"semiweeklyish","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return E_PERM;","else","threedays = (3 * 24) * 3600;","fork ((((7 * 60) * 60) + threedays) - (time() % threedays))","this:(verb)();","endfork","this:gc();","endif"]},{"name":"is_paranoid","owner":2,"perms":173,"preposition":-1,"code":["\"Some people make their .paranoid !r.  Wizardly verb to retrieve value.\";","return `args[1].paranoid ! ANY';"]},{"name":"initialize_quota","owner":36,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return E_PERM;","else","args[1].ownership_quota = $wiz_utils.default_player_quota;","endif"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return E_PERM;","else","$quota_utils = this;","endif"]},{"name":"adjust_quota_for_programmer","owner":36,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return E_PERM;","else","victim = args[1];","oldquota = victim.ownership_quota;","if ($object_utils:has_property($local, \"second_char_registry\") && $local.second_char_registry:is_second_char(victim))","\"don't increment quota for 2nd chars when programmering\";","victim.ownership_quota = oldquota;","else","victim.ownership_quota = oldquota + ($wiz_utils.default_programmer_quota - $wiz_utils.default_player_quota);","endif","endif"]},{"name":"bi_create","owner":2,"perms":173,"preposition":-1,"code":["\"Calls built-in create.\";","set_task_perms(caller_perms());","return `create(@args) ! ANY';"]},{"name":"creation_permitted","owner":36,"perms":173,"preposition":-1,"code":["$recycler:check_quota_scam(args[1]);","return args[1].ownership_quota > 0;"]},{"name":"verb_addition_permitted property_addition_permitted","owner":36,"perms":173,"preposition":-1,"code":["return 1;"]},{"name":"display_quota","owner":36,"perms":173,"preposition":-1,"code":["who = args[1];","if (caller_perms() == who)","q = who.ownership_quota;","total = (typeof(who.owned_objects) == LIST) ? length(setremove(who.owned_objects, who)) | 0;","if (q == 0)","player:tell(tostr(\"You can't create any more objects\", (total < 1) ? \".\" | tostr(\" until you recycle some of the \", total, \" you already own.\")));","else","player:tell(tostr(\"You can create \", q, \" new object\", (q == 1) ? \"\" | \"s\", (total == 0) ? \".\" | tostr(\" without recycling any of the \", total, \" that you already own.\")));","endif","else","if ($perm_utils:controls(caller_perms(), who))","player:tell(tostr(who.name, \"'s quota is currently \", who.ownership_quota, \".\"));","else","player:tell(\"Permission denied.\");","endif","endif"]},{"name":"get_quota quota_remaining","owner":36,"perms":173,"preposition":-1,"code":["if ($perm_utils:controls(caller_perms(), args[1]) || (caller == this))","return args[1].ownership_quota;","else","return E_PERM;","endif"]},{"name":"charge_quota","owner":36,"perms":173,"preposition":-1,"code":["\"Charge args[1] for the quota required to own args[2]\";","{who, what} = args;","if ((caller == this) || caller_perms().wizard)","who.ownership_quota = who.ownership_quota - 1;","else","return E_PERM;","endif"]},{"name":"reimburse_quota","owner":36,"perms":173,"preposition":-1,"code":["\"Reimburse args[1] for the quota required to own args[2]\";","{who, what} = args;","if ((caller == this) || caller_perms().wizard)","who.ownership_quota = who.ownership_quota + 1;","else","return E_PERM;","endif"]},{"name":"set_quota","owner":36,"perms":173,"preposition":-1,"code":["\"Set args[1]'s quota to args[2]\";","{who, quota} = args;","if (caller_perms().wizard || (caller == this))","return who.ownership_quota = quota;","else","return E_PERM;","endif"]},{"name":"preliminary_reimburse_quota","owner":36,"perms":173,"preposition":-1,"code":["return 0;"]},{"name":"can_peek","owner":36,"perms":173,"preposition":-1,"code":["\"Is args[1] permitted to examine args[2]'s quota information?\";","return $perm_utils:controls(args[1], args[2]);"]},{"name":"can_touch","owner":36,"perms":173,"preposition":-1,"code":["\"Is args[1] permitted to examine args[2]'s quota information?\";","return args[1].wizard;"]},{"name":"help_msg","owner":36,"perms":173,"preposition":-1,"code":["output = {\"On $server_options, the following settings have been established by the wizards:\", \"\"};","wizonly = {};","etc = {};","mentioned = {};","for x in (setremove(properties(this), \"help_msg\"))","if (index(x, \"protect_\") == 1)","mentioned = {@mentioned, x[9..$]};","wizonly = {@wizonly, tostr(x[9..$], \"() is \", this.(x) ? \"\" | \"not \", \"wizonly.\")};","else","etc = {@etc, tostr(\"$server_options.\", x, \" = \", $string_utils:print(this.(x)))};","endif","endfor","if (\"set_verb_code\" in wizonly)","wizonly = {@wizonly, \"\", \"Note: since the 'set_verb_code' built-in function is wiz-only, then the '.program' built-in command is wiz-only too.\"};","endif","if (bf = $set_utils:intersection(verbs(#0), mentioned))","bf = $list_utils:sort(bf);","etc = {@etc, \"\", \"In your code, #0:(built-in)(@args) should be called rather than built-in(@args) when you would use one of the following built-in functions:\", $string_utils:english_list(bf) + \".\", (((\"Example: #0:\" + bf[1]) + \"(@args) should be used instead of \") + bf[1]) + \"(@args)\"};","endif","return {@this.help_msg, @output, @wizonly, \"\", @etc};"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","raise(E_PERM);","endif","this.support_numeric_verbname_strings = 0;"]},{"name":"list","owner":36,"perms":157,"preposition":3,"code":["\"Copied from Features Feature Object (#24300):list by Joe (#2612) Mon Oct 10 21:07:35 1994 PDT\";","if (this.contents)","player:tell(\".features objects:\");","player:tell(\"----------------------\");","first = 1;","for thing in (this.contents)","$command_utils:kill_if_laggy(10, \"Sorry, the MOO is very laggy, and there are too many feature objects in here to list!\");","$command_utils:suspend_if_needed(0);","if (!first)","player:tell();","endif","player:tell($string_utils:nn(thing), \":\");","`thing:look_self() ! ANY => player:tell(\"<<Error printing description>>\")';","first = 0;","endfor","player:tell(\"----------------------\");","else","player:tell(\"No objects in \", this.name, \".\");","endif"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (!caller_perms().wizard)","return E_PERM;","else","this.(\"@quota\") = {\"*forward*\", \"object-quota\"};","endif"]},{"name":"open","owner":2,"perms":173,"preposition":-1,"code":["if (!this:trusted(caller_perms()))","return E_PERM;","endif","{host, ?user = \"\", ?pass = \"\"} = args;","if (typeof(conn = $network:open(host, this.port)) == ERR)","return {\"Unable to connect to host.\"};","endif","this.connections = {@this.connections, {conn, caller_perms(), {}, 0, {}}};","if (((!this:wait_for_response(conn)) || (user && (!this:do_command(conn, \"USER \" + user)))) || (pass && (!this:do_command(conn, \"PASS \" + pass))))","messages = this:get_messages(conn);","this.connections = listdelete(this.connections, $list_utils:iassoc(conn, this.connections));","$network:close(conn);","return messages;","endif","return conn;"]},{"name":"close","owner":2,"perms":173,"preposition":-1,"code":["conn = args[1];","if (!this:controls(caller_perms(), conn))","return E_PERM;","endif","this:do_command(conn, \"QUIT\");","info = $list_utils:assoc(conn, this.connections);","this.connections = setremove(this.connections, info);","$network:close(conn);","if ($network:is_open(info[4]))","$network:close(info[4]);","endif","return info[3];"]},{"name":"do_command","owner":2,"perms":173,"preposition":-1,"code":["{conn, cmd, ?nowait = 0} = args;","if (!this:controls(caller_perms(), conn))","return E_PERM;","endif","$network:notify(conn, cmd);","return nowait ? 1 | this:wait_for_response(conn);"]},{"name":"wait_for_response","owner":2,"perms":173,"preposition":-1,"code":["{conn, ?first_only = 0} = args;","if (!this:controls(caller_perms(), conn))","return E_PERM;","endif","matchstr = first_only ? \"^[1-9][0-9][0-9] \" | \"^[2-9][0-9][0-9] \";","messages = {};","result = \"\";","while ((typeof(result) == STR) && (!match(result, matchstr)))","result = $network:read(conn);","messages = {@messages, result};","endwhile","i = $list_utils:iassoc(conn, this.connections);","this.connections[i][3] = {@this.connections[i][3], @messages};","if (typeof(result) == STR)","if (result[1] in {\"4\", \"5\"})","player:tell(result);","return E_NONE;","else","return 1;","endif","else","return result;","endif"]},{"name":"controls","owner":2,"perms":173,"preposition":-1,"code":["return args[1].wizard || ({@$list_utils:assoc(args[2], this.connections), 0, 0}[2] == args[1]);"]},{"name":"get_messages","owner":2,"perms":173,"preposition":-1,"code":["{conn, ?keep = 0} = args;","if (!this:controls(caller_perms(), conn))","return E_PERM;","endif","i = $list_utils:iassoc(conn, this.connections);","messages = this.connections[i][3];","if (!keep)","this.connections[i][3] = {};","endif","return messages;"]},{"name":"open_data","owner":2,"perms":173,"preposition":-1,"code":["conn = args[1];","if (!this:controls(caller_perms(), conn))","return E_PERM;","endif","i = $list_utils:iassoc(conn, this.connections);","if (!$network:is_open(this.connections[i][4]))","this:do_command(conn, \"PASV\");","msg = (msg = this:get_messages(conn, 1))[$];","if (msg[1..3] != \"227\")","return E_TYPE;","elseif (!(match = match(msg, \"(%([0-9]+%),%([0-9]+%),%([0-9]+%),%([0-9]+%),%([0-9]+%),%([0-9]+%))\")))","return E_TYPE;","elseif (typeof(dconn = $network:open(substitute(\"%1.%2.%3.%4\", match), (toint(substitute(\"%5\", match)) * 256) + toint(substitute(\"%6\", match)))) == ERR)","return dconn;","else","this.connections[i][4] = dconn;","endif","this.connections[i][5] = E_INVARG;","set_task_perms(caller_perms());","fork (0)","this:listen(conn, dconn);","endfork","endif","return 1;"]},{"name":"get_data","owner":2,"perms":173,"preposition":-1,"code":["{conn, ?nowait = 0} = args;","if (!this:controls(caller_perms(), conn))","return E_PERM;","endif","i = $list_utils:iassoc(conn, this.connections);","while ((!nowait) && (this.connections[i][5] == E_INVARG))","suspend(0);","endwhile","return this.connections[i][5];"]},{"name":"put_data","owner":2,"perms":173,"preposition":-1,"code":["{conn, data} = args;","if (!this:controls(caller_perms(), conn))","return E_PERM;","endif","i = $list_utils:iassoc(conn, this.connections);","dconn = this.connections[i][4];","if (!$network:is_open(dconn))","return E_INVARG;","else","for line in (data)","notify(dconn, line);","$command_utils:suspend_if_needed(0);","endfor","this:close_data(conn);","this.connections[i][4] = 0;","endif"]},{"name":"trusted","owner":2,"perms":173,"preposition":-1,"code":["return args[1].wizard || ((typeof(this.trusted) == LIST) ? args[1] in this.trusted | this.trusted);"]},{"name":"listen","owner":2,"perms":173,"preposition":-1,"code":["if (caller != this)","return E_PERM;","endif","{conn, dconn} = args;","data = {};","line = `read(dconn) ! ANY';","while (typeof(line) == STR)","data = {@data, line};","line = read(dconn);","$command_utils:suspend_if_needed(0);","endwhile","if (i = $list_utils:iassoc(conn, this.connections))","this.connections[i][5] = data;","endif"]},{"name":"close_data","owner":2,"perms":173,"preposition":-1,"code":["conn = args[1];","if (!this:controls(caller_perms(), conn))","return E_PERM;","endif","if (!$network:is_open(dconn = $list_utils:assoc(conn, this.connections)[4]))","return E_INVARG;","else","$network:close(dconn);","\"...let the reading task come to terms with its abrupt superfluousness...\";","suspend(0);","return 1;","endif"]},{"name":"get","owner":2,"perms":173,"preposition":-1,"code":["\":get(host, username, password, filename)\";","if (!this:trusted(caller_perms()))","return E_PERM;","endif","if (typeof(conn = this:open(@args[1..3])) != OBJ)","return E_NACC;","else","result = (this:open_data(conn) && this:do_command(conn, \"RETR \" + args[4])) && this:get_data(conn);","this:close(conn);","return result;","endif"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","this.connections = {};","this.trusted = 1;","pass(@args);","endif"]},{"name":"put","owner":2,"perms":173,"preposition":-1,"code":["\":put(host, username, password, filename, data)\";","if (!this:trusted(caller_perms()))","return E_PERM;","endif","if (typeof(conn = this:open(@args[1..3])) != OBJ)","return E_NACC;","else","result = (this:open_data(conn) && this:do_command(conn, \"STOR \" + args[4], 1)) && this:put_data(conn, args[5]);","this:close(conn);","return result;","endif"]},{"name":"data_connection","owner":2,"perms":173,"preposition":-1,"code":["\"return the data connection associated with the control connection args[1]\";","conn = args[1];","i = $list_utils:iassoc(conn, this.connections);","return this.connections[i][4];"]},{"name":"help_msg","owner":36,"perms":173,"preposition":-1,"code":["if (typeof(base = this.(verb)) == STR)","base = {base};","endif","base = {@base, \"\", tostr(\".minimum_password_length = \", toliteral(x = this.minimum_password_length)), x ? tostr(\"Passwords are required to be a minimum of \", $string_utils:english_number(x), \" characters in length.\") | \"There is no minimum length requirement for passwords.\"};","base = {@base, \"\", tostr(\".check_against_moo = \", toliteral(x = this.check_against_moo)), tostr(\"Passwords \", x ? \"may not\" | \"may\", \" be variants on the MOO's name (\", $network.MOO_name, \").\")};","base = {@base, \"\", tostr(\".check_against_name = \", toliteral(x = this.check_against_name)), tostr(\"Passwords \", x ? \"may not\" | \"may\", \" be variants on the player's MOO name and/or aliases.\")};","base = {@base, \"\", tostr(\".check_against_email = \", toliteral(x = this.check_against_email)), x ? \"Passwords may not be variants on the player's email address.\" | \"Passwords are not checked against the player's email address.\"};","base = {@base, \"\", tostr(\".check_against_hosts = \", toliteral(x = this.check_against_hosts)), x ? \"Passwords may not be variants on the player's hostname(s).\" | \"Passwords are not checked against the player's hostname(s).\"};","base = {@base, \"\", tostr(\".check_against_dictionary = \", toliteral(x = this.check_against_dictionary)), tostr(\"Passwords \", (typeof(x) in {LIST, OBJ}) ? \"may not\" | \"may\", \" be dictionary words.\", (x && (!$network.active)) ? \"  (This option is set but unavailable.)\" | \"\")};","base = {@base, \"\", tostr(\".require_funky_characters = \", toliteral(x = this.require_funky_characters)), tostr(\"Non-alphabetic characters are \", x ? \"\" | \"not \", \"required in passwords.\")};","base = {@base, \"\", tostr(\".check_obscure_stuff = \", toliteral(x = this.check_obscure_stuff)), x ? \"Misc. obscure checks enabled\" | \"No obscure checks in use.\"};","return base;"]},{"name":"reject_password","owner":2,"perms":173,"preposition":-1,"code":["\":reject_password ( STR password [ , OBJ for-whom ] );\";","\"=> string value [if the password is rejected, why?]\";","\"=> false value [if the password isn't rejected]\";","if (length(args) == 1)","trust = 0;","else","if ($perm_utils:controls(caller_perms(), args[2]))","trust = 1;","else","return \"Permissions don't permit setting of that password.\";","endif","endif","\"this is gonna be huge\";","return (((((((this:trivial_check(@args) || (this.minimum_password_length && this:check_length(@args))) || ((this.check_against_name && trust) && this:check_name(@args))) || ((this.check_against_email && trust) && this:check_email(@args))) || ((this.check_against_hosts && trust) && this:check_hosts(@args))) || ((typeof(this.check_against_dictionary) in {LIST, OBJ}) && this:check_dictionary(@args))) || (this.require_funky_characters && this:check_for_funky_characters(@args))) || (this.check_against_moo && this:check_against_moo(@args))) || (this.check_obscure_stuff && this:check_obscure_combinations(@args));"]},{"name":"trivial_check","owner":36,"perms":173,"preposition":-1,"code":["if (typeof(pwd = args[1]) != STR)","return \"Passwords must be strings.\";","elseif (index(pwd, \" \"))","return \"Passwords may not contain spaces.\";","elseif (length(args) == 2)","if (((typeof(who = args[2]) != OBJ) || (!valid(who))) || (!is_player(who)))","return \"That's not a player.\";","elseif (!$perm_utils:controls(caller_perms(), who))","return \"You can't set the password for that player.\";","elseif ($object_utils:isa(who, $guest))","return \"Sorry, but guest characters are not allowed to change their passwords.\";","endif","endif"]},{"name":"check_length","owner":36,"perms":173,"preposition":-1,"code":["if ((l = this.minimum_password_length) && (length(args[1]) < l))","return tostr(\"Passwords must be a minimum of \", $string_utils:english_number(l), (l == 1) ? \" character \" | \" characters \", \"long.\");","endif"]},{"name":"check_name","owner":36,"perms":173,"preposition":-1,"code":["pwd = args[1];","if (valid($player_db:find_exact(pwd)))","return \"Passwords may not be close to a player's name/alias pair.\";","elseif (valid($player_db:find($string_utils:reverse(pwd))))","return \"Passwords ought not be the reverse of a player's name/alias.\";","endif"]},{"name":"check_email","owner":2,"perms":173,"preposition":-1,"code":["{pwd, who} = args;","if (!$perm_utils:controls(caller_perms(), who))","return \"Permission denied.\";","endif","email = $wiz_utils:get_email_address(who);","if (!email)","\"can't check\";","return;","endif","if (index(email, pwd))","return \"Passwords can't match your registered email address.\";","endif"]},{"name":"check_hosts","owner":2,"perms":173,"preposition":-1,"code":["{pwd, who} = args;","if (!$perm_utils:controls(caller_perms(), who))","return \"Permission denied.\";","endif","hosts = who.all_connect_places;","for x in (hosts)","if (index(x, pwd))","return \"Passwords may not match hostnames.\";","endif","endfor"]},{"name":"check_dictionary","owner":36,"perms":173,"preposition":-1,"code":["pwd = args[1];","if ((typeof(dict = this.check_against_dictionary) == LIST) && $network.active)","\"assume we're checking an on-line dictionary\";","dict[3] = dict[3] + pwd;","result = $gopher:get(@dict);","if (typeof(result) == ERR)","\"we probably can't check the dictionary anyway\";","return;","elseif ((result[1] && (result[1][1] != \"0\")) && (!this:_is_funky_case(pwd)))","return \"Dictionary words are not permitted for passwords.\";","endif","elseif (typeof(dict) == OBJ)","\"assume we're checking mr spell\";","try","if (dict:find_exact(pwd) && (!this:_is_funky_case(pwd)))","return \"Dictionary words are not permitted for passwords.\";","endif","except (ANY)","\"in case this is messed up. Just let it go and return 0;\";","endtry","endif"]},{"name":"check_for_funky_characters","owner":36,"perms":173,"preposition":-1,"code":["if (this:_is_funky_case(pwd = args[1]))","return;","endif","alphabet = $string_utils.alphabet;","for i in [1..length(pwd)]","if (!index(alphabet, pwd[i]))","return;","endif","endfor","return \"At least one unusual capitalization and/or numeric or punctuation character is required.\";"]},{"name":"check_against_moo","owner":36,"perms":173,"preposition":-1,"code":["pwd = args[1];","moo = $network.MOO_Name;","if (this:_is_funky_case(pwd))","return;","endif","if (pwd == moo)","return \"The MOO's name is not secure as a password.\";","endif","if (moo[$ - 2..$] == \"MOO\")","if (pwd == moo[1..$ - 3])","return \"The MOO's name is not secure as a password.\";","endif","endif"]},{"name":"_is_funky_case","owner":36,"perms":173,"preposition":-1,"code":["pwd = args[1];","if (!strcmp(pwd, u = $string_utils:uppercase(pwd)))","return 0;","elseif (!strcmp(pwd, l = $string_utils:lowercase(pwd)))","return 0;","elseif (!strcmp(pwd, tostr(u[1], l[2..$])))","return 0;","else","return 1;","endif"]},{"name":"check_obscure_combinations","owner":36,"perms":173,"preposition":-1,"code":["pwd = args[1];","if (match(pwd, \"^[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]$\"))","return \"Social security numbers are potentially insecure passwords.\";","elseif (match(pwd, \"^[0-9]+/[0-9]+/[0-9]+$\"))","return \"Passwords which look like dates are potentially insecure passwords.\";","endif"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","pass(@args);","this.minimum_password_length = this.check_against_name = this.check_against_email = this.check_against_hosts = this.check_against_dictionary = this.require_funky_characters = this.check_against_moo = this.check_obscure_stuff = 0;","endif"]},{"name":"set_gender","owner":2,"perms":173,"preposition":-1,"code":["\"set_gender(newgender) attempts to change this.gender to newgender\";","\"  => E_PERM   if you don't own this or aren't its parent\";","\"  => Other return values as from $gender_utils:set.\";","if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))","return E_PERM;","else","result = $gender_utils:set(this, args[1]);","this.gender = (typeof(result) == STR) ? result | args[1];","return result;","endif"]},{"name":"@gen*der","owner":2,"perms":105,"preposition":12,"code":["if (player.wizard || (player == this.owner))","player:tell(this:set_gender(iobjstr) ? \"Gender and pronouns set.\" | \"Gender set.\");","else","player:tell(\"Permission denied.\");","endif"]},{"name":"verb_sub","owner":2,"perms":173,"preposition":-1,"code":["\"Copied from generic player (#6):verb_sub by ur-Rog (#6349) Fri Jan 22 11:20:11 1999 PST\";","\"This verb was copied by TheCat on 01/22/99, so that the generic gendered object will be able to do verb conjugation as well as pronoun substitution.\";","text = args[1];","if (a = `$list_utils:assoc(text, this.verb_subs) ! ANY')","return a[2];","else","return $gender_utils:get_conj(text, this);","endif"]},{"name":"@rooms","owner":36,"perms":13,"preposition":-1,"code":["\"'@rooms' - List the rooms which are known by name.\";","line = \"\";","for item in (this.rooms)","line = (((line + item[1]) + \"(\") + tostr(item[2])) + \")   \";","endfor","player:tell(line);"]},{"name":"names_of","owner":36,"perms":173,"preposition":-1,"code":["\"Return a string giving the names of the objects in a list. Now on $string_utils\";","return $string_utils:names_of(@args);"]},{"name":"@go","owner":36,"perms":29,"preposition":-1,"code":["\"'@go <place>' - Teleport yourself somewhere. Example: '@go liv' to go to the living room.\";","dest = this:lookup_room(dobjstr);","if (dest == $failed_match)","player:tell(\"There's no such place known.\");","else","this:teleport(player, dest);","endif"]},{"name":"lookup_room","owner":36,"perms":173,"preposition":-1,"code":["\"Look up a room in your personal database of room names, returning its object number. If it's not in your database, it checks to see if it's a number or a nearby object.\";","room = args[1];","if (room == \"home\")","return player.home;","elseif (room == \"me\")","return player;","elseif (room == \"here\")","return player.location;","elseif (!room)","return $failed_match;","endif","index = this:index_room(room);","if (index)","return this.rooms[index][2];","else","return this:my_match_object(room);","\"old code no longer used, 2/11/96 Heathcliff\";","source = player.location;","if (!(valid(source) && ($room in $object_utils:ancestors(source))))","source = $room;","endif","return source:match_object(room);","endif"]},{"name":"teleport","owner":2,"perms":173,"preposition":-1,"code":["\"Teleport a player or object. For printing messages, there are three cases: (1) teleport self (2) teleport other player (3) teleport object. There's a spot of complexity for handling the invalid location #-1.\";","set_task_perms((caller == this) ? this | $no_one);","{thing, dest} = args;","source = thing.location;","if (valid(dest))","dest_name = dest.name;","else","dest_name = tostr(dest);","endif","if (source == dest)","player:tell(thing.name, \" is already at \", dest_name, \".\");","return;","endif","thing:moveto(dest);","if (thing.location == dest)","tsd = {thing, source, dest};","if (thing == player)","this:teleport_messages(@tsd, this:self_port_msg(@tsd), this:oself_port_msg(@tsd), this:self_arrive_msg(@tsd), \"\");","elseif (is_player(thing))","this:teleport_messages(@tsd, this:player_port_msg(@tsd), this:oplayer_port_msg(@tsd), this:player_arrive_msg(@tsd), this:victim_port_msg(@tsd));","else","this:teleport_messages(@tsd, this:thing_port_msg(@tsd), this:othing_port_msg(@tsd), this:thing_arrive_msg(@tsd), this:object_port_msg(@tsd));","endif","elseif (thing.location == source)","if ($object_utils:contains(thing, dest))","player:tell(\"Ooh, it's all twisty. \", dest_name, \" is inside \", thing.name, \".\");","else","if ($object_utils:has_property(thing, \"po\"))","pronoun = thing.po;","else","pronoun = \"it\";","endif","player:tell(\"Either \", thing.name, \" doesn't want to go, or \", dest_name, \" didn't accept \", pronoun, \".\");","endif","else","thing_name = (thing == player) ? \"you\" | thing.name;","player:tell(\"A strange force deflects \", thing_name, \" from the destination.\");","endif"]},{"name":"teleport_messages","owner":36,"perms":173,"preposition":-1,"code":["\"Send teleport messages. There's a slight complication in that the source and dest need not be valid objects.\";","{thing, source, dest, pmsg, smsg, dmsg, tmsg} = args;","if (pmsg)","\"The player's own message.\";","player:tell(pmsg);","endif","if (smsg)","`source:room_announce_all_but({thing, player}, smsg) ! E_VERBNF, E_INVIND';","endif","if (dmsg)","`dest:room_announce_all_but({thing, player}, dmsg) ! E_VERBNF, E_INVIND';","endif","if (tmsg)","\"A message to the victim being teleported.\";","thing:tell(tmsg);","endif"]},{"name":"@move","owner":36,"perms":93,"preposition":-2,"code":["\"'@move <object> to <place>' - Teleport an object. Example: '@move trash to #11' to move trash to the closet.\";","here = player.location;","if ((prepstr != \"to\") || (!iobjstr))","player:tell(\"Usage: @move <object> to <location>\");","return;","endif","if ((!dobjstr) || (dobjstr == \"me\"))","thing = this;","else","thing = `here:match_object(dobjstr) ! E_VERBNF, E_INVIND => $failed_match';","if (thing == $failed_match)","thing = player:my_match_object(dobjstr);","endif","endif","if ($command_utils:object_match_failed(thing, dobjstr))","return;","endif","if ((!player.programmer) && ((thing.owner != player) && (thing != player)))","player:tell(\"You can only move your own objects.\");","return;","endif","dest = this:lookup_room(iobjstr);","if ((dest == #-1) || (!$command_utils:object_match_failed(dest, iobjstr)))","this:teleport(thing, dest);","endif"]},{"name":"index_room","owner":36,"perms":173,"preposition":-1,"code":["\"'index_room (<room name>)' - Look up a room in your personal database of room names, returning its index in the list. Return 0 if it is not in the list. If the room name is the empty string, then only exact matches are considered; otherwise, a leading match is good enough.\";","room = tostr(args[1]);","size = length(room);","index = 1;","match = 0;","for item in (this.rooms)","item_name = item[1];","if (room == item_name)","return index;","elseif ((size && (length(item_name) >= size)) && (room == item_name[1..size]))","match = index;","endif","index = index + 1;","endfor","return match;"]},{"name":"@addr*oom","owner":36,"perms":29,"preposition":-1,"code":["\"'@addroom <name> <object>', '@addroom <object> <name>', '@addroom <name>', '@addroom <object>', '@addroom' - Add a room to your personal database of teleport destinations. Example: '@addroom Kitchen #24'. Reasonable <object>s are numbers (#17) and 'here'. If you leave out <object>, the object is the current room. If you leave out <name>, the name is the specified room's name. If you leave out both, you get the current room and its name.\";","if (((!caller) && (player != this)) || (caller && (callers()[1][3] != this)))","if (!caller)","player:tell(E_PERM);","endif","return E_PERM;","endif","if (!dobjstr)","object = this.location;","name = valid(object) ? object.name | \"Nowhere\";","elseif (command = this:parse_out_object(dobjstr))","name = command[1];","object = command[2];","else","name = dobjstr;","object = this.location;","endif","if (!valid(object))","player:tell(\"This is not a valid location.\");","return E_INVARG;","endif","player:tell(\"Adding \", name, \"(\", tostr(object), \") to your database of rooms.\");","this.rooms = {@this.rooms, {name, object}};"]},{"name":"@rmr*oom","owner":36,"perms":29,"preposition":-1,"code":["\"'@rmroom <roomname>' - Remove a room from your personal database of teleport destinations. Example: '@rmroom library'.\";","if (((!caller) && (player != this)) || (caller && (callers()[1][3] != this)))","if (!caller)","player:tell(E_PERM);","endif","return E_PERM;","endif","index = this:index_room(dobjstr);","if (index)","player:tell(\"Removing \", this.rooms[index][1], \"(\", this.rooms[index][2], \").\");","this.rooms = listdelete(this.rooms, index);","else","player:tell(\"That room is not in your database of rooms. Check '@rooms'.\");","endif"]},{"name":"@join","owner":36,"perms":29,"preposition":-1,"code":["\"'@join <player>' - Teleport yourself to the location of any player, whether connected or not.\";","if (dobjstr == \"\")","player:tell(\"Usage: @join <player>. For example, '@join frand'.\");","return;","endif","target = $string_utils:match_player(dobjstr);","$command_utils:player_match_result(target, dobjstr);","if (valid(target))","if (target == this)","if (player == this)","player:tell(\"There is little need to join yourself, unless you are split up.\");","else","player:tell(\"No thank you. Please get your own join verb.\");","endif","return;","endif","dest = target.location;","msg = this:enlist(this:join_msg());","editing = $object_utils:isa(dest, $generic_editor);","if (editing)","dest = dest.original[target in dest.active];","editing_msg = \"%N is editing at the moment. You can wait here until %s is done.\";","if (player.location == dest)","msg = {editing_msg};","else","msg = {@msg, editing_msg};","endif","endif","if (msg && ((player.location != dest) || editing))","player:tell_lines($string_utils:pronoun_sub(msg, target));","elseif (player.location == dest)","player:tell(\"OK, you're there. You didn't need to actually move, though.\");","return;","endif","this:teleport(player, dest);","endif"]},{"name":"@find","owner":36,"perms":29,"preposition":-1,"code":["\"'@find #<object>', '@find <player>', '@find :<verb>' '@find .<property>' - Attempt to locate things. Verbs and properties are found on any object in the player's vicinity, and some other places.  '@find ?<help>' looks for a help topic on any available help database.\";","if (!dobjstr)","player:tell(\"Usage: '@find #<object>' or '@find <player>' or '@find :<verb>' or '@find .<property>' or '@find ?<help topic>'.\");","return;","endif","if (dobjstr[1] == \":\")","name = dobjstr[2..$];","this:find_verb(name);","return;","elseif (dobjstr[1] == \".\")","name = dobjstr[2..$];","this:find_property(name);","return;","elseif (dobjstr[1] == \"#\")","target = toobj(dobjstr);","if (!valid(target))","player:tell(target, \" does not exist.\");","endif","elseif (dobjstr[1] == \"?\")","name = dobjstr[2..$];","this:find_help(name);","return;","else","target = $string_utils:match_player(dobjstr);","$command_utils:player_match_result(target, dobjstr);","endif","if (valid(target))","player:tell(target.name, \" (\", target, \") is at \", valid(target.location) ? target.location.name | \"Nowhere\", \" (\", target.location, \").\");","endif"]},{"name":"find_verb","owner":36,"perms":173,"preposition":-1,"code":["\"'find_verb (<name>)' - Search for a verb with the given name. The objects searched are those returned by this:find_verbs_on(). The printing order relies on $list_utils:remove_duplicates to leave the *first* copy of each duplicated element in a list; for example, {1, 2, 1} -> {1, 2}, not to {2, 1}.\";","name = args[1];","results = \"\";","objects = $list_utils:remove_duplicates(this:find_verbs_on());","for thing in (objects)","if (valid(thing) && (mom = $object_utils:has_verb(thing, name)))","results = ((((results + \"   \") + thing.name) + \"(\") + tostr(thing)) + \")\";","mom = mom[1];","if (thing != mom)","results = ((((results + \"--\") + mom.name) + \"(\") + tostr(mom)) + \")\";","endif","endif","endfor","if (results)","this:tell(\"The verb :\", name, \" is on\", results);","else","this:tell(\"The verb :\", name, \" is nowhere to be found.\");","endif"]},{"name":"@ways","owner":36,"perms":29,"preposition":-1,"code":["\"'@ways', '@ways <room>' - List any obvious exits from the given room (or this room, if none is given).\";","if (dobjstr)","room = dobj;","else","room = this.location;","endif","if ((!valid(room)) || (!($room in $object_utils:ancestors(room))))","player:tell(\"You can only pry into the exits of a room.\");","return;","endif","exits = {};","if ($object_utils:has_verb(room, \"obvious_exits\"))","exits = room:obvious_exits();","endif","exits = this:checkexits(this:obvious_exits(), room, exits);","exits = this:findexits(room, exits);","this:tell_ways(exits, room);"]},{"name":"findexits","owner":36,"perms":173,"preposition":-1,"code":["\"Add to the 'exits' list any exits in the room which have a single-letter alias.\";","{room, exits} = args;","alphabet = \"abcdefghijklmnopqrstuvwxyz0123456789\";","for i in [1..length(alphabet)]","found = room:match_exit(alphabet[i]);","if (valid(found) && (!(found in exits)))","exits = {@exits, found};","endif","endfor","return exits;"]},{"name":"checkexits","owner":36,"perms":173,"preposition":-1,"code":["\"Check a list of exits to see if any of them are in the given room.\";","{to_check, room, exits} = args;","for word in (to_check)","found = room:match_exit(word);","if (valid(found) && (!(found in exits)))","exits = {@exits, found};","endif","endfor","return exits;"]},{"name":"self_port_msg player_port_msg thing_port_msg join_msg","owner":36,"perms":173,"preposition":-1,"code":["\"This verb returns messages that go only to you. You don't need to have your name tacked on to the beginning of these. Heh.\";","msg = this.(verb);","if (msg && (length(args) >= 3))","msg = this:msg_sub(msg, @args);","endif","return msg;"]},{"name":"oself_port_msg self_arrive_msg oplayer_port_msg player_arrive_msg victim_port_msg othing_port_msg thing_arrive_msg object_port_msg","owner":36,"perms":173,"preposition":-1,"code":["\"This verb returns messages that go to other players. It does pronoun substitutions; if your name is not included in the final string, it adds the name in front.\";","msg = this.(verb);","if (!msg)","msg = $frand_class.(verb);","endif","if (length(args) >= 3)","msg = this:msg_sub(msg, @args);","endif","if (!$string_utils:index_delimited(msg, player.name))","msg = (player.name + \" \") + msg;","endif","return msg;"]},{"name":"msg_sub","owner":36,"perms":173,"preposition":-1,"code":["\"Do pronoun and other substitutions on the teleport messages. The arguments are: 1. The original message, before any substitutions; 2. object being teleported; 3. from location; 4. to location. The return value is the final message.\";","{msg, thing, from, to} = args;","msg = $string_utils:substitute(msg, $string_utils:pronoun_quote({{\"%<from room>\", valid(from) ? from.name | \"Nowhere\"}, {\"%<to room>\", valid(to) ? to.name | \"Nowhere\"}}));","msg = $string_utils:pronoun_sub(msg, thing);","return msg;"]},{"name":"obvious_exits","owner":36,"perms":173,"preposition":-1,"code":["\"'obvious_exits()' - Return a list of common exit names which are obviously worth looking for in a room.\";","return {\"n\", \"ne\", \"e\", \"se\", \"s\", \"sw\", \"w\", \"nw\", \"north\", \"northeast\", \"east\", \"southeast\", \"south\", \"southwest\", \"west\", \"northwest\", \"u\", \"d\", \"up\", \"down\", \"out\", \"exit\", \"leave\", \"enter\"};"]},{"name":"tell_ways","owner":36,"perms":173,"preposition":-1,"code":["\":tell_ways (<list of exits>)' - Tell yourself a list of exits, for @ways. You can override it to print the exits in any format.\";","exits = args[1];","answer = {};","for e in (exits)","answer = {@answer, ((e.name + \" (\") + $string_utils:english_list(e.aliases)) + \")\"};","endfor","player:tell(\"Obvious exits: \", $string_utils:english_list(answer), \".\");"]},{"name":"tell_obj","owner":36,"perms":173,"preposition":-1,"code":["\"Return the name and number of an object, e.g. 'Root Class (#1)'.\";","o = args[1];","return (((valid(o) ? o.name | \"Nothing\") + \" (\") + tostr(o)) + \")\";"]},{"name":"parse_out_object","owner":36,"perms":173,"preposition":-1,"code":["\"'parse_out_object (<string>)' -> {<name>, <object>}, or 0. Given a string, attempt to find an object at its beginning or its end. An object can be either an object number, or 'here'. If this succeeds, return a list of the object and the unmatched part of the string, called the name. If it fails, return 0.\";","words = $string_utils:words(args[1]);","if (!length(words))","return 0;","endif","word1 = words[1];","wordN = words[$];","if (length(word1) && (word1[1] == \"#\"))","start = 2;","finish = length(words);","what = toobj(word1);","elseif (word1 == \"here\")","start = 2;","finish = length(words);","what = this.location;","elseif (length(wordN) && (wordN[1] == \"#\"))","start = 1;","finish = length(words) - 1;","what = toobj(wordN);","elseif (wordN == \"here\")","start = 1;","finish = length(words) - 1;","what = this.location;","else","return 0;","endif","\"toobj() has the nasty property that invalid strings get turned into #0. Here we just pretend that all references to #0 are actually meant for #-1.\";","if (what == #0)","what = $nothing;","endif","name = $string_utils:from_list(words[start..finish], \" \");","if (!name)","name = valid(what) ? what.name | \"Nowhere\";","endif","return {name, what};"]},{"name":"enlist","owner":36,"perms":173,"preposition":-1,"code":["\"'enlist (<x>)' - If x is a list, just return it; otherwise, return {x}. The purpose here is to turn message strings into lists, so that lines can be added. It is not guaranteed to work for non-string non-lists.\";","x = args[1];","if (!x)","return {};","elseif (typeof(x) == LIST)","return x;","else","return {x};","endif"]},{"name":"@spellm*essages @spellp*roperties","owner":2,"perms":89,"preposition":-2,"code":["\"@spellproperties <object>\";","\"@spellmessages <object>\";","\"Spell checks the string properties of an object, or the subset of said properties which are suffixed _msg, respectively.\";","set_task_perms(player);","if (!dobjstr)","player:notify(tostr(\"Usage: \", verb, \" <object>\"));","return;","elseif ($command_utils:object_match_failed(dobj = player:my_match_object(dobjstr), dobjstr))","return;","elseif (typeof(props = $object_utils:all_properties(dobj)) == ERR)","player:notify(\"Permission denied to read properties on that object.\");","return;","endif","props = setremove(props, \"messages\");","if (verb[1..7] == \"@spellm\")","spell = {};","for prop in (props)","if ((index(prop, \"_msg\") == (length(prop) - 3)) && index(prop, \"_msg\"))","spell = {@spell, prop};","endif","endfor","props = spell;","endif","if (props == {})","player:notify(tostr(\"No \", (verb[1..7] == \"@spellm\") ? \"messages\" | \"properties\", \" found to spellcheck on \", dobj, \".\"));","return;","endif","for data in (props)","if (typeof(dd = `dobj.(data) ! ANY') == LIST)","text = {};","for linenum in (dd)","text = listappend(text, linenum);","endfor","elseif ((((typeof(dd) == OBJ) || (typeof(dd) == INT)) || (typeof(dd) == ERR)) || (typeof(dd) == FLOAT))","text = \"\";","elseif (typeof(dd) == STR)","text = dd;","endif","if (typeof(text) == STR)","text = {text};","endif","linenumber = 0;","for thisline in (text)","$command_utils:suspend_if_needed(0);","linenumber = linenumber + 1;","if (((((typeof(thisline) != LIST) && (typeof(thisline) != OBJ)) && (typeof(thisline) != INT)) && (typeof(thisline) != FLOAT)) && (typeof(thisline) != ERR))","i = $string_utils:strip_chars(thisline, \"!@#$%^&*()_+1234567890={}[]<>?:;,./|\\\"~'\");","if (i)","i = $string_utils:words(i);","for ii in [1..length(i)]","$command_utils:suspend_if_needed(0);","if (!$spell:valid(i[ii]))","if ((rindex(i[ii], \"s\") == length(i[ii])) && $spell:valid(i[ii][1..$ - 1]))","msg = \"Possible match: \" + i[ii];","elseif ((rindex(i[ii], \"'s\") == (length(i[ii]) - 1)) && $spell:valid(i[ii][1..$ - 2]))","msg = \"Possible match: \" + i[ii];","else","msg = \"Unknown word: \" + i[ii];","endif","if (length(text) == 1)","foo = \": \";","else","foo = (\" (line \" + tostr(linenumber)) + \"): \";","endif","player:notify(tostr(dobj, \".\", data, foo, msg));","endif","endfor","endif","endif","endfor","endfor","player:notify(tostr(\"Done spellchecking \", dobj, \".\"));"]},{"name":"@at","owner":36,"perms":93,"preposition":-2,"code":["\"'@at' - Find out where everyone is. '@at <player>' - Find out where <player> is, and who else is there. '@at <obj>' - Find out who else is at the same place as <obj>. '@at <place>' - Find out who is at the place. The place can be given by number, or it can be a name from your @rooms list. '@at #-1' - Find out who is at #-1. '@at me' - Find out who is in the room with you. '@at home' - Find out who is at your home.\";","this:internal_at(argstr);"]},{"name":"at_players","owner":36,"perms":173,"preposition":-1,"code":["\"'at_players ()' - Return a list of players to be displayed by @at.\";","return connected_players();"]},{"name":"do_at_all","owner":36,"perms":173,"preposition":-1,"code":["\"'do_at_all ()' - List where everyone is, sorted by popularity of location. This is called when you type '@at'.\";","locations = {};","parties = {};","counts = {};","for who in (this:at_players())","loc = who.location;","if (i = loc in locations)","parties[i] = setadd(parties[i], who);","counts[i] = counts[i] - 1;","else","locations = {@locations, loc};","parties = {@parties, {who}};","counts = {@counts, 0};","endif","endfor","locations = $list_utils:sort(locations, counts);","parties = $list_utils:sort(parties, counts);","this:print_at_items(locations, parties);"]},{"name":"do_at","owner":36,"perms":173,"preposition":-1,"code":["\"'do_at (<location>)' - List the players at a given location.\";","loc = args[1];","party = {};","for who in (this:at_players())","if (who.location == loc)","party = setadd(party, who);","endif","endfor","this:print_at_items({loc}, {party});"]},{"name":"print_at_items","owner":36,"perms":173,"preposition":-1,"code":["\"'print_at_items (<locations>, <parties>)' - Print a list of locations and people, for @at. Override this if you want to make a change to @at's output that you can't make in :at_item.\";","{locations, parties} = args;","for i in [1..length(locations)]","$command_utils:suspend_if_needed(0);","player:tell_lines(this:at_item(locations[i], parties[i]));","endfor"]},{"name":"at_item","owner":36,"perms":173,"preposition":-1,"code":["\"'at_item (<location>, <party>)' - Given a location and a list of the people there, return a string displaying the information. Override this if you want to change the format of each line of @at's output.\";","{loc, party} = args;","su = $string_utils;","if (this.at_number)","number = su:right(tostr(loc), 7) + \" \";","else","number = \"\";","endif","room = su:left(valid(loc) ? loc.name | \"[Nowhere]\", this.at_room_width);","if (length(room) > this.at_room_width)","room = room[1..this.at_room_width];","endif","text = (number + room) + \" \";","if (party)","filler = su:space(length(text) - 2);","line = text;","text = {};","for who in (party)","name = \" \" + (valid(who) ? who.name | \"[Nobody]\");","if ((length(line) + length(name)) > this:linelen())","text = {@text, line};","line = filler + name;","else","line = line + name;","endif","endfor","text = {@text, line};","else","text = text + \" [deserted]\";","endif","return text;"]},{"name":"internal_at","owner":36,"perms":173,"preposition":-1,"code":["\"'internal_at (<argument string>)' - Perform the function of @at. The argument string is whatever the user typed after @at. This is factored out so that other verbs can call it.\";","where = $string_utils:trim(args[1]);","if (where)","if (where[1] == \"#\")","result = toobj(where);","if ((!valid(result)) && (result != #-1))","player:tell(\"That object does not exist.\");","return;","endif","else","result = this:lookup_room(where);","if (!valid(result))","result = $string_utils:match_player(where);","if (!valid(result))","player:tell(\"That is neither a player nor a room name.\");","return;","endif","endif","endif","if (valid(result) && (!$object_utils:isa(result, $room)))","result = result.location;","endif","this:do_at(result);","else","this:do_at_all();","endif"]},{"name":"confunc","owner":2,"perms":173,"preposition":-1,"code":["\"'confunc ()' - Besides the inherited behavior, notify the player's feature objects that the player has connected.\";","if ((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this)))","return E_PERM;","endif","pass(@args);","set_task_perms(this);","for feature in (this.features)","try","feature:player_connected(player, @args);","except (E_VERBNF)","continue feature;","except id (ANY)","player:tell(\"Feature initialization failure for \", feature, \": \", id[2], \".\");","endtry","$command_utils:suspend_if_needed(0);","endfor"]},{"name":"disfunc","owner":2,"perms":173,"preposition":-1,"code":["\"'disfunc ()' - Besides the inherited behavior, notify the player's feature objects that the player has disconnected.\";","if ((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this)))","return E_PERM;","endif","pass(@args);","\"This is forked off to protect :disfunc from buggy :player_disconnected verbs.\";","set_task_perms(this);","fork (max(0, $login:current_lag()))","for feature in (this.features)","try","feature:player_disconnected(player, @args);","except (ANY)","continue feature;","endtry","endfor","endfork"]},{"name":"@addword @adddict","owner":2,"perms":89,"preposition":-2,"code":["set_task_perms(player);","if ((verb == \"@adddict\") && (!((player in $spell.trusted) || player.wizard)))","player:tell(\"You may not add to the master dictionary. The following words will instead by put in a list of words to be approved for later addition to the dictionary. Thanks for your contribution.\");","endif","if (!argstr)","player:notify(tostr(\"Usage: \", verb, \" one or more words\"));","player:notify(tostr(\"       \", verb, \" object:verb\"));","player:notify(tostr(\"       \", verb, \" object.prop\"));","elseif (data = $spell:get_input(argstr))","num_learned = 0;","for i in [1..length(data)]","line = $string_utils:words(data[i]);","for ii in [1..length(line)]","if (seconds_left() < 2)","suspend(0);","endif","if (verb == \"@adddict\")","result = $spell:add_word(line[ii]);","if (result == E_PERM)","if ($spell:find_exact(line[ii]) == $failed_match)","player:notify(tostr(\"Submitted for approval:  \", line[ii]));","$spell:submit(line[ii]);","else","player:notify(tostr(\"Already in dictionary:  \" + line[ii]));","endif","elseif (typeof(result) == ERR)","player:notify(tostr(result));","elseif (result)","player:notify(tostr(\"Word added:  \", line[ii]));","num_learned = num_learned + 1;","else","player:notify(tostr(\"Already in dictionary:  \" + line[ii]));","endif","elseif (!$spell:valid(line[ii]))","player.dict = listappend(player.dict, line[ii]);","player:notify(tostr(\"Word added:  \", line[ii]));","num_learned = num_learned + 1;","endif","endfor","endfor","player:notify(tostr(num_learned ? num_learned | \"No\", \" word\", (num_learned != 1) ? \"s \" | \" \", \"added to \", (verb == \"@adddict\") ? \"main \" | \"personal \", \"dictionary.\"));","endif"]},{"name":"@spell @cspell @complete","owner":2,"perms":89,"preposition":-2,"code":["\"@spell a word or phrase  -- Spell check a word or phrase.\";","\"@spell thing.prop  -- Spell check a property. The value must be a string or a list of strings.\";","\"@spell thing:verb  -- Spell check a verb. Only the quoted strings in the verb are checked.\";","\"@cspell word  -- Spell check a word, and if it is not in the dictionary, offset suggestions about what the right spelling might be. This actually works with thing.prop and thing:verb too, but it is too slow to be useful--it takes maybe 30 seconds per unknown word.\";","\"@complete prefix  -- List all the word in the dictionary which begin with the given prefix. For example, `@complete zoo' lists zoo, zoologist, zoology, and zoom.\";","\"\";","\"Mr. Spell was written by waffle (waffle@euclid.humboldt.edu), for use by\";","\"MOOers all over this big green earth. (....and other places....)\";","\"This monstrosity programmed Sept-Oct 1991, when I should have been studying.\";","set_task_perms(player);","if (!argstr)","if (verb == \"@complete\")","player:notify(tostr(\"Usage: \", verb, \" word-prefix\"));","else","player:notify(tostr(\"Usage: \", verb, \" object.property\"));","player:notify(tostr(\"       \", verb, \" object:verb\"));","player:notify(tostr(\"       \", verb, \" one or more words\"));","endif","elseif (verb == \"@complete\")","if ((foo = $string_utils:from_list($spell:sort($spell:find_all(argstr)), \" \")) == \"\")","player:notify(tostr(\"No words found that begin with `\", argstr, \"'\"));","else","player:notify(tostr(foo));","endif","else","\"@spell or @cspell.\";","corrected_words = {};","data = $spell:get_input(argstr);","if (data)","misspelling = 0;","for i in [1..length(data)]","line = $string_utils:words(data[i]);","for ii in [1..length(line)]","$command_utils:suspend_if_needed(0);","if (!$spell:valid(line[ii]))","if ((rindex(line[ii], \"s\") == length(line[ii])) && $spell:valid(line[ii][1..$ - 1]))","msg = \"Possible match: \" + line[ii];","msg = (msg + \" \") + ((length(data) != 1) ? (\"(line \" + tostr(i)) + \")  \" | \"  \");","elseif ((rindex(line[ii], \"'s\") == (length(line[ii]) - 1)) && $spell:valid(line[ii][1..$ - 2]))","msg = \"Possible match: \" + line[ii];","msg = (msg + \" \") + ((length(data) != 1) ? (\"(line \" + tostr(i)) + \")  \" | \"  \");","else","misspelling = misspelling + 1;","msg = (\"Unknown word: \" + line[ii]) + ((length(data) != 1) ? (\" (line \" + tostr(i)) + \")  \" | \"  \");","if ((verb == \"@cspell\") && (!(line[ii] in corrected_words)))","corrected_words = listappend(corrected_words, line[ii]);","guesses = $string_utils:from_list($spell:guess_words(line[ii]), \" \");","if (guesses == \"\")","msg = msg + \"-No guesses\";","else","msg = msg + \"-Possible correct spelling\";","msg = msg + (index(guesses, \" \") ? \"s: \" | \": \");","msg = msg + guesses;","endif","endif","endif","player:notify(tostr(msg));","endif","endfor","endfor","player:notify(tostr(\"Found \", misspelling ? misspelling | \"no\", \" misspelled word\", (misspelling == 1) ? \".\" | \"s.\"));","elseif (data != $failed_match)","player:notify(tostr(\"Nothing found to spellcheck!\"));","endif","endif"]},{"name":"@rmword","owner":2,"perms":89,"preposition":-2,"code":["set_task_perms(player);","if (argstr in player.dict)","player.dict = setremove(player.dict, argstr);","player:notify(tostr(\"`\", argstr, \"' removed from personal dictionary.\"));","else","player:notify(tostr(\"`\", argstr, \"' not found in personal dictionary.\"));","endif"]},{"name":"@rmdict","owner":2,"perms":89,"preposition":-2,"code":["set_task_perms(player);","result = $spell:remove_word(argstr);","if (result == E_PERM)","player:notify(\"You may not remove words from the main dictionary. Use `@rmword' to remove words from your personal dictionary.\");","elseif (typeof(result) == ERR)","player:notify(tostr(result));","elseif (result)","player:notify(tostr(\"`\", argstr, \"' removed.\"));","else","player:notify(tostr(\"`\", argstr, \"' not found in dictionary.\"));","endif"]},{"name":"find_property","owner":36,"perms":173,"preposition":-1,"code":["\"'find_property (<name>)' - Search for a property with the given name. The objects searched are those returned by this:find_properties_on(). The printing order relies on $list_utils:remove_duplicates to leave the *first* copy of each duplicated element in a list; for example, {1, 2, 1} -> {1, 2}, not to {2, 1}.\";","name = args[1];","results = \"\";","objects = $list_utils:remove_duplicates(this:find_properties_on());","for thing in (objects)","if (valid(thing) && (mom = $object_utils:has_property(thing, name)))","results = ((((results + \"   \") + thing.name) + \"(\") + tostr(thing)) + \")\";","mom = this:property_inherited_from(thing, name);","if (thing != mom)","if (valid(mom))","results = ((((results + \"--\") + mom.name) + \"(\") + tostr(mom)) + \")\";","else","results = results + \"--built-in\";","endif","endif","endif","endfor","if (results)","this:tell(\"The property .\", name, \" is on\", results);","else","this:tell(\"The property .\", name, \" is nowhere to be found.\");","endif"]},{"name":"find_verbs_on","owner":36,"perms":173,"preposition":-1,"code":["\"'find_verbs_on ()' -> list of objects - Return the objects that @find searches when looking for a verb. The objects are searched (and the results printed) in the order returned. Feature objects are included in the search. Duplicate entries are removed by the caller.\";","return {this, this.location, @valid(this.location) ? this.location:contents() | {}, @this:contents(), @this.features};"]},{"name":"find_properties_on","owner":36,"perms":173,"preposition":-1,"code":["\"'find_properties_on ()' -> list of objects - Return the objects that @find searches when looking for a property. The objects are searched (and the results printed) in the order returned. Feature objects are *not* included in the search. Duplicate entries are removed by the caller.\";","return {this, this.location, @valid(this.location) ? this.location:contents() | {}, @this:contents()};"]},{"name":"property_inherited_from","owner":36,"perms":173,"preposition":-1,"code":["\"'property_inherited_from (<object>, <property name>)' -> object - Return the ancestor of <object> on which <object>.<property> is originally defined. If <object>.<property> is not actually defined, return 0. The property is taken as originally defined on the earliest ancestor of <object> which has it. If the property is built-in, return $nothing.\";","{what, prop} = args;","if (!$object_utils:has_property(what, prop))","return 0;","elseif (prop in $code_utils.builtin_props)","return $nothing;","endif","ancestor = what;","while ($object_utils:has_property(parent(ancestor), prop))","ancestor = parent(ancestor);","endwhile","return ancestor;"]},{"name":"@ref*use","owner":36,"perms":89,"preposition":-2,"code":["\"'@refuse <action(s)> [ from <player> ] [ for <time> ]' - Refuse all of a list of one or more actions. If a player is given, refuse actions from the player; otherwise, refuse all actions. If a time is specified, refuse the actions for the given amount of time; otherwise, refuse them for a week. If the actions are already refused, then the only their times are adjusted.\";","if (!argstr)","player:tell(\"@refuse <action(s)> [ from <player> ] [ for <time> ]\");","return;","endif","stuff = this:parse_refuse_arguments(argstr);","if (stuff)","if (((typeof(who = stuff[1]) == OBJ) && (who != $nothing)) && (!is_player(who)))","player:tell(\"You must give the name of some player.\");","else","\"'stuff' is now in the form {<origin>, <actions>, <duration>}.\";","this:add_refusal(@stuff);","player:tell(\"Refusal of \", this:refusal_origin_to_name(stuff[1]), \" for \", $time_utils:english_time(stuff[3]), \" added.\");","endif","endif"]},{"name":"@unref*use @allow","owner":36,"perms":89,"preposition":-2,"code":["\"'@unrefuse <action(s)> [ from <player> ]' - Stop refusing all of a list of actions. If a player is given, stop refusing actions by the player; otherwise, stop refusing all actions of the given kinds. '@unrefuse everything' - Remove all refusals.\";","if (argstr == \"everything\")","if ($command_utils:yes_or_no(\"Do you really want to erase all your refusals?\"))","this:clear_refusals();","player:tell(\"OK, they are gone.\");","else","player:tell(\"OK, no harm done.\");","endif","return;","endif","stuff = this:parse_refuse_arguments(argstr);","if (!stuff)","return;","endif","\"'stuff' is now in the form {<origin>, <actions>, <duration>}.\";","origins = stuff[1];","actions = stuff[2];","if (typeof(origins) != LIST)","origins = {origins};","endif","n = 0;","for origin in (origins)","n = n + this:remove_refusal(origin, actions);","endfor","plural = ((n == 1) && (length(origins) == 1)) ? \"\" | \"s\";","if (n)","player:tell(\"Refusal\", plural, \" removed.\");","else","player:tell(\"You have no such refusal\", plural, \".\");","endif"]},{"name":"@refusals","owner":36,"perms":73,"preposition":-2,"code":["\"'@refusals' - List your refusals. '@refusals for <player>' - List the given player's refusals.\";","if (iobjstr)","who = $string_utils:match_player(iobjstr);","if ($command_utils:player_match_failed(who, iobjstr))","return;","endif","if (!$object_utils:has_verb(who, \"refusals_text\"))","player:tell(\"That player does not have the refusal facility.\");","return;","endif","else","who = player;","endif","who:remove_expired_refusals();","player:tell_lines(this:refusals_text(who));"]},{"name":"@refusal-r*eporting","owner":36,"perms":89,"preposition":-2,"code":["\"'@refusal-reporting' - See if refusal reporting is on. '@refusal-reporting on', '@refusal-reporting off' - Turn it on or off..\";","if (!argstr)","player:tell(\"Refusal reporting is \", this.report_refusal ? \"on\" | \"off\", \".\");","elseif (argstr in {\"on\", \"yes\", \"y\", \"1\"})","this.report_refusal = 1;","player:tell(\"Refusals will be reported to you as they happen.\");","elseif (argstr in {\"off\", \"no\", \"n\", \"0\"})","this.report_refusal = 0;","player:tell(\"Refusals will happen silently.\");","else","player:tell(\"@refusal-reporting on     - turn on refusal reporting\");","player:tell(\"@refusal-reporting off    - turn it off\");","player:tell(\"@refusal-reporting        - see if it's on or off\");","endif"]},{"name":"parse_refuse_arguments","owner":36,"perms":173,"preposition":-1,"code":["\"'parse_refuse_arguments (<string>)' -> {<who>, <actions>, <duration>} - Parse the arguments of a @refuse or @unrefuse command. <who> is the player requested, or $nothing if none was. <actions> is a list of the actions asked for. <duration> is how long the refusal should last, or 0 if no expiration is given. <errors> is a list of actions (or other words) which are wrong. If there are any errors, this prints an error message and returns 0.\";","words = $string_utils:explode(args[1]);","possible_actions = this:refusable_actions();","who = $nothing;","actions = {};","until = this.default_refusal_time;","errors = {};","skip_to = 0;","for i in [1..length(words)]","word = words[i];","if (i <= skip_to)","elseif (which = $string_utils:find_prefix(word, possible_actions))","actions = setadd(actions, possible_actions[which]);","elseif ((word[$] == \"s\") && (which = $string_utils:find_prefix(word[1..$ - 1], possible_actions)))","\"The word seems to be the plural of an action.\";","actions = setadd(actions, possible_actions[which]);","elseif (results = this:translate_refusal_synonym(word))","actions = $set_utils:union(actions, results);","elseif ((word == \"from\") && (i < length(words)))","\"Modified to allow refusals from all guests at once. 5-27-94, Gelfin\";","if (words[i + 1] == \"guests\")","who = \"all guests\";","elseif (!(typeof(who = $code_utils:toobj(words[i + 1])) == OBJ))","who = $string_utils:match_player(words[i + 1]);","if ($command_utils:player_match_failed(who, words[i + 1]))","return 0;","endif","endif","skip_to = i + 1;","elseif ((word == \"for\") && (i < length(words)))","n_words = this:parse_time_length(words[i + 1..$]);","until = this:parse_time(words[i + 1..i + n_words]);","if (!until)","return 0;","endif","skip_to = i + n_words;","else","errors = {@errors, word};","endif","endfor","if (errors)","player:tell((length(errors) > 1) ? \"These parts of the command were not understood: \" | \"This part of the command was not understood: \", $string_utils:english_list(errors, 0, \" \", \" \", \" \"));","return 0;","endif","return {this:player_to_refusal_origin(who), actions, until};"]},{"name":"time_word_to_seconds","owner":36,"perms":173,"preposition":-1,"code":["\"'time_word_to_seconds (<string>)' - The <string> is expected to be a time word, 'second', 'minute', 'hour', 'day', 'week', or 'month'. Return the number of seconds in that amount of time (a month is taken to be 30 days). If <string> is not a time word, return 0. This is used both as a test of whether a word is a time word and as a converter.\";","return $time_utils:parse_english_time_interval(\"1\", args[1]);"]},{"name":"parse_time_length","owner":36,"perms":173,"preposition":-1,"code":["\"'parse_time_length (<words>)' -> n - Given a list of words which is expected to begin with a time expression, return how many of them belong to the time expression. A time expression can be a positive integer, a time word, or a positive integer followed by a time word. A time word is anything that this:time_word_to_seconds this is one. The return value is 0, 1, or 2.\";","words = {@args[1], \"dummy\"};","n = 0;","if (toint(words[1]) || this:time_word_to_seconds(words[1]))","n = 1;","endif","if (this:time_word_to_seconds(words[n + 1]))","n = n + 1;","endif","return n;"]},{"name":"parse_time","owner":36,"perms":173,"preposition":-1,"code":["\"'parse_time (<words>)' -> <seconds> - Given a list of zero or more words, either empty or a valid time expression, return the number of seconds that the time expression refers to. This is a duration, not an absolute time.\";","words = args[1];","\"If the list is empty, return the default refusal time.\";","if (!words)","return this.default_refusal_time;","endif","\"If the list has one word, either <units> or <n>.\";","\"If it is a unit, like 'hour', return the time for 1 <unit>.\";","\"If it is a number, return the time for <n> days.\";","if (length(words) == 1)","return this:time_word_to_seconds(words[1]) || (toint(words[1]) * this:time_word_to_seconds(\"days\"));","endif","\"The list must contain two words, <n> <units>.\";","return toint(words[1]) * this:time_word_to_seconds(words[2]);"]},{"name":"clear_refusals","owner":36,"perms":173,"preposition":-1,"code":["\"'clear_refusals ()' - Erase all of this player's refusals.\";","if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))","return E_PERM;","endif","this.refused_origins = {};","this.refused_actions = {};","this.refused_until = {};","this.refused_extra = {};"]},{"name":"set_default_refusal_time","owner":36,"perms":173,"preposition":-1,"code":["\"'set_default_refusal_time (<seconds>)' - Set the length of time that a refusal lasts if its duration isn't specified.\";","if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))","return E_PERM;","endif","this.default_refusal_time = toint(args[1]);"]},{"name":"refusable_actions","owner":36,"perms":173,"preposition":-1,"code":["\"'refusable_actions ()' -> {'page', 'whisper', ...} - Return a list of the actions that can be refused. This is a verb, rather than a property, so that it can be inherited properly. If you override this verb to add new refusable actions, write something like 'return {@pass (), 'action1', 'action2', ...}'. That way people can add new refusable actions at any level of the player class hierarchy, without clobbering any that were added higher up.\";","return {\"page\", \"whisper\", \"move\", \"join\", \"accept\", \"mail\"};"]},{"name":"translate_refusal_synonym","owner":36,"perms":173,"preposition":-1,"code":["\"'translate_refusal_synonym (<word>)' -> list - If the <word> is a synonym for some set of refusals, return the list of those refusals. Otherwise return the empty list, {}. Programmers can override this verb to provide more synonyms.\";","word = args[1];","if (word == \"all\")","return this:refusable_actions();","endif","return {};"]},{"name":"default_refusals_text_filter","owner":36,"perms":173,"preposition":-1,"code":["\"'default_refusals_text_filter (<origin>, <actions>)' - Return any actions by this <origin> which should be included in the text returned by :refusals_text. This is the default filter, which includes all actions.\";","return args[2];"]},{"name":"refusals_text","owner":36,"perms":173,"preposition":-1,"code":["\"'refusals_text (<player>, [<filter verb name>])' - Return text describing the given player's refusals. The filter verb name is optional; if it is given, this verb takes an origin and a list of actions and returns any actions which should be included in the refusals text. This verb works only if <player> is a player who has the refusals facility; it does not check for this itself.\";","{who, ?filter_verb = \"default_refusals_text_filter\"} = args;","text = {};","for i in [1..length(who.refused_origins)]","origin = who.refused_origins[i];","actions = this:(filter_verb)(origin, who.refused_actions[i]);","if (actions)","line = \"\";","for action in (actions)","line = (line + \" \") + action;","endfor","line = (this:refusal_origin_to_name(origin) + \": \") + line;","line = (ctime(who.refused_until[i]) + \" \") + line;","text = {@text, line};","endif","endfor","if (!text)","text = {\"No refusals.\"};","endif","return text;"]},{"name":"player_to_refusal_origin","owner":2,"perms":173,"preposition":-1,"code":["\"'player_to_refusal_origin (<player>)' -> <origin> - Convert a player to a unique identifier called the player's 'refusal origin'. For most players, it's just their object number. For guests, it is a hash of the site they are connecting from. Converting an origin to an origin is a safe no-op--the code relies on this.\";","set_task_perms(caller_perms());","{who} = args;","if (((typeof(who) == OBJ) && valid(who)) && (parent(who) == `$local.guest ! ANY => $guest'))","return who:connection_name_hash(\"xx\");","else","return who;","endif"]},{"name":"refusal_origin_to_name","owner":36,"perms":173,"preposition":-1,"code":["\"'refusal_origin_to_name (<origin>)' -> string - Convert a refusal origin to a name.\";","origin = args[1];","if (origin in {\"all guests\", \"everybody\"})","return origin;","elseif (typeof(origin) != OBJ)","return \"a certain guest\";","elseif (origin == #-1)","return \"Everybody\";","else","return $string_utils:name_and_number(origin);","endif"]},{"name":"check_refusal_actions","owner":36,"perms":173,"preposition":-1,"code":["\"'check_refusal_actions (<actions>)' - Check a list of refusal actions, and return whether they are all legal.\";","actions = args[1];","legal_actions = this:refusable_actions();","for action in (actions)","if (!(action in legal_actions))","return 0;","endif","endfor","return 1;"]},{"name":"add_refusal","owner":36,"perms":173,"preposition":-1,"code":["\"'add_refusal (<origin>, <actions> [, <duration> [, <extra>]])' - Add refusal(s) to this player's list. <Actions> is a list of the actions to be refused. The list should contain only actions, no synonyms. <Origin> is the actor whose actions are to be refused. <Until> is the time that the actions are being refused until, in the form returned by time(). It is optional; if it's not given, it defaults to .default_refusal_time. <Extra> is any extra information; it can be used for comments, or to make finer distinctions about the actions being refused, or whatever. If it is not given, it defaults to 0. The extra information is per-action; that is, it is stored separately for each action that it applies to.\";","if (caller != this)","return E_PERM;","endif","{orig, actions, ?duration = this.default_refusal_time, ?extra = 0} = args;","origins = this:player_to_refusal_origin(orig);","if (typeof(origins) != LIST)","origins = {origins};","endif","if (typeof(actions) != LIST)","actions = {actions};","endif","if (!this:check_refusal_actions(actions))","return E_INVARG;","endif","until = time() + duration;","for origin in (origins)","if (i = origin in this.refused_origins)","this.refused_until[i] = until;","for action in (actions)","if (j = action in this.refused_actions[i])","this.refused_extra[i][j] = extra;","else","this.refused_actions[i] = {@this.refused_actions[i], action};","this.refused_extra[i] = {@this.refused_extra[i], extra};","endif","endfor","else","this.refused_origins = {@this.refused_origins, origin};","this.refused_actions = {@this.refused_actions, actions};","this.refused_until = {@this.refused_until, until};","this.refused_extra = {@this.refused_extra, $list_utils:make(length(actions), extra)};","endif","endfor"]},{"name":"remove_refusal","owner":36,"perms":173,"preposition":-1,"code":["\"'remove_refusal (<origin>, <actions>)' - Remove any refused <actions> by <origin>. The <actions> list should contain only actions, no synonyms. Return the number of such refusals found (0 if none).\";","if (caller != this)","return E_PERM;","endif","{origin, actions} = args;","if (typeof(actions) != LIST)","actions = {actions};","endif","count = 0;","i = origin in this.refused_origins;","if (i)","for action in (actions)","if (j = action in this.refused_actions[i])","this.refused_actions[i] = listdelete(this.refused_actions[i], j);","this.refused_extra[i] = listdelete(this.refused_extra[i], j);","count = count + 1;","endif","endfor","if (!this.refused_actions[i])","this.refused_origins = listdelete(this.refused_origins, i);","this.refused_actions = listdelete(this.refused_actions, i);","this.refused_until = listdelete(this.refused_until, i);","this.refused_extra = listdelete(this.refused_extra, i);","endif","endif","return count;"]},{"name":"remove_expired_refusals","owner":36,"perms":173,"preposition":-1,"code":["\"'remove_expired_refusals ()' - Remove refusal entries which are past their time limits.\";","origins = {};","\"Before removing any refusals, figure out which ones to remove. Removing one changes the indices and invalidates the loop invariant.\";","for i in [1..length(this.refused_origins)]","if (time() >= this.refused_until[i])","origins = {@origins, this.refused_origins[i]};","endif","endfor","for origin in (origins)","this:remove_refusal(origin, this:refusable_actions());","endfor"]},{"name":"refuses_action","owner":36,"perms":173,"preposition":-1,"code":["\"'refuses_action (<origin>, <action>, ...)' - Return whether this object refuses the given <action> by <origin>. <Origin> is typically a player. Extra arguments after <origin>, if any, are used to further describe the action.\";","\"Modified by Diopter (#98842) at LambdaMOO\";","{origin, action, @extra_args} = args;","extra_args = {origin, @extra_args};","rorigin = this:player_to_refusal_origin(origin);","if (((which = rorigin in this.refused_origins) && (action in this.refused_actions[which])) && this:(\"refuses_action_\" + action)(which, @extra_args))","return 1;","elseif (((((typeof(rorigin) == OBJ) && valid(rorigin)) && (which = rorigin.owner in this.refused_origins)) && (action in this.refused_actions[which])) && this:(\"refuses_action_\" + action)(which, @extra_args))","return 1;","elseif ((((which = $nothing in this.refused_origins) && (rorigin != this)) && (action in this.refused_actions[which])) && this:(\"refuses_action_\" + action)(which, @extra_args))","return 1;","elseif ((((which = \"all guests\" in this.refused_origins) && $object_utils:isa(origin, $guest)) && (action in this.refused_actions[which])) && this:(\"refuses_action_\" + action)(which, @extra_args))","return 1;","endif","return 0;"]},{"name":"refuses_action_*","owner":36,"perms":173,"preposition":-1,"code":["\"'refuses_action_* (<which>, <origin>, ...)' - The action (such as 'whisper' for the verb :refuses_action_whisper) is being considered for refusal. Return whether the action should really be refused. <Which> is an index into this.refused_origins. By default, always refuse non-outdated actions that get this far.\";","{which, @junk} = args;","if (time() >= this.refused_until[which])","fork (0)","\"This <origin> is no longer refused. Remove any outdated refusals.\";","this:remove_expired_refusals();","endfork","return 0;","else","return 1;","endif"]},{"name":"report_refusal","owner":36,"perms":173,"preposition":-1,"code":["\"'report_refusal (<player>, <message>, ...)' - If refusal reporting is turned on, print the given <message> to report the refusal of some action by <player>. The message may take more than one argument. You can override this verb to do more selective reporting.\";","if (this.report_refusal)","this:tell(@listdelete(args, 1));","endif"]},{"name":"wh*isper","owner":36,"perms":157,"preposition":1,"code":["\"'whisper <message> to <this player>' - Whisper a message to this player which nobody else can see.\";","if (this:refuses_action(player, \"whisper\"))","player:tell(this:whisper_refused_msg());","this:report_refusal(player, \"You just refused a whisper from \", player.name, \".\");","else","pass(@args);","endif"]},{"name":"receive_page","owner":36,"perms":173,"preposition":-1,"code":["\"'receive_page (<message>)' - Receive a page. If the page is accepted, pass(@args) shows it to the player.\";","if (this:refuses_action(player, \"page\"))","this.page_refused = task_id();","return 0;","endif","this.page_refused = 0;","return pass(@args);"]},{"name":"page_echo_msg","owner":36,"perms":173,"preposition":-1,"code":["\"'page_echo_msg ()' - Return a message to inform the pager what happened to their page.\";","if (task_id() == this.page_refused)","this:report_refusal(player, \"You just refused a page from \", player.name, \".\");","return this:page_refused_msg();","else","return pass(@args);","endif"]},{"name":"moveto acceptable","owner":36,"perms":173,"preposition":-1,"code":["\"'moveto (<destination>)', 'accept (<object>)' - Check whether this :moveto or :accept is allowed or refused. If it is allowed, do it. This code is slightly modified from an original verb by Grump.  Upgraded by Bits to account for forthcoming 1.8.0 behavior of callers().\";","by = callers();","\"Ignore all the verbs on this.\";","while (((y = by[1])[1] == this) && (y[2] == verb))","by = listdelete(by, 1);","endwhile","act = (verb == \"moveto\") ? \"move\" | \"accept\";","if ((player != this) && this:refuses_action(player, act, args[1]))","\"check player\";","return 0;","endif","last = #-1;","for k in (by)","if ((((perms = k[3]) == #-1) && (k[2] != \"\")) && (k[1] == #-1))","elseif ((!perms.wizard) && (perms != this))","if (perms != last)","\"check for possible malicious programmer\";","if (this:refuses_action(perms, act, args[1]))","return 0;","endif","last = perms;","endif","endif","endfor","\"Coded added 11/8/98 by TheCat, to refuse spurned objects.\";","if ((act == \"accept\") && (typeof(this.spurned_objects) == LIST))","for item in (this.spurned_objects)","if ($object_utils:isa(args[1], item))","return 0;","endif","endfor","endif","\"(end of code added by TheCat)\";","return pass(@args);"]},{"name":"receive_message","owner":36,"perms":173,"preposition":-1,"code":["\"'receive_message (<message>, <sender>)' - Receive the given mail message from the given sender. This version handles refusal of the message.\";","if ((!$perm_utils:controls(caller_perms(), this)) && (caller != this))","return E_PERM;","elseif (this:refuses_action(args[2], \"mail\"))","return this:mail_refused_msg();","else","return pass(@args);","endif"]},{"name":"whisper_refused_msg page_refused_msg mail_refused_msg","owner":36,"perms":173,"preposition":-1,"code":["\"'whisper_refused_msg()', 'page_refused_msg()', etc. - Return a message string.\";","return $string_utils:pronoun_sub(this.(verb), this);"]},{"name":"last_huh","owner":2,"perms":173,"preposition":-1,"code":["set_task_perms(caller_perms());","if (pass(@args))","return 1;","endif","{verb, args} = args;","if (valid(dobj = $string_utils:literal_object(dobjstr)) && (r = $match_utils:match_verb(verb, dobj, args)))","return r;","elseif (valid(iobj = $string_utils:literal_object(iobjstr)) && (r = $match_utils:match_verb(verb, iobj, args)))","return r;","else","return 0;","endif"]},{"name":"ping_features","owner":2,"perms":173,"preposition":-1,"code":["\":ping_features()\";","\" -- cleans up the .features list to remove !valid objects\";","\" ==> cleaned-up .features list\";","features = this.features;","for x in (features)","if (!$recycler:valid(x))","features = setremove(features, x);","endif","endfor","return this.features = features;"]},{"name":"set_owned_objects","owner":2,"perms":173,"preposition":-1,"code":["\":set_owned_objects( LIST owned-objects list )\";","\"  -- set your .owned_objects, ordered as you please\";","\"  -- no, it will NOT let you set to to anything you want\";","if ((caller == this) || $perm_utils:controls(caller_perms(), this))","new = args[1];","old = this.owned_objects;","\"make sure they're the same\";","if (length(new) != length(old))","return E_INVARG;","endif","for i in (new)","old = setremove(old, i);","endfor","if (old)","\"something's funky\";","return E_INVARG;","endif","return this.owned_objects = new;","else","return E_PERM;","endif"]},{"name":"init_for_core","owner":2,"perms":173,"preposition":-1,"code":["if (caller_perms().wizard)","pass();","if ($code_utils:verb_location() == this)","this.rooms = {};","delete_verb(this, \"@web\");","delete_verb(this, \"web_info\");","delete_verb(this, \"set_web_info\");","delete_property(this, \"web_info\");","else","clear_property(this, \"rooms\");","endif","this.features = {$pasting_feature, $stage_talk};","endif"]},{"name":"find_help","owner":36,"perms":173,"preposition":-1,"code":["\"'find_help (<name>[, databases])'\";","\"Search for a help topic with the given name. [<databases>] defaults to the ones returned by $code_utils:help_db_list().\";","{name, ?databases = $code_utils:help_db_list()} = args;","if (!name)","this:tell(\"What topic do you want to search for?\");","elseif (result = $code_utils:help_db_search(name, databases))","{object, realname} = result;","if (object == $ambiguous_match)","this:tell(\"The help topic \\\"\", name, \"\\\" could refer to any of the following:  \", $string_utils:english_list(realname));","elseif (((object == $help) && (!$object_utils:has_property(object, realname))) && valid(o = $string_utils:match_object(name, player.location)))","if ($object_utils:has_callable_verb(o, \"help_msg\"))","this:tell(\"That help topic was returned by \", $string_utils:nn(o), \":help_msg().\");","elseif ($object_utils:has_property(o, \"help_msg\"))","this:tell(\"That help topic is located in \", $string_utils:nn(o), \".help_msg.\");","else","this:tell(\"That help topic was matched by $help but there doesn't seem to be any help available for it.\");","endif","elseif (object == $verb_help)","if (((what = $code_utils:parse_verbref(realname)) && valid(what[1] = $string_utils:match_object(what[1], player.location))) && $object_utils:has_verb(@what))","this:tell(\"That help topic is located at the beginning of the verb \", $string_utils:nn(what[1]), \":\", what[2], \".\");","else","this:tell(\"That help topic was matched by $verb_help but there doesn't seem to be any help available for it.\");","endif","else","where = {};","for x in (databases)","if ({realname} == x:find_topics(realname))","where = setadd(where, x);","endif","endfor","asname = (name == realname) ? \"\" | ((\" as \\\"\" + realname) + \"\\\"\");","if (where)","this:tell(\"That help topic is located on \", $string_utils:nn(where), asname, \".\");","else","\"...this shouldn't happen unless $code_utils:help_db_search finds a match we weren't expecting\";","this:tell(\"That help topic appears to be located on \", $string_utils:nn(object), asname, \", although this command could not find it.\");","endif","endif","else","this:tell(\"The help topic \\\"\", name, \"\\\" could not be found.\");","endif"]},{"name":"@spurn","owner":36,"perms":25,"preposition":-1,"code":["\"Prevent an object or any of its descendents from going into your inventory, regardless of whose player perms sent it there.\";","\"Syntax:  @spurn <object>\";","\"         @spurn !<object>\";","\"The second form removes an object from your list of spurned objects.\";","\"Verb created by TheCat, 11/8/98\";","if (caller != this)","return E_PERM;","endif","if (!argstr)","this:tell(\"Spurn what?\");","elseif (argstr[1] == \"!\")","\"Stop spurning something.\";","item = this:my_match_object(argstr[2..$]);","if (item in this.spurned_objects)","this.spurned_objects = $list_utils:setremove_all(this.spurned_objects, item);","this:tell((\"You are no longer spurning \" + $string_utils:nn(item)) + \" or any kids of it.\");","else","this:tell((\"You are not spurning \" + $string_utils:nn(item)) + \".\");","endif","else","\"Spurn something.\";","item = this:my_match_object(argstr);","if (!$command_utils:object_match_failed(item, argstr))","if (item in this.spurned_objects)","this:tell((\"You are already spurning \" + $string_utils:nn(item)) + \" plus any and all kids of it.\");","else","this.spurned_objects = setadd(this.spurned_objects, item);","this:tell((\"You are now spurning \" + $string_utils:nn(item)) + \" plus any and all kids of it.\");","endif","endif","endif"]},{"name":"@spurned","owner":36,"perms":9,"preposition":-1,"code":["\"Displays a list of spurned objects.\";","\"Verb created by TheCat, 11/8/98\";","if (this.spurned_objects)","this:tell(\"You are spurning the following objects, including any and all descendents:  \" + $string_utils:nn(this.spurned_objects));","else","this:tell(\"You are not spurning any objects.\");","endif"]},{"name":"set_spurned_objects","owner":36,"perms":173,"preposition":-1,"code":["\"Permits programmatic setting of .spurned_objects, which is -c.\";","{spurned_objects} = args;","if ($perm_utils:controls(caller_perms(), this))","\"Note, the final result must be a list of objects, otherwise there's no point.\";","if (typeof(spurned_objects) != LIST)","spurned_objects = {spurned_objects};","endif","this.spurned_objects = spurned_objects;","endif"]},{"name":"stage `*","owner":36,"perms":93,"preposition":-2,"code":["\"Say something out loud, directed at someone or something.\";","\"Usage:\";","\"  `target message\";","\"Example:\";","\"  Munchkin is talking to Kenneth, who's in the same room with him.  He types:\";","\"      `kenneth What is the frequency?\";","\"  The room sees:\";","\"       Munchkin [to Kenneth]: What is the frequency?\";","name = verb[2..$];","who = player.location:match_object(name);","if ($command_utils:object_match_failed(who, name))","return;","endif","player.location:announce_all(player.name, \" [to \", who.name, \"]: \", argstr);"]},{"name":"stage [*","owner":36,"perms":93,"preposition":-2,"code":["\"Say something out loud, in some specific way.\";","\"Usage:\";","\"  [how]: message\";","\"Example:\";","\"  Munchkin decideds to sing some lyrics.  He types:\";","\"      [sings]: I am the eggman\";","\"  The room sees:\";","\"      Munchkin [sings]: I am the eggman\";","player.location:announce_all((((player.name + \" \") + verb) + \" \") + argstr);"]},{"name":"stage ]*","owner":36,"perms":93,"preposition":-2,"code":["\"Perform some physical, non-verbal, action.\";","\"Usage:\";","\"  ]third person action\";","\"Example:\";","\"  Munchkin has annoyed some would-be tough guy.  He types:\";","\"      ]hides behind the reactor.\";","\"  The room sees:\";","\"      [Munchkin hides behind the reactor.]\";","player.location:announce_all(\"[\", (((player.name + \" \") + verb[2..$]) + (argstr ? \" \" + argstr | \"\")) + \"]\");"]},{"name":"-*","owner":36,"perms":93,"preposition":-2,"code":["\"This is the same as `*\";","name = verb[2..$];","who = player.location:match_object(name);","argstr = $code_utils:argstr(verb, args, argstr);","if (!valid(who))","player.location:announce_all(player.name, \" [\", name, \"]: \", argstr);","else","player.location:announce_all(player.name, \" [to \", who.name, \"]: \", argstr);","endif"]},{"name":"stage <*","owner":36,"perms":93,"preposition":-2,"code":["\"Point to yourself.\";","\"Usage:\";","\"  <message\";","\"Example:\";","\"  Muchkin decides he's being strange. He types:\";","\"    <being strange.\";","\"  The room sees:\";","\"    Munchkin <- being strange.\";","player.location:announce_all((((player.name + \" <- \") + verb[2..$]) + \" \") + argstr);"]},{"name":"@paste","owner":36,"perms":85,"preposition":-2,"code":["\"Usage: @paste <prefix> <suffix>\";","\"Announce a series of entered lines to the room the player is in.\";","\"Before the lines are quoted, player.paste_header is run through\";","\"$string_utils:pronoun_sub(), and if the result contains the player's\";","\"name, it is used as a header.  Otherwise player.name centered in a\";","\"line of dashes is used.\";","\"A footer comes afterwards, likewise derived from player.paste_footer.\";","\"<prefix> and <suffix> are placed before and after each line.\";","\"\";","\"This verb is, as one might guess, designed for pasting text to MOO using\";","\"GnuEmacs or a windowing system.  You should remember that after you\";","\"have pasted the lines in, you must type . on a line by itself, or you'll\";","\"sit around waiting for $command_utils:read_lines() to finish _forever_.\";","{?prefix = \"\", ?suffix = \"\"} = args;","lines = $command_utils:read_lines();","header = $string_utils:pronoun_sub_secure($code_utils:verb_or_property(player, \"paste_header\"), \"\") || $string_utils:center(player.name, 75, \"-\");","to_tell = {header};","for line in (lines)","to_tell = listappend(to_tell, (prefix + line) + suffix);","endfor","to_tell = listappend(to_tell, $string_utils:pronoun_sub_secure($code_utils:verb_or_property(player, \"paste_footer\"), \"\") || $string_utils:center(\"finished\", 75, \"-\"));","for thing in (player.location.contents)","$command_utils:suspend_if_needed(0);","thing:tell_lines(to_tell);","endfor","player:tell(\"Done @pasting.\");"]},{"name":"|*","owner":36,"perms":93,"preposition":-2,"code":["\"Echo a line prefaced by a vertical bar.\";","\"Usage:\";","\"  |message\";","\"Example:\";","\"  Hacker wants to echo to the room what he just saw. He enters (either by hand, or with Emacs or a windowing system):\";","\"      |Haakon has disconnected.\";","\"  The room sees:\";","\"      Hacker | Haakon has disconnected.\";","player.location:announce_all((((player.name + \" | \") + verb[2..$]) + \" \") + argstr);"]},{"name":"@pasteto @paste-to","owner":36,"perms":29,"preposition":-1,"code":["\"Syntax: @paste-to <player>\";","\"\";","\"Which will then prompt you for the lines to privately send to <player>. The lines will be surrounded by a default footer and header.\";","target = $string_utils:match_player(dobjstr);","$command_utils:player_match_result(target, dobjstr);","if (!valid(target))","return;","endif","prefix = \"\";","suffix = \"\";","lines = $command_utils:read_lines();","to_tell = {$string_utils:center(\"Private message from \" + player.name, 75, \"-\")};","for line in (lines)","to_tell = listappend(to_tell, (prefix + line) + suffix);","endfor","to_tell = listappend(to_tell, $string_utils:center(\"end message\", 75, \"-\"));","target:tell_lines(to_tell);","player:tell(\"Done @pasting.\");"]},{"name":"vector_add vector_sub vector_mul vector_div","owner":36,"perms":173,"preposition":-1,"code":["\":vector_add(V1 [,V2 ...]) => VN such that VN[n] = V1[n] + V2[n]...\";","\":vector_sub(V1 [,V2 ...]) => VN such that VN[n] = V1[n] - V2[n]...\";","\":vector_mul(V1 [,V2 ...]) => VN such that VN[n] = V1[n] * V2[n]...\";","\":vector_div(V1 [,V2 ...]) => VN such that VN[n] = V1[n] / V2[n]...\";","\"Vectors do not need to be the same length, but they should be. VN's length will be the length of the longest vector in the arguments. :vector_add and :vector_sub will pad out the smaller vectors with 0's or 0.0's. :vector_mul and :vector_div will pad out the smaller vectors with 1's or 1.0's. Vectors do not need to contain homogeneous data, but the nth term of each vector must be of the same type.\";","\"I can see a reason for wanting to do vector addition or subtraction, but multiplication and divareion is usually handled in other ways. I've included them here for novelty, and becuase it was easy enough to do.\";","\"\";","\"Vector addition is used when two or more similar vector quantities are at work and need to be resolved into a single vector. For instance, a ship travelling in a current will be acted upon by (at least) two forces: a force propelling it forward (its engine), and a force pushing it off course (the current). The sum of these two forces gives the resultant net force acting upon the ship and, since Force = Mass * Acceleration, the direction the ship is accelerating.\";","\"\";","\"Vector subtraction can be used to reverse the process of vector addition. In the ship problem above, let's say the actual resultant force is known, but it does not match the result of adding the propelling force and the drifting force. Friction is probably acting against the motion of the ship. Subtracting the computed resultant force from the known net force will yield the frictional force acting against the progress of the ship.\";","\"\";","\"Vector multiplication and division do not have RL examples, but vector multiplication of this type makes computing the dot product of two vectors simple.\";","\"\";","if (length(args) == 1)","return args;","elseif (!args)","return raise(E_INVARG);","endif","type = verb[$ - 2..$];","lresult = max = length(args[1]);","results = args[1];","for n in [2..length(args)]","if (type == \"add\")","for m in [1..min(lcurr = length(args[n]), lresult)]","results[m] = results[m] + args[n][m];","endfor","if (lcurr > lresult)","results[lresult + 1..lcurr] = args[n][lresult + 1..lcurr];","endif","elseif (type == \"sub\")","for m in [1..min(lcurr = length(args[n]), lresult)]","results[m] = results[m] - args[n][m];","endfor","if (lcurr > lresult)","for m in [lresult + 1..lcurr]","results = {@results, -args[n][m]};","endfor","endif","elseif (type == \"mul\")","for m in [1..min(lcurr = length(args[n]), lresult)]","results[m] = results[m] * args[n][m];","endfor","if (lcurr > lresult)","results[lresult + 1..lcurr] = args[n][lresult + 1..lcurr];","endif","else","for m in [1..min(lcurr = length(args[n]), lresult)]","results[m] = results[m] / args[n][m];","endfor","if (lcurr > lresult)","for m in [lresult + 1..lcurr]","results = {@results, (typeof(foo = args[n][m]) == INT) ? 1 / foo | (1.0 / foo)};","endfor","endif","endif","endfor","return results;"]},{"name":"matrix_add matrix_sub","owner":36,"perms":173,"preposition":-1,"code":["\":matrix_add(M1 [, M2 ...]) => MN such that MN[m][n] = M1[m][n] + M2[m][n]...\";","\":matrix_sub(M1 [, M2 ...]) => MN such that MN[m][n] = M1[m][n] - M2[m][n]...\";","\"Matrices should all be of the same size.\";","\"\";","\"Matrix addition and subtraction is simply the addition or subtraction of the vectors contained in the matrices. See 'help $matrix_utils:vector:add' for more help.\";","type = verb[$ - 2..$];","results = args[1];","if (typeof(results[1][1]) == LIST)","for n in [1..length(results)]","results[n] = this:(verb)(results[n], @$list_utils:slice(args[2..$], n));","endfor","else","for n in [1..length(results)]","results[n] = this:(\"vector_\" + type)(results[n], @$list_utils:slice(args[2..$], n));","endfor","endif","return results;"]},{"name":"transpose","owner":36,"perms":173,"preposition":-1,"code":["\":transpose(Mmn) => Mnm\";","\"Transpose an m by n matrix into an n by m matrix by making the rows in the original the columns in the output.\";","{mat} = args;","if (!this:is_matrix(mat))","return raise(\"E_INVMAT\", \"Invalid Matrix Format\");","endif","j = this:dimensions(mat)[2];","result = {};","for n in [1..j]","result = {@result, this:column(mat, n)};","endfor","return result;"]},{"name":"determinant","owner":36,"perms":173,"preposition":-1,"code":["\":determinant(M) => NUM the determinant of the matrix.\";","\"\";","\"There are several properties of a matrix's determinant. Adding or subtracting a row or column from another row or colum of a matrix does not hange the value of its determinant. Multiplying a row or column of a matrix by a single scalar value has the effect of multiplying the matrix's determinant by the same scalar.\";","\"\";","\"However, the most dramatic use of determinants is in solving linear equations. For example, the solution to this system of equations:\";","\"\";","\"Ax1 + Bx2 + Cx3 = D\";","\"Ex1 + Fx2 + Gx3 = H\";","\"Ix1 + Jx2 + Kx3 = L\";","\"\";","\"is\";","\"\";","\"     1 |D B C|         1 |A D C|        1 |A B D|\";","\"x1 = - |H F G|    x2 = - |E H G|   x3 = - |E F H|\";","\"     Z |L J K|         Z |I L K|        Z |I J L|\";","\"\";","\"          |A B C|\";","\"where Z = |E F G|\";","\"          |I J K|\";","\"\";","\"or, in other words, x1, x2, and x3 are some determinant divided by Z, another determinant.\";","\"\";","\"Determinants are also used in computing the cross product of two vectors. See 'help $matrix_utils:cross_prod' for more info.\";","\"\";","{mat} = args;","if (!this:is_square(mat))","return raise(\"E_INVMAT\", \"Invalid Matrix Format\");","elseif (this:dimensions(mat)[1] == 2)","return (mat[1][1] * mat[2][2]) - (mat[1][2] * mat[2][1]);","else","result = 0;","coeff = 1;","for n in [1..length(mat[1])]","result = result + ((coeff * mat[1][n]) * this:determinant(this:submatrix(1, n, mat)));","coeff = -coeff;","endfor","return result;","endif"]},{"name":"inverse","owner":36,"perms":173,"preposition":-1,"code":["\":inverse(M) => MN such that M * MN = I\";","\"\";","\"The inverse of a matrix is very similar to the reciprocal of a scalar number. If two numbers, A and B, equal 1 (the scalar identity number) when multiplied together (AB=1), then B is said the be the reciprocal of A, and A is the reciprocal of B. If A and B are matrices, and the result of multiplying them togeter is the Identity Matrix, then B is the inverse of A, and A is the inverse of B.\";","\"\";","\"Computing the inverse involves the solutions of several linear equations. Since linear equations can be easily solved with determinants, this is rather simple. See 'help $matrix_utils:determinant' for more on how determinants solve linear equations.\";","\"\";","{mat} = args;","{i, j} = this:dimensions(mat);","det = this:determinant(mat);","result = {};","for k in [1..i]","sub = {};","for l in [1..j]","sub = {@sub, (tofloat($math_utils:pow(-1, i + j)) * this:determinant(this:submatrix(j, i, mat))) / det};","endfor","result = {@result, sub};","endfor","return result;"]},{"name":"identity","owner":36,"perms":173,"preposition":-1,"code":["\":identity(INT <size>) => Identity matrix (I) of dimensions <size> by <size>.\";","\"All elements of I are 0, except for the diagonal elements which are 1.\";","\"\";","\"The Identity Matrix has the unique property such that when another matrix is multiplied by it, the other matrix remains unchanged. This is similar to the number 1. a*1 = a. A * I = A, if the dimensions of I and A are the same.\";","\"\";","n = args[1];","result = this:null(n, n);","for i in [1..n]","result[i][i] = 1;","endfor","return result;"]},{"name":"null","owner":36,"perms":173,"preposition":-1,"code":["\":null(INT <size>) => Null matrix (O) of dimensions <size> by <size>.\";","\"All elements of O are 0.\";","\"\";","\"The Null Matrix has the property that is equivalent to the number 0; it reduces the original matrix to itself. a * 0 = 0. A * N = N.\";","\"\";","{m, ?n = m} = args;","result = {};","for i in [1..m]","result = {@result, {}};","for j in [1..n]","result[i] = {@result[i], 0};","endfor","endfor","return result;"]},{"name":"is_square","owner":36,"perms":173,"preposition":-1,"code":["\":is_square(M) => 1 iff dimensions of M are equal to each other.\";","{m} = args;","return (this:is_matrix(m) && (this:order(m) == 2)) && ((dim = this:dimensions(m))[1] == dim[2]);"]},{"name":"is_null","owner":36,"perms":173,"preposition":-1,"code":["\":is_null(M) => 1 iff M is O.\";","m = length(mat = args[1]);","if (!this:is_square(mat))","return 0;","endif","for i in [1..m]","for j in [1..m]","if (mat[i][j] != 0)","return 0;","endif","endfor","endfor","return 1;"]},{"name":"is_identity","owner":36,"perms":173,"preposition":-1,"code":["\":is_identity(M) => 1 iff M is I.\";","m = length(mat = args[1]);","if (!this:is_square(mat))","return 0;","endif","for i in [1..m]","for j in [1..m]","if ((mat[i][j] != 0) && ((i != j) ? 1 | (mat[i][j] != 1)))","return 0;","endif","endfor","endfor","return 1;"]},{"name":"cross_prod outer_prod vector_prod","owner":36,"perms":173,"preposition":-1,"code":["\":cross_prod(V1, V2) => VN, the vector perpendicular to both V1 and V2 with length equal to the area of the parallelogram spanned by V1 and V2, and direction governed by the rule of thumb.\";","\"\";","\"If A = a1i + a2j + a3k, represented as a list as {a1, a2, a3}\";","\"and B = b1i + b2j + b3k, or {b1, b2, b3}, then\";","\"\";","\"        |i  j  k |\";","\"A x B = |a1 a2 a3| = |a2 a3|i - |a1 a3|j + |a1 a2|k\";","\"        |b1 b2 b3| = |b2 b3|    |b1 b3|    |b1 b2|\";","\"\";","\"or, in list terms, as the list of the coefficients of i, j, and k.\";","\"\";","\"Note: i, j, and k are unit vectors in the x, y, and z direction respectively.\";","\"\";","\"The rule of thumb: A x B = C  If you hold your right hand out so that your fingers point in the direction of A, and so that you can curl them through B as you make a hitchhiking fist, your thumb will point in the direction of C.\";","\"\";","\"Put another way, A x B = ABsin(THETA) (A cross B equals the magnitude of A times the magnitude of B times the sin of the angle between them) This is expressed as a vector perpendicular the the A-B plane, pointing `up' if you curl your right hand fingers from A to B, and `down' if your right hand fingers curl from B to A.\";","\"\";","\"The cross product has many uses in physics. Angular momentum is the cross product of a particles position vector from the point it is rotating around and it's linear momentum (L = r x p). Torque is the cross product of position and Force (t = r x F).\";","\"\";","{v1, v2} = args;","if (((((l = length(v1)) != length(v2)) || (l != 3)) || (!this:is_vector(v1))) || (!this:is_vector(v2)))","return raise(\"E_INVVEC\", \"Invalid Vector Format\");","endif","mat = {{1, 1, 1}, v1, v2};","coeff = 1;","result = {};","for n in [1..3]","result = {@result, coeff * this:determinant(this:submatrix(1, n, mat))};","coeff = -coeff;","endfor","return result;"]},{"name":"norm length","owner":36,"perms":173,"preposition":-1,"code":["\":norm(V) => FLOAT\";","\":length(V) => FLOAT\";","\"The norm is the length of a vector, the square root of the sum of the squares of its elements.\";","\"\";","\"In school, we all should have learned the Pythagorean Theorem of right triangles: The sum of the squares of the sides of a right triagle is equal to the square of the hypoteneuse. The Theorem holds true no matter how many dimensions are being considered. The length of a vector is equal to the square root of the sum of the squares of its components. The dot product of a vector with itself happens to be the sum of the squares of its components.\";","\"\";","{v} = args;","return this:is_vector(v) ? sqrt(tofloat(this:dot_prod(v, v))) | E_TYPE;"]},{"name":"submatrix","owner":36,"perms":173,"preposition":-1,"code":["\":submatrix(i, j, M1) => M2, the matrix formed from deleting the ith row and jth column from M1.\";","{i, j, mat} = args;","{k, l} = this:dimensions(mat);","result = {};","for m in [1..k]","sub = {};","for n in [1..l]","if ((m != i) && (n != j))","sub = {@sub, mat[m][n]};","endif","endfor","if (sub)","result = {@result, sub};","endif","endfor","return result;"]},{"name":"dot_prod inner_prod scalar_prod","owner":36,"perms":173,"preposition":-1,"code":["\":dot_prod(V1, V2) => NUM\";","\":inner_prod(V1, V2) => NUM\";","\"The dot, or inner, product of two vectors is the sum of the products of the corresponding elements of the vectors.\";","\"If V1 = {1, 2, 3} and V2 = {4, 5, 6}, then V1.V2 = 1*4 + 2*5 + 3*6 = 32\";","\"\";","\"The dot product is useful in computing the angle between two vectors, and the length of a vector. See 'help $matrix_utils:subtended_angle' and 'help $matrix_utils:length'.\";","\"\";","\"A . B = ABcos(THETA)  (A dot B equals the magnitude of A times the magnitude of B times the cosine of the angle between them.)\";","\"\";","{v1, v2} = args;","if ((((l = length(v1)) != length(v2)) || (!this:is_vector(v1))) || (!this:is_vector(v2)))","return raise(\"E_INVVEC\", \"Invalid Vector Format\");","endif","temp = this:vector_mul(v1, v2);","result = (typeof(temp[1]) == INT) ? 0 | 0.0;","for n in [1..l]","result = result + temp[n];","endfor","return result;"]},{"name":"dimension*s","owner":36,"perms":173,"preposition":-1,"code":["\":dimensions(M) => LIST of dimensional sizes.\";","l = {length(m = args[1])};","if (typeof(m[1]) == LIST)","l = {@l, @this:dimensions(m[1])};","endif","return l;"]},{"name":"order","owner":36,"perms":173,"preposition":-1,"code":["\":order(M) => INT how many dimensions does this matrix have? 1 means vector\";","return length(this:dimensions(args[1]));"]},{"name":"scalar_vector_add scalar_vector_sub scalar_vector_mul scalar_vector_div","owner":36,"perms":173,"preposition":-1,"code":["\":scalar_vector_add(S, V) => VN such that VN[n] = V[n] + S...\";","\":scalar_vector_sub(S, V) => VN such that VN[n] = V[n] - S...\";","\":scalar_vector_mul(S, V) => VN such that VN[n] = V[n] * S...\";","\":scalar_vector_div(S, V) => VN such that VN[n] = V[n] / S...\";","\"Actually, arguments can be (S, V) or (V, S). Each element of V is augmented by S. S should be either an INT or a FLOAT, as appropriate to the values in V.\";","\"\";","\"I can see a reason for wanting to do scalar/vector multiplcation or division, but addition and subtraction between vector and scalar types is not done. I've included them here for novelty, and because it was easy enough to to.\";","\"\";","\"Scalar-vector multiplication stretches a vector along its direction, generating points along a line. One of the more famous uses from physics is Force equals mass times acceleration. F = ma. Force and acceleration are both vectors. Mass is a scalar quantity.\";","\"\";","if (typeof(args[1]) == LIST)","{vval, sval} = args;","else","{sval, vval} = args;","endif","if (!this:is_vector(vval))","return raise(\"E_INVVEC\", \"Invalid Vector Format\");","endif","type = verb[$ - 2..$];","for n in [1..length(vval)]","if (type == \"add\")","vval[n] = vval[n] + sval;","elseif (type == \"sub\")","vval[n] = vval[n] - sval;","elseif (type == \"mul\")","vval[n] = vval[n] * sval;","else","vval[n] = vval[n] / sval;","endif","endfor","return vval;"]},{"name":"subtended_angle","owner":36,"perms":173,"preposition":-1,"code":["\":subtended_angle(V1, V2) => FLOAT smallest angle defined by V1, V2 in radians\";","\"\";","\"Any two vectors define two angles, one less than or equal to 180 degrees, the other 180 degrees or more. The larger can be determined from the smaller, since their sum must be 360 degrees.\";","\"\";","\"The dot product of the two angles, divided by the lengths of each of the vectors is the cosine of the smaller angle defined by the two vectors.\";","\"\";","{v1, v2} = args;","if ((((l = length(v1)) != length(v2)) || (!this:is_vector(v1))) || (!this:is_vector(v2)))","return raise(\"E_INVVEC\", \"Invalid Vector Format\");","endif","return acos(tofloat(this:dot_prod(v1, v2)) / (this:norm(v1) * this:norm(v2)));"]},{"name":"column","owner":36,"perms":173,"preposition":-1,"code":["\":column(M, INT <n>) => LIST the nth column of M.\";","{mat, i} = args;","j = this:dimensions(mat)[1];","result = {};","for m in [1..j]","result = {@result, mat[m][i]};","endfor","return result;"]},{"name":"matrix_mul","owner":36,"perms":173,"preposition":-1,"code":["\":matrix_mul(M1, M2) => MN such that MN[m][n] = the dot product of the mth row of M1 and the transpose of thenth column of M2.\";","\"\";","\"Matrix multiplication is the most common and complex operation performed on two matrices. First, matrices can only be multiplied if they are of compatible sizes. An i by j matrix can only be multiplied by a j by k matrix, and the results of this multiplication will be a matrix of size i by k. Each element in the resulting matrix is the dot product of a row from the first matrix and a column from the second matrix. (See 'help $matrix_utils:dot_prod'.)\";","\"\";","{m1, m2} = args;","{i, j} = this:dimensions(m1);","{k, l} = this:dimensions(m2);","if (((j != k) || (!this:is_matrix(m1))) || (!this:is_matrix(m2)))","return raise(\"E_INVMAT\", \"Invalid Matrix Format\");","endif","result = {};","for m in [1..i]","sub = {};","for n in [1..l]","sub = {@sub, this:dot_prod(m1[m], this:column(m2, n))};","endfor","result = {@result, sub};","endfor","return result;"]},{"name":"scalar_matrix_mul scalar_matrix_div","owner":36,"perms":173,"preposition":-1,"code":["\":scalar_matrix_add(S, M) => MN such that MN[m][n] = MN[m][n] + S...\";","\":scalar_matrix_sub(S, M) => MN such that MN[m][n] = MN[m][n] - S...\";","\":scalar_matrix_mul(S, M) => MN such that MN[m][n] = MN[m][n] * S...\";","\":scalar_matrix_div(S, M) => MN such that MN[m][n] = MN[m][n] / S...\";","\"Actually, arguments can be (S, M) or (M, S). Each element of M is augmented by S. S should be either an INT or a FLOAT, as appropriate to the values in M.\";","\"I can see a reason for wanting to do scalar/matrix multiplication or division, but addition and subtraction between matrix and scalar types is not done. I've included them here for novelty, and because it was easy enough to do.\";","type = verb[$ - 2..$];","if (typeof(args[1]) == LIST)","{mval, sval} = args;","else","{sval, mval} = args;","endif","if (!this:is_matrix(mval))","return raise(\"E_INVMAT\", \"Invalid Matrix Format\");","endif","results = {};","if (typeof(mval[1][1] == LIST))","for n in [1..length(mval)]","results = {@results, this:(verb)(mval[n], sval)};","endfor","else","for n in [1..length(mval)]","results = {@results, this:(\"scalar_vector_\" + type)(mval[n], sval)};","endfor","endif","return results;"]},{"name":"is_matrix","owner":36,"perms":173,"preposition":-1,"code":["\"A matrix is defined as a list of vectors, each having the smae number of elements.\";","{m} = args;","if ((typeof(m) != LIST) || (typeof(m[1]) != LIST))","return 0;","endif","len = length(m[1]);","for v in (m)","if ((!this:is_vector(v)) || (length(v) != len))","return 0;","endif","endfor","return 1;"]},{"name":"is_vector","owner":36,"perms":173,"preposition":-1,"code":["\"A vector shall be defined as a list of INTs or FLOATs. (I'm not gonna worry about them all being the same type.)\";","flag = 1;","{v} = args;","if (typeof(v) != LIST)","return 0;","endif","for n in (v)","if (((ntype = typeof(n)) != INT) && (ntype != FLOAT))","flag = 0;","break;","endif","endfor","return flag;"]},{"name":"is_reflexive is_areflexive","owner":36,"perms":173,"preposition":-1,"code":["\":is_reflexive   (M) => 1 if M is a reflexive relation, -1 if areflexive,\";","\"                       0 otherwise.\";","\":is_areflexive does the same, but with 1 and -1 reversed.\";","{m} = args;","if (!this:is_square(m))","return raise(\"E_INVMAT\", \"Invalid Matrix Format\");","endif","good = bad = 0;","for n in [1..length(m)]","if (!m[n][n])","bad = 1;","else","good = 1;","endif","endfor","return this:_relation_result(good, bad, verb[4] == \"a\");"]},{"name":"is_symmetric is_asymmetric","owner":36,"perms":173,"preposition":-1,"code":["\":is_symmetric   (M) => 1 if M is a symmetric relation, -1 if asymmetric,\";","\"                       0 otherwise.\";","\":is_asymmetric does the same, but with 1 and -1 reversed.\";","{mat} = args;","if (!this:is_square(mat))","return raise(\"E_INVMAT\", \"Invalid Matrix Format\");","endif","good = bad = 0;","for m in [1..len = length(mat)]","for n in [m + 1..len]","if (mat[m][n] == mat[n][m])","good = 1;","else","bad = 1;","endif","endfor","endfor","return this:_relation_result(good, bad, verb[4] == \"a\");"]},{"name":"is_transitive is_atransitive","owner":36,"perms":173,"preposition":-1,"code":["\":is_transitive  (M) => 1 if M is a transitive relation, -1 if atransitive,\";","\"                       0 otherwise.\";","\":is_atransitive does the same, but with 1 and -1 reversed.\";","{mat} = args;","if (!this:is_square(mat))","return raise(\"E_INVMAT\", \"Invalid Matrix Format\");","endif","good = bad = 0;","for m in [1..len = length(mat)]","for n in [1..len]","if (mat[m][n])","for l in [1..len]","if (mat[n][l])","if (mat[m][l])","good = 1;","else","bad = 1;","endif","endif","endfor","endif","endfor","endfor","return this:_relation_result(good, bad, verb[4] == \"a\");"]},{"name":"_relation_result","owner":36,"perms":173,"preposition":-1,"code":["\"Common code for is_reflexive, is_symmetric, and is_transitive.\";","{good, bad, flag} = args;","if (good && (!bad))","result = 1;","elseif ((!good) && bad)","result = -1;","else","result = 0;","endif","return flag * result;"]},{"name":"is_partial_ordering","owner":36,"perms":173,"preposition":-1,"code":["\":is_partial_ordering(M) => 1 iff M is a reflexive, asymmetric, transitive relation.\";","{mat} = args;","return ((this:is_asymmetric(mat) == this:is_reflexive(mat)) == this:is_transitive(mat)) == 1;"]},{"name":"dd_to_dms dh_to_hms","owner":36,"perms":173,"preposition":-1,"code":["\":dd_to_dms(INT|FLOAT <degrees>) => LIST {INT <degrees>, INT <minutes>, FLOAT <seconds>}\";","\"This verb converts decimal degrees to degrees, minutes, and seconds.\";","dd = tofloat(args[1]);","s = (((dd - tofloat(d = toint(dd))) * 60.0) - tofloat(m = toint((dd - tofloat(d)) * 60.0))) * 60.0;","return {d, m, s};"]},{"name":"dms_to_dd hms_to_dh","owner":36,"perms":173,"preposition":-1,"code":["\":dms_to_dd(INT|FLOAT <deg>, INT|FLOAT <min>, INT|FLOAT <sec>) => FLOAT <deg>\";","\"This verb converts degrees/minutes/seconds to decimal degrees.\";","{d, m, s} = args[1..3];","d = tofloat(d);","m = tofloat(m);","s = tofloat(s);","return (d + (m / 60.0)) + (s / 3600.0);"]},{"name":"rect_to_polar","owner":36,"perms":173,"preposition":-1,"code":["\":rect_to_polar(INT|FLOAT <x>, INT|FLOAT <y>) => FLOAT <radius>, FLOAT <angle>.\";","\"This verb converts from rectangular (x,y) coordinates to polar (r, theta) coordinates.\";","{x, y} = args[1..2];","x = tofloat(x);","y = tofloat(y);","return {sqrt((x * x) + (x * x)), `atan(y, x) ! E_INVARG => 0.0'};"]},{"name":"polar_to_rect","owner":36,"perms":173,"preposition":-1,"code":["\":polar_to_rect(INT|FLOAT <radius>, INT|FLOAT <angle>) => FLOAT <x>, FLOAT <y>\";","\"This verb converts from polar (radius, angle) coordinates to rectangulat (x,y) coordinates.\";","{r, a} = args[1..2];","r = tofloat(r);","a = tofloat(a);","return {(r = r / (1.0 + (z2 = (z = tan(a / 2.0)) * z))) * (1.0 - z2), (r * 2.0) * z};"]},{"name":"F_to_C degF_to_degC","owner":36,"perms":173,"preposition":-1,"code":["\":F_to_C(INT|FLOAT <Fahrenheit>) => FLOAT <Celsius>\";","\"This verb converts Fahrenheit degrees to Celsius degrees.\";","return (tofloat(args[1]) - 32.0) / 1.8;"]},{"name":"C_to_F degC_to_degF","owner":36,"perms":173,"preposition":-1,"code":["\":C_to_F(INT|FLOAT <Celsius>) => FLOAT <Fahrenheit>\";","\"This verb converts Celsius degrees to Fahrenheit degrees.\";","return (tofloat(args[1]) * 1.8) + 32.0;"]},{"name":"convert","owner":36,"perms":173,"preposition":-1,"code":["\":convert(STR <units>, STR <units>) => FLOAT conversion factor | LIST errors.\";","\"This verb attempts to compute the conversion factor between two sets of units. If the two inputs are of the same type (two speeds, two lengths, etc.), the value is returned. If the two inputs are not of the same type, a LIST is returned as follows: {1, {FLOAT <value>, STR <units>}. {FLOAT <value>, STR <units>}}. The 1 indicates that the two inputs were correctly formed. <value> is the conversion factor of the input into the basic <units>. This error output is useful for determining the basic structure and value of an unknown unit of measure. If either of the inputs can not be broken down to known units, a LIST is returned as follows: {0, STR <bad input>}.\";","\"\";","\"The format of the input strings is fairly straight forward: any multiplicative combination of units, ending in an optional digit to represent that unit is raised to a power, the whole of which is preceeded by an initial value. Examples: \\\"100 kg m/sec2\\\", \\\"35 joules\\\", \\\"2000 furlongs/fortnight\\\"\";","\"\";","\"Some example uses:\";","\";$convert_utils:convert(\\\"2000 furlongs/fortnight\\\", \\\"mph\\\")\";","\"=> 0.744047619047619\";","\";$convert_utils:convert(\\\"kilowatt hours\\\", \\\"joules\\\")\";","\"=> 3600000.0\";","\"\";","\";$convert_utils:convert(\\\"furlongs\\\", \\\"mph\\\")\";","\"=> {1, {201.168, \\\"m\\\"}, {044704, \\\"m / s\\\"}}\";","\"\";","\";$convert_utils:convert(\\\"junk\\\", \\\"meters\\\")\";","\"=> {0, \\\"junk\\\"}\";","{havestr, wantstr} = args;","have = this:_do_convert(havestr);","want = this:_do_convert(wantstr);","if ((have && want) && (have[2] == want[2]))","return have[1] / want[1];","elseif (have && want)","return {1, {have[1], this:_format_units(@have[2])}, {want[1], this:_format_units(@want[2])}};","else","return {0, have ? wantstr | havestr};","endif"]},{"name":"_do_convert","owner":36,"perms":173,"preposition":-1,"code":["\"THIS VERB IS NOT INTENDED FOR USER USAGE.\";","\":_do_convert is the workhorse of $convert_utils:convert and is based loosely upon the 'units' Perl script the ships with BSD Unix.\";","\"Essentially, it breaks the input up into values and units, attempts to break each unit down into elementary (basic) units, modifies the value as it goes, until it has no more input or can not convert a unit into a basic unit.\";","instr = args[1];","units = this.basic_units_template;","value = 1.0;","top = 1;","\"Ensure that the division mark is a spearate word.\";","instr = $string_utils:substitute(instr, {{\"/\", \" / \"}});","while (instr)","\"Grab the next word to process\";","{first, instr} = $string_utils:first_word(instr);","if (first == \"/\")","\"Now we're working with values under the division mark - units with negative exponents.\";","top = 1 - top;","continue;","elseif (match(first, \"|\"))","\"The word was a value expressed as a ratio. Compute the ratio and adjust the value accordingly.\";","value = this:_do_value(first, value, top);","continue;","elseif ($string_utils:is_integer(first) || $string_utils:is_float(first))","\"The word was a value. Adjust the accumulated value accordingly.\";","value = top ? value * tofloat(first) | (value / tofloat(first));","continue;","elseif (match(first, \"[0-9]$\"))","\"The word ends with a digit, but isn't a value. It must be a powered unit. Expand it: cm3 => cm cm cm\";","subs = match(first, \"%([a-zA-Z]+%)%([0-9]+%)\");","first = substitute(\"%1\", subs);","power = toint(substitute(\"%2\", subs));","while (power > 0)","instr = (first + \" \") + instr;","power = power - 1;","endwhile","continue;","else","\"Check to see if the word starts with one or more metric prefix and attempt to evaluate the prefix.\";","{first, value, top} = this:_try_metric_prefix(first, value, top);","\"Check to see if we have a basic unit. If so, adjust the apropriate unit count.\";","if (index = first in this.basic_units)","units[index][2] = top ? units[index][2] + 1 | (units[index][2] - 1);","continue;","elseif (prop = `this.(first) ! E_PROPNF => 0')","\"Check to see if this is a known unit. If so, convert it and adjust the value and units.\";","result = this:_do_convert(prop);","value = top ? value * result[1] | (value / result[1]);","for i in [1..length(units)]","units[i][2] = top ? units[i][2] + result[2][i][2] | (units[i][2] - result[2][i][2]);","endfor","continue;","elseif (first[$] == \"s\")","\"Check to see if this is a normal 's'-ending plural, and try to do the above checks again.\";","temp = first[1..$ - 1];","if (index = temp in this.basic_units)","units[index][2] = top ? units[index][2] + 1 | (units[index][2] - 1);","continue;","elseif (prop = `this.(temp) ! E_PROPNF => 0')","result = this:_do_convert(prop);","value = top ? value * result[1] | (value / result[1]);","for i in [1..length(units)]","units[i][2] = top ? units[i][2] + result[2][i][2] | (units[i][2] - result[2][i][2]);","endfor","continue;","endif","endif","\"We were unable to find any conversion for the current word, so halt all operation and return 0.\";","return 0;","endif","endwhile","\"We were able to successfully convert each part of the input. Return the equivalent value and units.\";","return {value, units};"]},{"name":"_try_metric_prefix","owner":36,"perms":173,"preposition":-1,"code":["\"THIS VERB IS NOT INTENDED FOR USER USAGE.\";","\":_try_metric_prefix runs through the metrix multipliers and tries to match them against the beginning of the input string. If successful, the given value is adjusted appropritately, and the input string is modified. The verb loops until there are no more prefix matches. (Hence, \\\"kilodecameter\\\" can be matched with only one verb call.\";","\"If anyone knows of other possibilities here, please let me know.\";","{first, value, top} = args;","while (1)","if (subs = match(first, \"^yocto%(.*%)\"))","first = substitute(\"%1\", subs);","value = top ? value / 1e+24 | (value * 1e+24);","continue;","endif","if (subs = match(first, \"^zepto%(.*%)\"))","first = substitute(\"%1\", subs);","value = top ? value / 1e+21 | (value * 1e+21);","continue;","endif","if (subs = match(first, \"^atto%(.*%)\"))","first = substitute(\"%1\", subs);","value = top ? value / 1e+18 | (value * 1e+18);","continue;","endif","if (subs = match(first, \"^femto%(.*%)\"))","first = substitute(\"%1\", subs);","value = top ? value / 1e+15 | (value * 1e+15);","continue;","endif","if (subs = match(first, \"^pico%(.*%)\"))","first = substitute(\"%1\", subs);","value = top ? value / 1000000000000.0 | (value * 1000000000000.0);","continue;","endif","if (subs = match(first, \"^nano%(.*%)\"))","first = substitute(\"%1\", subs);","value = top ? value / 1000000000.0 | (value * 1000000000.0);","continue;","endif","if (match(first, \"^micron\"))","break;","endif","if (subs = match(first, \"^micro%(.*%)\"))","first = substitute(\"%1\", subs);","value = top ? value / 1000000.0 | (value * 1000000.0);","continue;","endif","if (subs = match(first, \"^milli%(.*%)\"))","first = substitute(\"%1\", subs);","value = top ? value / 1000.0 | (value * 1000.0);","continue;","endif","if (subs = match(first, \"^centi%(.*%)\"))","first = substitute(\"%1\", subs);","value = top ? value / 100.0 | (value * 100.0);","continue;","endif","if (subs = match(first, \"^deci%(.*%)\"))","first = substitute(\"%1\", subs);","value = top ? value / 10.0 | (value * 10.0);","continue;","endif","if (subs = match(first, \"^%(deca%|deka%)%(.*%)\"))","first = substitute(\"%2\", subs);","value = (!top) ? value / 10.0 | (value * 10.0);","continue;","endif","if (subs = match(first, \"^hecto%(.*%)\"))","first = substitute(\"%1\", subs);","value = (!top) ? value / 100.0 | (value * 100.0);","continue;","endif","if (subs = match(first, \"^kilo%(.*%)\"))","first = substitute(\"%1\", subs);","value = (!top) ? value / 1000.0 | (value * 1000.0);","continue;","endif","if (subs = match(first, \"^mega%(.*%)\"))","first = substitute(\"%1\", subs);","value = (!top) ? value / 1000000.0 | (value * 1000000.0);","continue;","endif","if (subs = match(first, \"^giga%(.*%)\"))","first = substitute(\"%1\", subs);","value = (!top) ? value / 1000000000.0 | (value * 1000000000.0);","continue;","endif","if (subs = match(first, \"^tera%(.*%)\"))","first = substitute(\"%1\", subs);","value = (!top) ? value / 1000000000000.0 | (value * 1000000000000.0);","continue;","endif","if (subs = match(first, \"^peta%(.*%)\"))","first = substitute(\"%1\", subs);","value = (!top) ? value / 1e+15 | (value * 1e+15);","continue;","endif","if (subs = match(first, \"^exa%(.*%)\"))","first = substitute(\"%1\", subs);","value = (!top) ? value / 1e+18 | (value * 1e+18);","continue;","endif","if (subs = match(first, \"^zetta%(.*%)\"))","first = substitute(\"%1\", subs);","value = (!top) ? value / 1e+21 | (value * 1e+21);","continue;","endif","if (subs = match(first, \"^yotta%(.*%)\"))","first = substitute(\"%1\", subs);","value = (!top) ? value / 1e+24 | (value * 1e+24);","continue;","endif","break;","endwhile","return {first, value, top};"]},{"name":"_format_units","owner":36,"perms":173,"preposition":-1,"code":["\"THIS VERB IS NOT INTENDED FOR USER USAGE.\";","\":_format_units takes the associative list of units and powers and construct a more user friendly string.\";","top = bottom = \"\";","for pair in (args)","if (pair[2] > 0)","top = tostr(top, \" \", pair[1], (pair[2] > 1) ? pair[2] | \"\");","elseif (pair[2] < 0)","bottom = tostr(bottom, \" \", pair[1], (pair[2] < -1) ? -pair[2] | \"\");","endif","endfor","if (bottom)","return ((top + \" /\") + bottom)[2..$];","else","return top[2..$];","endif"]},{"name":"K_to_C degK_to_degC","owner":36,"perms":173,"preposition":-1,"code":["\":K_to_C (INT|FLOAT <Kelvin>) => FLOAT <Celcius>\";","\"This verb converts Kelvin degrees to Celcius degrees.\";","return tofloat(args[1]) - 273.0;"]},{"name":"C_to_K degC_to_degK","owner":36,"perms":173,"preposition":-1,"code":["\":C_to_K (INT|FLOAT <Celcius>) => FLOAT <Kelvin>\";","\"This verb converts Celcius degrees to Kelvin degrees.\";","return tofloat(args[1]) + 273.0;"]},{"name":"F_to_R degF_to_degR","owner":36,"perms":173,"preposition":-1,"code":["\":F_to_R (INT|FLOAT <Fahrenheit>) => FLOAT <Rankine>\";","\"This verb converts Fahrenheit degrees to Rankine degrees.\";","return tofloat(args[1]) + 491.4;"]},{"name":"R_to_F degR_to_degF","owner":36,"perms":173,"preposition":-1,"code":["\":R_to_F (INT|FLOAT <Rankine>) => FLOAT <Fahrenheit>\";","\"This verb converts Rankine degrees to Fahrenheit degrees.\";","return tofloat(args[1]) - 491.4;"]},{"name":"_do_value","owner":36,"perms":173,"preposition":-1,"code":["\"THIS VERB IS NOT INTENDED FOR USER USAGE.\";","\":_do_value takes a string of the form <number>|<number>, interprets it as a ratio, and applies that ratio to the incoming 'value' accordingly with the 'top' input, and returns it back to the calling verb.\";","{first, value, top} = args;","{numer, denom} = $string_utils:explode(first, \"|\");","return top ? (value * tofloat(numer)) / tofloat(denom) | ((value * tofloat(denom)) / tofloat(numer));"]}]
